(function(window, undefined) {

var it = {};
window.it = it;
it.version = "v1.0.0";
var $Util = it.Util = {};
$Util._debug = true;
$Util.dropImg = new Image();
$Util.dropImg.src = "data:image/png;base64,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";
$Util.dropImg.client = {width:318,height:442,size:50,lineWidth:5,color:'#FFFFFF',startX:100,startY:300,withUnit:true}
$Util._blue = new Image();
$Util._blue.src = "data:image/png;base64,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";
$Util._green = new Image();
$Util._green.src = "data:image/png;base64,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";
$Util._yellow = new Image();
$Util._yellow.src = "data:image/png;base64,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";
$Util._red = new Image();
$Util._red.src = "data:image/png;base64,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";
$Util._imgMaps = {};

$Util.registerImg = function(id,src,client){
	var image = new Image();
	image.src = src;
	image.client = {};
	if(client){
		for(var pro in client){
			image.client[pro] = client[pro];
		}
	}
	$Util._imgMaps[id] = image;
}

// $Util.canvas = document.createElement('canvas');
$Util.isDebug = function(){
    return $Util._debug;
}
$Util.checkNotNull = function(object,name) {
    if(object == null){
    	if(name){
    	  throw name + "can\'t be null";	
    	}else{
    		return false;
    	}
    }
    return true;
}

$Util.translateJson = function (json) {
    if (typeof json === 'string') {
        try {
            json = JSON.parse(json);
        } catch (e) {
        }

    }
    return json;
}

$Util.clone = function(obj) {
    var o;
    if (typeof obj == "object") {
        if (obj === null) {
            o = null;
        } else {
            if (obj instanceof Array) {
                o = [];
                for (var i = 0, len = obj.length; i < len; i++) {
                    o.push($Util.clone(obj[i]));
                }
            } else {
                o = {};
                for (var j in obj) {
                    if(typeof(o[j]) == 'function' || j == '_alarmState'){
                        continue;
                    }
                    o[j] = $Util.clone(obj[j]);
                }
            }
        }
    } else {
        o = obj;
    }
    return o;
};

$Util.getComputedStyle = function(element){
   return element.currentStyle? element.currentStyle : window.getComputedStyle(element, null);
};

$Util.updateEmptyBillboardContent = function (billboard, content, args) {

    var args = this.ext({
        contentX: 0,
        contentY: 0,
        contentWidth: billboard.args.width,
        contentHeight: billboard.args.height - billboard.args.arrowHeight
    }, args);
    args = this.ext(billboard.args, args);
    var bg = this.getBillboardContent(args);
    var ct = bg.getContext('2d');
    ct.drawImage(content, args.contentX, args.contentY, args.contentWidth, args.contentHeight);
    billboard.s({
        'm.texture.image': bg
    });
}

$Util.updateTextBillboardText = function (billboard, text, bgColor) {
    text = text || '';
    var content = it.Util.getTextBillboardContent(text, bgColor);
    this.updateTextBillboardContent(billboard, content)
}

$Util.updateTextBillboardContent = function (billboard, content) {

    billboard.s({
        'm.texture.image': content
    });
    billboard.contentWidth = content.width;
    billboard.contentHeight = content.height;
    billboard.setScale(content.width / 2, content.height / 2, 1);
}

$Util.updateTitleBillboardContent = function (billboard, content) {
    var width = billboard.contentWidth;
    var height = billboard.contentHeight;
    var title = billboard.title;
    var canvas = it.Util.getTitleBillboardContent(title, content, width, height, billboard.content);
    billboard.s({
        'm.texture.image': canvas
    });
}

$Util.createEmptyBillboardForNode = function (node, args) {
    var board = this.createEmptyBillboard(args)
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.createEmptyBillboard = function (args) {
    args = it.Util.ext({
        width: 256,
        height: 128,
        radius: 16,
        arrowWidth: 16,
        arrowHeight: 16,
        bgColor: '#5B85B5',
    }, args);
    var c = this.getBillboardContent(args);
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.args = args;
    board.setScale(args.width, args.height, 1);
    board.setSelectable(false);
    board.contentWidth = args.width;
    board.contentHeight = args.height;
    board.isEmptyBillboard = true;
    return board;
};

$Util.createTitleBillboardForNode = function (node, args) {
    var board = this.createTitleBillboard(args);
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.getTitleBillboardContent = function (title, content, width, height, contentBackground) {

    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var context = canvas.getContext('2d');
    context.save();
    context.drawImage(title, Math.max(0, (canvas.width - title.width) / 2), 0, title.width, title.height);
    context.translate(0, title.height);
    if (contentBackground) {
        context.drawImage(contentBackground, Math.max(0, (canvas.width - contentBackground.width) / 2), 0, contentBackground.width, contentBackground.height, 0, 0, width, height - title.height);
    }
    context.drawImage(content, Math.max(0, (canvas.width - content.width) / 2), 0, content.width, content.height, 0, 0, width, height);

    return canvas;
}

$Util.createTitleBillboard = function (args) {
    args = it.Util.ext({
        title: '标题',
        titleColor: '#FFFFFF',
        titleFont: '24px LEDFont,sans-serif',
        titleBgColor: '#4a74a4',
        titleWidth: 256,
        titleHeight: 32,
        titleRadius: 16,
        width: 256,
        height: 128,
        radius: 0,
        arrowWidth: 0,
        arrowHeight: 0,
        bgColor: '#5B85B5',
    }, args);
    var title = this.getBillboardTitle(args);
    var content = this.getBillboardContent(args);
    var width = Math.max(title.width, content.width);
    var height = title.height + content.height;
    var canvas = it.Util.getTitleBillboardContent(title, content, width, height);
    var board = new mono.Billboard();
    board.title = title;
    board.content = content;
    board.s({
        'm.texture.image': canvas,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.args = args;
    board.setScale(canvas.width, canvas.height, 1);
    board.setSelectable(false);
    board.contentWidth = width;
    board.contentHeight = height;
    board.isTitleBillboard = true;
    return board;
};

$Util.createTextBillboard = function (text, gbColor) { // 考虑标题header，考虑Chart图表等
    var c = this.getTextBillboardContent(text, gbColor);
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
        'm.texture.wrapS':TGL.ClampToEdgeWrapping,
        'm.texture.wrapT':TGL.ClampToEdgeWrapping
    });
    board.setScale(c.width/2, c.height/2, 1);
    board.setSelectable(false);
    board.contentWidth = c.width;
    board.contentHeight = c.height;
    board.isTextBillboard = true;
    return board;
};

$Util.createTextBillboardForNode = function (node, text, gbColor) {
    text = text || '';
    var board = this.createTextBillboard(text, gbColor);
    var bb = node.getBoundingBox();
    board.setParent(node);
    board.p(0, bb.max.y, 0);
    return board;
};

$Util.createSpecailTextBillboard = function (text, gbColor,isHumOrTemp,canvas) { // 考虑标题header，考虑Chart图表等
    var c = null;
    if (isHumOrTemp) {
    	c = this.getHumOrTempCanvas(text, null, null, gbColor,canvas);
    }else{
    	c = this.getSpecialTextBillboard(text, null, null, gbColor,canvas);
    }
    var board = new mono.Billboard();
    board.s({
        'm.texture.image': c,
        'm.transparent': true,
        'm.alignment': mono.BillboardAlignment.bottomCenter,
        'm.vertical': false,
    });
    board.setScale(c.width / 2, c.height / 2, 1);
    board.setSelectable(false);
    board.contentWidth = c.width;
    board.contentHeight = c.height;
    board.isTextBillboard = true;
    board.invalidateTexture();
    return board;
};

$Util.getImageById = function(id,value) {
	if (!id) {
		return this.dropImg;
	}
	if (this._imgMaps 
	    && this._imgMaps[id]) {
		return this._imgMaps[id];
	} else if (this[id]) {
		return this[id];
	} else {
		return this.dropImg;
	}
};

/**
 * 刷新或创建温/湿度的Canvas
 */
$Util.getHumOrTempCanvas = function(text, titleText, endText, bgcolor, canvas) {
	var image = this.getImageById(bgcolor,text);
	var canvas = canvas || document.createElement('canvas');
	if (!image) {
		return canvas;
	}
	if (!image.client) {
		image.client = {width:318,height:442,size:50,lineWidth:5,color:'#FFFFFF',startX:100,startY:300};
	};
	color = image.client['color']||'#888888';
	var width = image.width,
		height = image.height;
	var context = canvas.getContext('2d');
	width = image.client['width']||image.width * 2, height = image.client['height']||image.height * 2;
	canvas.height = height;
    canvas.width = width;
	context.drawImage(image, 0, 0, width, height);
	var x = parseInt(image.client['startX'])||(height - 50);
	var y = parseInt(image.client['startY'])||(height - 50);
	if (text) {
		var csize = parseInt(image.client['size'])||80;
		context.font = csize + 'px "Microsoft Yahei" ';
		context.strokeStyle = color;
		context.fillStyle = color;
		context.textAlign = 'left';
		context.textBaseline = 'middle';
		context.lineWidth = parseInt(image.client['lineWidth'])||8;	
		if (image.client['stroke']) {
			context.strokeText(text, x, y);
		}else{
			context.fillText(text, x, y);
		}
	}
	return canvas;
};

$Util.createHumOrTempCanvas = function(text,unit, bgcolor, canvas){
	var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = image.client['fontFamily']||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = 'bold '+csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
            if (image.client['withUnit'] && unit) {
                var width = context.measureText(text).width;
                var unitSize = parseInt(csize/2)||5;
                context.font = 'bold '+unitSize + 'px "Microsoft Yahei"';
                if (image.client['stroke']) {
                     context.strokeText(unit, x+width, y);
                }else{
                     context.fillText(unit, x+width, y);
                }
            }

        }
        return canvas;
};

/**
 * 目前流量的billboard用到了这个
 */
$Util.getSpecialTextBillboard = function(text,titleText,endText,bgcolor,canvas){
    var canvas = canvas || document.createElement('canvas');
    var context = canvas.getContext('2d');
    var width,height;
    // if(isHumOrTemp){
    //   width  = 318;
    //   height = 442;
    // }else{
      width = 512;
      height = 256;
    // }
    var arrowHeight = height / 4;
    var arrowWidth = width / 4;
    canvas.height = height + arrowHeight;
    canvas.width = width;
    
    this.getBillboardContent({
        width: width,
        height: height + arrowHeight,
        radius: width / 16,
        arrowWidth: arrowWidth,
        arrowHeight: arrowHeight,
        bgColor: bgcolor,
        canvas: canvas,
        // isHumOrTemp:isHumOrTemp
    });
    /*
    if(isHumOrTemp){
        text = parseInt(text)+"";
        // text = text+"";
        height= height + arrowHeight;
        var color='#888888';
        var bgImage = this.dropImg;
        if (bgcolor 
        	&& this._imgMaps 
        	&& this._imgMaps[bgcolor]) {
        	color = '#FFFFFF';
            bgImage = this._imgMaps[bgcolor];
            // context.drawImage(this._imgMaps[bgcolor],30,10,288,432);
        }else if (bgcolor && this[bgcolor]) {
            color='#FFFFFF';
            bgImage = this[bgcolor];
        	// context.drawImage(this[bgcolor],30,10,288,432); 
        }else{
            color='#888888';
            bgImage = this.dropImg;
        	// context.drawImage(this.dropImg,30,10,288,432); 
        }
        width = bgImage.width*2,height = bgImage.height*2;
        context.drawImage(bgImage,30,10,width,height); 

        if(text){
            var csize = 80;
            context.font = csize+'px "Microsoft Yahei" ';
            context.strokeStyle=color;
            // context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth=8;
            if(text.length == 2){
                context.strokeText(text, 2*height/10-10, 2*height/3-50);
            }else if(text.length <2){
                context.strokeText(text, 2*height/10+10, 2*height/3-50);
            }else{
                context.strokeText(text, 2*height/10-30, 2*height/3-50);
            }
        }
        if(endText){
            var esize = 50;
            context.font = esize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(endText, width-height/10, height/2+50);
        }
    }else{
    	*/
        var color='white';
        if(titleText){
            var tsize = 50;
            context.font = tsize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(titleText, height/10, height/5);
        }
        if(text){
            var csize = 120;
            context.font = csize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(text, 2*height/10, 2*height/3);
            context.strokeStyle=color;
            context.lineWidth=4;
            context.strokeText(text, 2*height/10, 2*height/3);
        }
        if(endText){
            var esize = 60;
            context.font = esize+'px "Microsoft Yahei" ';
            context.fillStyle = color;
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            context.fillText(endText, width-height/10, height/2+20);
        }
    // }
    return canvas;
};

$Util.getTextBillboardContent = function (label, bgcolor, args) {

    args = args || {};
    var canvas = document.createElement('canvas');
     var context = canvas.getContext('2d');
     context.font = "120px LEDFont,sans-serif";
     
     var array = [];
     if(label.indexOf("\n")){
         array= label.split("\n");
     }else{
         array= [label]
     }
     var length = 0;
     for(var i = 0;i < array.length;i ++){
        if(i == 0){
           length = context.measureText(array[i]).width;
        }else{
           length = Math.max(context.measureText(array[i]).width,length);
        }
    }

    var size = mono.Utils.getMaxTextSize(array, context.font);
    var c_width = mono.Utils.nextPowerOfTwo(length);
    var oHeight = size.height;
    var arrowHeight = oHeight / 4;
    var arrowWidth = c_width / 4;
    var c_height = mono.Utils.nextPowerOfTwo(oHeight + arrowHeight);
   
    canvas.height = c_height;
    canvas.width = c_width;
    var lineHeight = c_height / array.length;
    var oLineHeight = oHeight / array.length;

    args = it.Util.ext({
        labelColor: 'white',
        width: c_width,
        height: c_height,
        radius: (c_width / 16),
        arrowWidth: arrowWidth,
        arrowHeight: arrowHeight,
        bgColor: bgcolor,
        canvas: canvas
    }, args);
    this.getBillboardContent(args);

    context.fillStyle = args.labelColor;
    context.textBaseline = 'middle';
    context.font = "120px LEDFont,sans-serif";
    for (var i = 0; i < array.length; i++) {
        var text = array[i];
        length = context.measureText(text).width;
        context.fillText(text, (c_width - length) / 2, lineHeight * (i + 0.5));
    }
    return canvas;
};

/**
 * 根据相关的参数画一个外边框
 * @param args
 * @returns {*}
 */
$Util.getBillboardTitle = function (args) {
    var width = args.titleWidth = mono.Utils.nextPowerOfTwo(args.titleWidth) || 192;
    var height = args.titleHeight = mono.Utils.nextPowerOfTwo(args.titleHeight) || 64;
    var radius = args.titleRadius || 8;

    var canvas = args.canvas;
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
    }
    var context = canvas.getContext('2d');
    context.globalAlpha = args.globalAlpha || 0.8;
    context.fillStyle = args.titleBgColor || '#5B85B5';
    context.font = args.titleFont || '120px LEDFont,sans-serif';
    var titleSizeWidth = args.titleSizeWidth = context.measureText(args.title).width;
    var titleSizeHeight = args.titleSizeHeight = mono.Utils.getMaxTextSize(args.title, args.titleFont);
    context.beginPath();
    context.moveTo(0, height);
    context.lineTo(0, radius);
    context.arcTo(0, 0, radius, 0, radius);
    context.lineTo(width - radius, 0);
    context.arcTo(width, 0, width, radius, radius);
    context.lineTo(width, height);
    context.closePath();
    context.fill();
    context.textBaseline = 'top';
    context.fillStyle = args.titleColor || '#A5855B';
    context.fillText(args.title, (width - titleSizeWidth) / 2, 2);
    context.restore();
    context.restore();
    return canvas;
}

/**
 * 根据相关的参数画一个下面有三角行的外边框
 * @param args
 * @returns {*}
 */
$Util.getBillboardContent = function (args) {

    args = it.Util.ext({width: 256, height: 128, radius: 20, arrowWidth: 50, arrowHeight: 30}, args);
    var width = args.width;
    var height = args.height;
    var radius = args.radius;
    var arrowWidth = args.arrowWidth;
    var arrowHeight = args.arrowHeight;

    var canvas = args.canvas;
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
    }
    if(!args.isHumOrTemp){
        var offset = 0;
        if(args.border){
            offset = args.borderWidth/2;
        }
        var context = canvas.getContext('2d');
        context.globalAlpha = args.globalAlpha || 0.8;
        context.fillStyle = args.bgColor || '#5B85B5';
        context.save();
        context.beginPath();
        context.moveTo(radius+offset, offset);
        context.lineTo(width - radius -offset, offset);
        context.arcTo(width-offset, offset, width-offset, radius+offset, radius);
        context.lineTo(width-offset, height - arrowHeight - radius-offset);
        context.arcTo(width-offset, height - arrowHeight-offset, width - radius-offset, height - arrowHeight-offset, radius);
        context.lineTo(width / 2 + arrowWidth / 2, height - arrowHeight-offset);
        context.lineTo(width / 2, height-offset);
        context.lineTo(width / 2 - arrowWidth / 2, height - arrowHeight-offset);
        context.lineTo(radius+offset, height - arrowHeight-offset);
        context.arcTo(offset, height - arrowHeight-offset, offset, height - arrowHeight - radius-offset, radius);
        context.lineTo(offset, radius+offset);
        context.arcTo(offset, offset, radius+offset, offset, radius);
        context.closePath();
        context.fill();
        if(args.border){
            context.strokeStyle = args.borderColor;
            context.lineWidth = args.borderWidth;
            context.stroke();
        }
        context.restore();
    }
    return canvas;
}

/**
 * 获取node的中心点，有些时候position并不是其真正的中心点，有可能对象自身的坐标并不是从中间开始的
 * @param node
 * @returns {position}
 */
$Util.getNodeCenterPosition = function (node) {
    if (!node) return null;
    var boundingBox = node.getBoundingBox();
    var offx = (boundingBox.max.x + boundingBox.min.x)/2*node.getScaleX();
    var offy = (boundingBox.max.y + boundingBox.min.y)/2*node.getScaleY();
    var offz = (boundingBox.max.z + boundingBox.min.z)/2*node.getScaleZ();
    var position = node.getWorldPosition();
    position.setX(position.x + offx);
    position.setY(position.y + offy);
    position.setZ(position.z + offz);
    return position;
};

$Util.formatDate = function (date, format) {
    if(!date || !format){
        return null;
    }
    var o = {
        'M+': date.getMonth() + 1,
        'd+': date.getDate(),
        'h+': date.getHours(),
        'm+': date.getMinutes(),
        's+': date.getSeconds(),
        'q+': Math.floor((date.getMonth() + 3) / 3),
        'S': date.getMilliseconds()
    };
    if (/(y+)/.test(format))
        format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
    for (var k in o)
        if (new RegExp('(' + k + ')').test(format))
            format = format.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length)));
    return format;
};

$Util.formateDateTime = function(date) {
	if (!date) {
		return "";
	}
	if (typeof(date) == 'string') {
		var local = new Date(date);
		var utc = local.getTime() + local.getTimezoneOffset() * 60000;
		date = new Date(utc);
	}
	if (date instanceof Date) {
		return it.Util.formatDate(date, 'yyyy-MM-dd hh:mm:ss');
	} else {
		return date;
	}
};

/**
 * 第一个参数是target, 返回target
 * @returns {*|{}}
 */
$Util.ext = function () {
    /*
     　　*target被扩展的对象
     　　*length参数的数量
     　　*deep是否深度操作
     　　*/
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // target为第一个参数，如果第一个参数是Boolean类型的值，则把target赋值给deep
    // deep表示是否进行深层面的复制，当为true时，进行深度复制，否则只进行第一层扩展
    // 然后把第二个参数赋值给target
    if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};

        // 将i赋值为2，跳过前两个参数
        i = 2;
    }

    // target既不是对象也不是函数则把target设置为空对象。
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
        target = {};
    }

    // 如果只有一个参数，则把jQuery对象赋值给target，即扩展到jQuery对象上
    if (length === i) {
        target = this;

        // i减1，指向被扩展对象
        --i;
    }

    // 开始遍历需要被扩展到target上的参数

    for (; i < length; i++) {
        // 处理第i个被扩展的对象，即除去deep和target之外的对象
        if ((options = arguments[i]) != null) {
            // 遍历第i个对象的所有可遍历的属性
            for (name in options) {
                // 根据被扩展对象的键获得目标对象相应值，并赋值给src
                src = target[name];
                // 得到被扩展对象的值
                copy = options[name];

                // 这里为什么是比较target和copy？不应该是比较src和copy吗？
                if (target === copy) {
                    continue;
                }

                // 当用户想要深度操作时，递归合并
                // copy是纯对象或者是数组
                if (deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) )) {
                    // 如果是数组
                    if (copyIsArray) {
                        // 将copyIsArray重新设置为false，为下次遍历做准备。
                        copyIsArray = false;
                        // 判断被扩展的对象中src是不是数组
                        clone = src && jQuery.isArray(src) ? src : [];
                    } else {
                        // 判断被扩展的对象中src是不是纯对象
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // 递归调用extend方法，继续进行深度遍历
                    target[name] = jQuery.extend(deep, clone, copy);

                    // 如果不需要深度复制，则直接把copy（第i个被扩展对象中被遍历的那个键的值）
                } else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    // 原对象被改变，因此如果不想改变原对象，target可传入{}
    return target;
};

$Util.jsonUtil = {
    object2String: function (obj) {
        try {
            var str = JSON.stringify(obj);
            return str;
        } catch (e) {
            if ($Util.isDebug()) {
                throw  e;
            } else {
                console.error('json对象转字符串失败', obj);
            }
        }
    },
    string2Object: function (str) {
        try {
            var obj = JSON.parse(str);
            return obj;
        } catch (e) {
            // if (Util.isDebug()) {
            //     throw  e;
            // } else {
                console.error('字符串转json对象失败', str);
            // }
        }
    }
};

$Util.o2s = function (o) {
    return $Util.jsonUtil.object2String(o);
}

$Util.s2o = function (s) {
    return $Util.jsonUtil.string2Object(s);
}

$Util.toJsonArray = function (json) {
    if (!json) {
        return [];
    }
    var jsonObject = json;
    if (typeof json === "string") {
        jsonObject = $Util.s2o(json);
    }
    var jsonObjects;
    if (jsonObject instanceof Array) {
        jsonObjects = jsonObject;
    } else {
        jsonObjects = [jsonObject];
    }
    return jsonObjects;
}

$Util.findFirstObjectByMouse = function (network, e, filter) {
    if (!filter) {
        filter = function (object3d) {
            return !(object3d instanceof mono.Billboard);
        }
    }
    var objects = network.getElementsByMouseEvent(e);
    if (objects.length) {
        for(var i=0;i<objects.length;i++){
            var first = objects[i];
            var object3d = first.element;
            if(filter(object3d)){
                return first;
            }
        }
    }
    return null;
};

$Util.compare = function(a, b) {
	if (a == b) {
		return 0;
	}

	if (a.length == 0) {
		return 1;
	}
	if (b.length == 0) {
		return -1;
	}
	if (a > b) {
		return 1;
	} else if (b > a) {
		return -1;
	} else {
		return 0;
	}

};

$Util.getEstimateOverviewPositionAndTarget = function(network,angle){
	if (!network) { 
		return null;
	}
	var camera = network.getCamera();
	var bb = network.getNetworkBoundingBox();
     if(bb == null){
        return null;
      }
      var center = bb.center();
      var sub1 = new mono.Vec3(0,bb.max.y - bb.min.y,bb.max.z - bb.min.z);
      var sub2 = new mono.Vec3(bb.max.x - bb.min.x,0,0,0);
      var sub = sub1.clone();
      if(sub.length() < sub2.length()){
          sub = sub2.clone();
      }
      var position;
      if(angle){
        var l = sub1.length();
        sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
        sub1.setLength(l);
      }
      position = new mono.Vec3().addVectors(center,sub1.multiplyScalar(0.5));
        var fov = camera.fov,aspect = camera.aspect;
        var length = sub.length() / 2 / Math.tan(fov * Math.PI/180);
        position.add(sub1.normalize().multiplyScalar(length));
      // this._camera.setPosition(position);
      // this._camera.lookAt(center);
      return {target:center,position:position};
      // this._overviewDistance = this._camera.getDistance();
};

/**
 * 计算boudingBox
 * 这里计算时注意：这个boundingBox的相关坐标都变成了绝的坐标值，所以这里算之前重新clone了一份，然后将位置置为原点，这样boundingBox就对称了
 * @includeChildren 是计算boundingBox一定包含孩子的的
 */
$Util.getBoundingBox = function(node,includeChildren) {
	if (!node) {
		return null;
	}
	if (node instanceof mono.Billboard) {
		return null;
	}
	var box = node.getBoundingBox?node.getBoundingBox():null;
	if (!includeChildren 
		&& box
		&& box.size().x 
		&& box.size().x != -Infinity
		&& box.size().x != Infinity) {
		return box;
	}
	var vertices = [];
	var cNode = node.clonePrefab();
	cNode.setPosition(0,0,0);
	$Util.getTransformVertices(cNode, vertices);
	box = new mono.BoundingBox();
	box.setFromPoints(vertices); //虽然将移到了0，可是算出来的boundingBox的Y还是绝对的 ，注意！！！
	return box;
};

$Util.getTransformVertices = function(node, vertices) {
    if (vertices == null) {
        vertices = [];
    }
    var i, vertex;
    if ( node instanceof TGL.Node || node instanceof TGL.Billboard) {
        for ( i = 0; i < node.vertices.length; i++) {
            vertex = node.vertices[i].clone();
            if ( node instanceof TGL.Billboard) {
                vertex.x *= node.rotation3d.x;
                vertex.y *= node.rotation3d.y;
                vertex.add(node.getPosition());
            } else {
                vertex.applyMatrix4(node.worldMatrix);
            }
            vertices.push(vertex);
        }
        for (var i = 0; i < (node._childList ? node._childList.size() : 0); i++) {
            var child = node._childList.get(i);
            if (child.getClient('it_data_id') == node.getClient('it_data_id') 
            	&& node.getClient('type') != 'parkSkybox'//不是天空盒
            	) { 
            	$Util.getTransformVertices(child, vertices);
            }
        }
    }
    return vertices;
};

/**
 * 动画移动镜头
 * @method playCameraAnimation
 * @static
 * @param  {mono.Camera}   camera   镜头
 * @param  {mono.Vec3}   [pos=null]      镜头位置，如果未提供，则取镜头当前的位置
 * @param  {mono.Vec3}   [target=null]   镜头焦点，如果未提供，则取镜头当前的焦点
 * @param  {Number}   [time=2000]     动画播放的时间，默认为2000ms
 * @param  {Function} callback 动画播放完后执行的回调函数
 * 注意：改变camera的target和pos，应该尽快的让target设置到位，否则当lookAt某个对象时，target差的较多的话，会一直看不到对象
 * play的过程：
 *       1、移动camera的target设置成新的target,并且distance最大的(跟最终的camera的distance比较)；
 *       2、旋转Camera(离地面最高点)至pos的上面；
 *       3、拉近
 * 有可能一个动画只有1，2，3中的一步或两步
 */
$Util.playCameraAnimation = function(camera, pos, target, time, callback) {
  if($Util.activeAnimates && $Util.activeAnimates instanceof Array){ //先停止之前的animate，有可能还没有执行完
    for(var a = 0 ; a < $Util.activeAnimates.length ; a++){
      $Util.activeAnimates[a].stop();
    }
  }
    pos = pos || camera.p();
    target = target || camera.getTarget();
    if(pos.equals(camera.getPosition()) 
       && target.equals(camera.target)){ //位置没变就直接返回吧
        callback&&callback();
      return null;
    }
    var offset=camera.getPosition().sub(camera.getTarget());
    var t_position=new mono.Vec3().addVectors(offset, target);
    time = time || 3000;
    // time = 3000;

    var angles = mono.Utils.getVectorAngles(target, t_position);//camera.getTarget(), camera.p()
    var angles2 = mono.Utils.getVectorAngles(target, pos);
    var dha = angles2[0] - angles[0];
    if (dha > 180) {
        dha = dha - 360;
    } else if (dha < -180) {
        dha = dha + 360;
    }
    var dva = angles2[1] - angles[1];
    if (dva > 180) {
        dva = dva - 360;
    } else if (dva < -180) {
        dva = dva + 360;
    }

    var t1 = camera.getTarget();
    var t2 = target;
    var d1 = camera.getDistance(),d2 = new mono.Vec3().subVectors(pos, target).length();
    var ang00 = angles[0],ang01 = angles[1],ang10 = angles2[0],ang11 = angles2[1];

    var animate2 = new mono.Animate({
      from:0,
      to:1,
      repeat:1,
      dur:time/3,
      onPlay : function(){
        this.isPlaying = true;
      },
      onUpdate : function(value){ // 2、拉近，x,y,z都会改变，并且拉近镜头的distance
            var hAngle = ang10; // 已经变到头了
            // var vAngle = ang01 + dva * value;
            // var vAngle = ang01>ang11?(ang01 + dva * value):(ang01 + dva );
            var vAngle = ang01>ang11?(ang01 + dva * value):ang11;//:ang10(还不能直接ang10，如果180的话会多转一圈);
            // var vAngle = ang01>ang11?ang01:ang11;
            var t = t2;//new mono.Vec3().lerpVectors(t1, t2, value);
            var d = d1 + (d2 - d1) * value;
            // update 2017-09-14 Kevin 当设备平视，有可能直接从animate0到animate2 //2017-8-31没有改全，
            // var d = d1 > d2 ? d1 : d2; 
            if(d2 > d1 && dha == 0 && ang11 < ang01){ // 没走animate1，直接从animate0到animate2,d2是终止的，有可能老早就到了d2
              // d = (d1 + (d2 - d1) * value); 
               d = d2; 
            }
            var newPos = new mono.Vec3();
            newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
            camera.p(newPos);
            camera.lookAt(t);
      },
      onDone : function() {
            if (callback)
                callback();
      },
      onStop : function(){
            // delete this.isPlaying;
      }
    });

    var animate1 = new mono.Animate({ // 1、旋转到正面，主要是改变x和z，镜头的distance也不变
      from: 0,
      to: 1,
      repeat: 1,
      dur: time / 3,
      onPlay: function() {
        // console.log('onplay 1');
        this.isPlaying = true;
      },
      onUpdate: function(value) {
        var hAngle = ang00 + dha * value; // 纬度变成用新的
        // var vAngle = ang01>ang11?ang01:(ang01 + dva * value);//  经度开始不变，应该用最大的，否则由近到远时(如从看到机柜到看到整个楼层)旋转有可能在内部，不能看到整个
        var vAngle = ang01 > ang11 ? ang01 : ang11;
        var t = t2; //new mono.Vec3().lerpVectors(t1, t2, value); //

        // add by Kevin 2017-06-05 ，当不需要进行animate2时(即ang11 >= ang01)时，直接用d1(目标distance)
        var d = d1 > d2 ? d1 : d2; //(d1+(d2-d1)*value); // camera的距离用最大的那个
        // if(ang11 >= ang01){
            // var d = d2;
        // }
        if(d1 > d2 && ang11 >= ang01){ // update 2017-08-31 Kevin 设备到机柜时：d1<d2 && ang11 >= ang01
            d = (d1 + (d2 - d1) * value); 
        }

        var newPos = new mono.Vec3();
        newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        camera.p(newPos);
        camera.lookAt(t);
      },
      onDone: function() {
        //     if (callback)
        //         callback();
        d1 = camera.getDistance(); // 第一步运行完后，距离重新算一下
        t1 = camera.getTarget();
      },
      onStop: function() {
        // console.log('stop1');
        if (this.isPlaying) {  // add by Kevin 2017-06-01 ，不这样有可能会有死循环，当callback中也有playCamera时，当前的animate永远是激活状态的，stop时总会调到
          delete this.isPlaying;

          if (ang11 >= ang01) {
            callback && callback();
          } else {
            animate2.play();
          }
        }
      }
    });

    // 起点是当前Camera没动之前的pos和target
    //点是pos是：在离target的距离为原始的(当前Camera)tar到pos之间和目标tar到目标pos之间的最大的距离，并且离平面高度为原始的和最终的最高的；target：最终的目标target
    var animate0 = new mono.Animate({ // 移动target，将target移至新的target
      from: 0,
      to: 1,
      dur: time / 3,
      onPlay: function() {
        this.isPlaying = true;
      },
      onUpdate: function(value) {
        var hAngle = ang00; // 纬度变成用新的
        // var vAngle = ang01;//  经度开始不变，应该用最大的，否则由近到远时(如从看到机柜到看到整个楼层)旋转有可能在内部，不能看到整个
        var vAngle = ang01 > ang11 ? ang01 : (ang01 + dva * value); //  经度开始不变，应该用最大的，否则由近到远时(如从看到机柜到看到整个楼层)旋转有可能在内部，不能看到整个
        var t = new mono.Vec3().lerpVectors(t1, t2, value); //
        // camera的距离用最大的那个，
        // add by Kevin 2017-06-05 ，可是当不需要旋转(aminate2,并且hAngle为0)时，应该直接一步到位用: (d1 + (d2 - d1) * value)
        // var d = d1 > d2 ? d1 : (d1 + (d2 - d1) * value); // camera的距离用最大的那个
        var d = (d1 + (d2 - d1) * value); 
        if(d1 > d2 && (dha != 0 || ang11 < ang01)){
            d = d1; 
        }
        var newPos = new mono.Vec3();
        newPos.x = t.x + d * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.z = t.z + d * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        newPos.y = t.y + d * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
        camera.p(newPos);
        camera.lookAt(t);
      },
      onDone: function() {

      },
	onStop: function() { // stop 一定会被执行，onDone则不一定
		// console.log('stop0');
		if (this.isPlaying) {
			delete this.isPlaying;
			if (dha == 0 && ang11 >= ang01) { // 纬度为0，并其经度已经调整到位了，直接退出  ang11 >= ang01 
				callback && callback();
			} else if (dha != 0) { //还需要调整纬度
				setTimeout(function() {
					animate1.play();
				}, 0); // onStop 是异步的 
			} else { // 纬度不需要调整了，单是经度有偏差
				setTimeout(function() {
					animate2.play();
				}, 0); // onStop 是异步的 
			}
		}
	}
 });

    // 不用动画链，因为有可能有些动画不需要执行
    // animate0.chain(animate1);
    // animate1.chain(animate2);
    if(dha == 0 && ang11 >= ang01){ //当只有一段时，时间全耗在这里
        animate0.dur = time;
        animate0.finish = time;
    }else if (dha == 0){
        animate2.dur = time*2/3; //当只有两段时，第一段移动焦点1/3,拉近2/3
        animate2.finish = time*2/3; 
    }else if (ang11 < ang01) { // else if (ang11 >= ang01) { update 2017-08-09
        animate1.dur = time*2/3; //当只有两段时，第一段移动焦点1/3,旋转2/3
        animate1.finish = time*2/3; 
    }
    animate0.play();
    $Util.activeAnimates = [animate0,animate1,animate2];
    return [animate0,animate1,animate2];
};

$Util.getZoomEstimateOverviewTargetAndPosition = function(network, angle) {
	if (!network) {
		return;
	}
	var bb = network.getNetworkBoundingBox();
	if (bb == null) {
		return;
	}
	var center = bb.center();
	var sub1 = new $Vec3(0, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
	var sub2 = new $Vec3(bb.max.x - bb.min.x, 0, 0, 0);
	var sub = sub1.clone();
	if (sub.length() < sub2.length()) {
		sub = sub2.clone();
	}
	var position;
	if (angle) {
		var l = sub1.length();
		sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
		sub1.setLength(l);
	}
	position = new $Vec3().addVectors(center, sub1.multiplyScalar(0.5));
	var fov = network._camera.fov,
		aspect = network._camera.aspect;
	var length = sub.length() / 2 / Math.tan(fov * Math.PI / 180);
	position.add(sub1.normalize().multiplyScalar(length));
	// network._camera.setPosition(position);
	// network._camera.lookAt(center);
	return {
		target: center,
		position: position
	};
	// this._overviewDistance = this._camera.getDistance();
};

var jsonUtil = window.jsonUtil = $Util.jsonUtil;


    

var $Base = function(){
	mono.PropertyChangeDispatcher.call(this);
};
it.Base = $Base;

mono.extend($Base,mono.PropertyChangeDispatcher,{
   onPropertyChange : function (property, oldValue, newValue) {
   }
});
/**
 * 类别管理
 */

var $Category = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._description = parameters.description;
    this._selectable = true; // 是否有选中效果
    this._stopAlarmPropagationable = false; // 是否终止告警传播
    this._lazyLoad = false;  // 延迟加载
    this._lazyLoadScene = ""; // 延迟加载的场景 ？
    this._rotationExp = {}; // 旋转支持表达式，如：{y : "x % 2 ? Math.IP : 0"};
    this._positionExp = {}; // 
    this._visible = parameters.visible == undefined ? true : parameters.visible; //默认是否显示其对应的it.Data实例
    this._userDataMap = {}; //存储用户自定义属性
    this.handleDoubleClick = null;
    this.handleClick = null;
};

it.Category = $Category;

mono.extend($Category, $Base, {
    ___accessor: ['description', 'stopAlarmPropagationable'],
    getId: function () {
        return this._id;
    },

    setId: function (id) {
        if (this._id === undefined) {
            this._id = id;
        } else {
            throw 'Can not set id';
        }
    },

    setVisible: function (visible) {
        this._visible = visible;
    },

    isVisible: function () {
        return this._visible;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },

    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {

        if (json.selectable == undefined) {
            json.selectable == true;
        }
        this._id = json.id;
        this._description = json.description;
        this._visible = json.visible;
        this._selectable = json.selectable; // 是否有选中效果
        this._stopAlarmPropagationable = json.stopAlarmPropagationable; // 是否终止告警传播
        this._lazyLoad = json.lazyLoad;  // 延迟加载
        this._lazyLoadScene = json.lazyLoadScene || ''; // 延迟加载的场景 ？
        this._rotationExp = json.rotationExp || {}; // 旋转支持表达式，如：{y : "x % 2 ? Math.IP : 0"};
        this._positionExp = json.positionExp || {}; //
    },
});
var $Data = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._ii = parameters.ii;
    this._id = parameters.id;
    this._description = parameters.description;
    this._position = parameters.position || new mono.Vec3; // 应该考虑把json格式换成mono.Vec3
    this._position2d = parameters.position2d || new mono.Vec2;
    this._rotation = parameters.rotation; // || new mono.Vec3; 空就是空，空就按express计算
    this._location = null; //基于LocationManager的管理，参考类it.Location;
    this._userDataMap = {}; //类似AssetInfo的数据，可以放在userDataMap 里面
    this._parentId = parameters.parentId;//父子关系
    this._hostId = ""; //依赖关系
    this._dataTypeId = parameters.dataTypeId;//绑定数据模型类型。
    this._businessTypeId = parameters.businessTypeId; //业务类型
    // this._parent = null;
    this._childList = new mono.List();
    this._alarmState = new it.AlarmState(this);
    this._powerParentId = ""; // 电力依赖关系
    this._allLinks = {};
    this._power = "";
    this._weight = 0;//自身重量
};

it.Data = $Data;

mono.extend($Data, $Base, {
    ___accessor: ['ii','rotation', 'parentId', 'hostId', "dataTypeId","businessTypeId", "alarmState", "description", "power", 'weight',"name","extend"],
    IT_Data: true,
    getId: function () {
        return this._id;
    },

    getLocation: function () {
        return this._location;
    },

    setLocation: function (object) {
        if (object) {
            var l = new it.Location(object);
            if (this._location) {
                if (l.x == this._location.x && l.y == this._location.y && l.z == this._location.z) {
                    return;
                }
            }
            var oldValue = this._location;
            this._location = l;
            this.firePropertyChange("location", oldValue, l);
        }
    },

    setPosition: function (x, y, z) {
        var p;
        if (arguments.length === 3) {
            p = new mono.Vec3(x, y, z);
        } else if (arguments.length === 1) {
            if (mono.Utils.isArray(x)) {
                p = new mono.Vec3(x[0], x[1], x[2]);
            } else {
                p = new mono.Vec3(x.x || 0, x.y || 0, x.z || 0);
            }
        }
        if (this._position) {
            if (p.x == this._position.x && p.y == this._position.y && p.z == this._position.z) {
                return;
            }
        }
        var oldValue = this._position;
        this._position = p;
        this.firePropertyChange("position", oldValue, p);
    },

    setPosition2d: function (x, y) {
        this._position2d = new mono.Vec2(x, y);
    },

    getValue: function (name) {
        if (!name) {
            return null;
        }
        if (this["_" + name]) {
            return this["_" + name];
        } else {
            return this.getUserData(name);
        }

    },

    getPosition: function () {
        return this._position || new mono.Vec3;
    },

    getPosition2d: function () {
        return this._position2d || new mono.Vec2;
    },

    u: function (userData) {
        if (!userData) {
            return;
        }
        for (var p in userData) {
            this.setUserData(p, userData[p]);
        }
    },

    addLink: function (link) {
        if (link && (link instanceof it.Link)
            && link.getId()
            && !this._allLinks[link.getId()]) {
            this._allLinks[link.getId()] = link;
        }
    },

    removeLink: function (link) {
        if (link && link.getId()) {
            delete this._allLinks[link.getId()];
        }
    },

    getAllLinks: function () {
        return this._allLinks;
    },

    getPosition2d: function () {
        return this._position2d;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._ii = json.ii;
        this._id = json.id;
        this._description = json.description;
        if (json.position && (json.position.x !== undefined || json.position.y !== undefined || json.position.z !== undefined)) {
            this._position = new mono.Vec3(json.position.x || 0, json.position.y || 0, json.position.z || 0);
        } else if (mono.Utils.isArray(json.position)) {
            this._position = new mono.Vec3(json.position[0] || 0, json.position[1] || 0, json.position[2] || 0);
        }
        if (json.position2d && (json.position2d.x !== undefined || json.position2d.y !== undefined)) {
            this._position2d = new mono.Vec2(json.position2d.x || 0, json.position2d.y || 0);
        } else if (mono.Utils.isArray(json.position2d)) {
            this._position2d = new mono.Vec2(json.position2d[0] || 0, json.position2d[1] || 0);
        }
        if (json.rotation && ((json.rotation.x !== undefined && json.rotation.x != '')
            || (json.rotation.y !== undefined && json.rotation.y != '')
            || (json.rotation.z !== undefined && json.rotation.z != ''))) {
            this._rotation = new mono.Vec3(json.rotation.x, json.rotation.y, json.rotation.z);
        } else if (mono.Utils.isArray(json.rotation)) {
            this._rotation = new mono.Vec3(json.rotation[0] || 0, json.rotation[1] || 0, json.rotation[2] || 0);
        }
        this.setLocation(json.location);
        this._parentId = json.parentId;
        this._dataTypeId = json.dataTypeId;
        this._businessTypeId = json.businessTypeId;
        this._hostId = json.hostId || json.groupId;
        this._power = json.power;
        this._weight = json.weight;
        this._name = json.name;
        this._extend = json.extend;
    },

    onAlarmChange: function () {

    },

    addChild: function (data) {
        if (data && !this._childList.contains(data)) {
            this._childList.add(data);//这个list竟然不去重，
        }
    },

    addChildren: function (datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.addChild(data);
        }
    },

    removeChild: function (data) {
        this._childList.remove(data);
    },

    removeChildren: function (datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.removeChild(data);
        }
    },

    getChildren: function () {
        return this._childList;
    },

    clone: function (id, cloneParentId) {
        var cloneData = new $Data(id);
        cloneData.setDataTypeId(this.getDataTypeId());
        var pos = this.getPosition(), loc = this.getLocation();
        cloneData.setPosition(pos.clone());
        if (loc) {
            cloneData.setLocation(new $Location(loc.x, loc.y, loc.z));
        }
        if (cloneParentId) {
            cloneData.setParentId(this.getParentId());
        }
        return cloneData;
    }
});
var $DataType = function (parameters) {
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._categoryId = "";
    this._description = "";
    this._size = null;    // 空间  参考类 it.Size 类
    this._childrenSize = new it.Size(); // 空间类，it.Size类；


    this._model2d = "";
    this._model2dParameters = null;
    this._model2d2 = "";
    this._model2d2Parameters = null;

    this._parameters = null;
    this._model = ""; // Link to modellib.js
    this._modelParameters = null;
    this._simpleModel = ""; // 简单模型管理 LOD
    this._simpleModelParameters = null;

    this._prefabAble = parameters.prefabAble == undefined ? true : parameters.prefabAble;
    this._simplePrefabAble = parameters.simplePrefabAble == undefined ? true : parameters.simplePrefabAble;
    // this.lod = "";
    this._selectable = true; // 是否有选中效果
    this._stopAlarmPropagationable = false; // 是否终止告警传播
    this._batchable = false; //是否启用批量绘制，将在BatchManager里面管理。
    this._lazyable = false;  // 延迟加载
    // this._lazyLoadScene = ""; // 延迟加载的场景 ？
    this.handleDoubleClick = null; // for user use;
    this.handleClick = null;  // for user use;

    this._rotationExp = {}; // 旋转支持表达式，如：{y : "x % 2 ? Math.IP : 0"};
    this._positionExp = {}; //

    this._visible = true;
    this._weightRating = 0;//承重的上限值
    this._powerRating = 0; // 额定功耗
    this._subType = 'server'; // 设备类型,server-主机  network-网络设备

    //_templateDatas数组中放的是it.Data的实例，并且该Data有类型哦，所以的需要专门的表来管理
    this._templateDatas = parameters.templateDatas || []; // port001@card001

    this._templateDataMap = {};
    this._userDataMap = {}; //存储用户自定义属性
};


mono.extend($DataType, $Base, {
    ___accessor: ['categoryId', 'description', 'rotationExp', 'positionExp', 'size', 'childrenSize', 'parameters', 'model2d', 'model2dParameters','model2d2', 'model2d2Parameters',
        'model', 'modelParameters', 'simpleModel', 'simpleModelParameters', 'batchable', 'lazyable', 'selectable', 'stopAlarmPropagationable', 'prefabAble', 'noVirtualOther', 'simplePrefabAble',
        'weightRating', 'weight', 'powerRating', 'power', 'subType'],
    getId: function () {
        return this._id;
    },

    setId: function (id) {
        if (this._id === undefined) {
            this._id = id;
        } else {
            throw 'Can\'t change id';
        }
    },

    getTemplateDatas: function (side) {
        side = side || false;
        var result = [];
        for(var id in this._templateDataMap){
            if(id.indexOf('@'+side)>0){
                result.push(this._templateDataMap[id]);
            }
        }
        return result;
    },

    setTemplateDatas: function (templateDatas) {
        this._templateDatas.length = 0;
        var self = this;
        if (templateDatas && templateDatas.length > 0) {
            templateDatas.forEach(function (templateData) {
                self.addTemplateData(templateData);
            });
        }
    },

    addTemplateData: function (data) {
        if (data instanceof it.Data) {
            this._templateDatas.push(data);
            this._templateDataMap[data.getId() + '@' + data.getUserData('side')] = data;
        } else {
            var itData = new it.Data();
            itData.setUserData('side', data.side);
            itData.fromJson(data);
            this._templateDatas.push(itData);
            this._templateDataMap[itData.getId() + '@' + itData.getUserData('side')] = itData;
        }
    },

    getTemplateDataById: function (id) {
        return this._templateDataMap[id];
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    },

    fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._categoryId = json.categoryId;
        this._description = json.description;
        this._size = new $Size(json.size)
        this._childrenSize = new $Size(json.childrenSize);
        this._model2d = json.model2d;
        this._model2dParameters = $Util.translateJson(json.model2dParameters);
        this._model2d2 = json.model2d2;
        this._model2d2Parameters = $Util.translateJson(json.model2d2Parameters);
        this._model = json.model;
        this._modelParameters = $Util.translateJson(json.modelParameters);
        this._simpleModel = json.simpleModel;
        this._simpleModelParameters = json.simpleModelParameters;
        this._selectable = json.selectable === undefined ? true : json.selectable;
        this._stopAlarmPropagationable = !!json.stopAlarmPropagationable;
        this._batchable = !!json.batchable;
        this._prefabAble = !!json.prefabAble;
        this._simplePrefabAble = !!json.simplePrefabAble;
        this._noVirtualOther = !!json.noVirtualOther;
        this._rotationExp = json.rotationExp || {};
        this._positionExp = json.positionExp || {};
        this._lazyable = json.lazyable;
        this._weightRating = json.weightRating;
        this._weight = json.weight;
        this._powerRating = json.powerRating;
        this._power = json.power;
        this._subType = json.subType;
    },
});

it.DataType = $DataType;

var $BusinessType = function(parameters){
	$Base.call(this);
	parameters = parameters || {};
	this._id = parameters.id || "";
	this._parentId = parameters.parentId || "";
	this._name = parameters.name || "";
	this._description = parameters.description;
	this._userDataMap = {};
};

mono.extend($BusinessType,$Base,{
	 
	___accessor: ['id', 'name', 'parentId', 'description'],

	fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentId = json.parentId;
	    this._name = json.name;
        this._description = json.description;
    },

    setUserData: function (key, value) {
        if (value == null) {
            delete this._userDataMap[key];
        } else {
            this._userDataMap[key] = value;
        }
    },
    
    getUserData: function (key) {
        return this._userDataMap[key];
    }

});

it.BusinessType = $BusinessType;
/*
 * terry  基于Model View Control MVC的设计
 */
var $DataManager = function(){
   this.defaultCategory = new it.Category(""); // 空分类
   this._categories = [];
   this._categoryMap = {};
   this._dataTypes = [];
   this._dataTypeMap = {};
   this._businessTypes = [];
   this._businessTypeMap = {};
   this._datas = [];
   this._dataMap = {};
   this._roots = []; // 管理最顶层的Data
   this._rootMap = {}; 

   this._links = [];
   this._linkMap = {};

   this._dataTypeDatas = {}; // 分类型管理Data
   this._categoryDatas = {}; //  分类管理Data

   this._scenes = [];
   this._sceneMap = {};
   this._rootScene = null;
   this._categorySceneMap = {};
    this._temperatureFields = {}; //温度场
    this._collectors = {}; //采集器
    this._typeCollectors = {}; //分类管理collector(采集器)
   
   // 事件管理
   this._dataManagerChangeDispatcher = new mono.EventDispatcher();
   this._dataPropertyChangeDispatcher = new mono.EventDispatcher();

   // 数据转换为场景的类，这个类可以用户定义，默认用我们的场景加载,可能
   // this.viewLoader = null; 
   // 位置管理
   // this.locationManager = null;
};

mono.extend($DataManager,mono.PropertyChangeDispatcher,{
    
    addScene : function(scene){
       if(!(scene instanceof it.Scene)){
          return false;
       }
       var id = scene.getId();
       if(this._sceneMap[id]){
           throw "Scene with id '" + id + "' already exists";
       }
       var categoryId = scene.getCategoryId();
       if(!this._categoryMap[categoryId] && !scene.isRoot()){
          throw "Scene Category with category id '" + categoryId + "' does not exist";
       }
       if(this._categorySceneMap[categoryId]){
          throw "Scene with category id '" + categoryId + "' already exists";
       }
       if(scene.isRoot()){
          if(this._rootScene != null){
            throw "Only support one root scene";
          }
          this._rootScene = scene;
       }
       this._scenes.push(scene);
       this._sceneMap[id] = scene;
       this._categorySceneMap[categoryId] = scene;
    },

    addSceneFromJson : function(scenes){
        var i = 0,len = scenes.length;
        for(;i < len;i ++){
            var scene = new it.Scene();
            scene.fromJson(scenes[i]);
            this.addScene(scene);
        }
    },

    getSceneByCategory : function(categoryOrId){
       if(!categoryOrId){
        return null;
       }
       var categoryId = categoryOrId.getId ? categoryOrId.getId() : categoryOrId;
       return this._categorySceneMap[categoryId];
    },

    getSceneByData : function(dataOrId){
      var category = this.getCategoryForData(dataOrId)
      return this.getSceneByCategory(category);
    },

    getRootScene : function(){
      return this._rootScene;
    },

    getChildrenScene : function(scene){
       
    },

    addCategory : function(category){
       var id = category.getId();
        if(!(category instanceof it.Category)){
        	throw "Can only add it.Category";
        }
        if(this._categoryMap[id]){
       	  throw "Category for id '" +id+"' already exists";
        }
        this._categories.push(category);
        this._categoryMap[id] = category;
    },

    removeCategory : function(category){
        if(!category){
          return false;
        }
        var id = category.getId();
        if(!this._categoryMap[id]){
           return false;
        }
        var index = this._categories.indexOf(category);
        if(index == -1){
        	return false;
        }
       	delete this._categoryMap[id];
       	this._categories.splice(index,1);
       	return true;
    },

    removeCategoryById : function(id){
       var category = this._categoryMap[id];
       if(category){
       	  this.removeCategory(category);
       }
    },

    addCategories : function(categories){
    	if(mono.Utils.isArray(categories)){
    		for(var i = 0;i < categories.length;i ++){
    			var category = categories[i];
    			this.addCategory(category);
    		}
    	}
    },
    
    // TODO
    addCategoryFromJson : function(json){
        var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var category = new it.Category();
          category.fromJson(jsonObject);
          this.addCategory(category);
       }
    },

    addDataType : function(dataType){
      if(!dataType){
      	return;
      }
      if(!(dataType instanceof it.DataType)){
      	throw "Can only add 'it.DataType'";
      }
      var id = dataType.getId();
      if(this._dataTypeMap[id]){
          throw "DataType for id '" +id+ "' already exists";
      }
      var categoryId = dataType.getCategoryId();
      if(categoryId && !this._categoryMap[categoryId]){
         throw "Category for '" + categoryId + "' does not exist";
      }
      this._dataTypes.push(dataType);
      this._dataTypeMap[id] = dataType;
    },


    addBusinessType : function(businessType){
       if (!businessType) {
          return;
       }
       var id = businessType.getId();
        if(!(businessType instanceof it.BusinessType)){
          throw "Can only add it.BusinessType";
        }
        if(this._businessTypeMap[id]){
          throw "BusinessType for id '" +id+"' already exists";
        }
        this._businessTypes.push(businessType);
        this._businessTypeMap[id] = businessType;
    },

    removeBusinessType : function(businessType){
        if(!businessType){
           return false;
        }
        var id = businessType.getId();
        if(!this._businessTypeMap[id]){
           return false;
        }
        var index = this._businessTypes.indexOf(businessType);
        if(index == -1){
           return false;
        }
        delete this._businessTypeMap[id];
        this._businessTypes.splice(index,1);
        return true;
    },

    removeBusinessTypeById : function(id){
       var businessType = this._businessTypeMap[id];
       if(businessType){
          this.removeBusinessType(businessType);
       }
    },

    addBusinessTypes : function(businessTypes){
      if(mono.Utils.isArray(businessTypes)){
        for(var i = 0; i < businessTypes.length; i ++){
          var businessType = businessTypes[i];
          this.addBusinessType(businessType);
        }
      }
    },

    addBusinessTypeFromJson : function(json){
        var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var businessType = new it.BusinessType();
          businessType.fromJson(jsonObject);
          this.addBusinessType(businessType);
       }
    },

    getBusinessTypeById : function(id){
        return this._businessTypeMap[id];
    },

    getBusinessTypeForData :function(data){
        var bid = data.getBusinessTypeId();
        if (bid) {
           return this.getBusinessTypeById(bid);
        }else{
          return null;
        }
    },

    /**
     * 转换templatedata的json数据并添加至某个DataType实例中
     * @param jsonObj
     * @returns {boolean}
     */
    addTemplateData : function(jsonObj){
        var dataTypeId  = jsonObj.parentDataTypeId||'';
        if(!dataTypeId){
            return false ;
        }
        var dataType = this._dataTypeMap[dataTypeId];
        if(!dataType){
            return false;
        }
        var data = new it.Data();
        //注意template_data中的position应该转成data中的position2d
        if(jsonObj.position){
            var pos3d = jsonObj.position;
            if(pos3d instanceof Array && pos3d.length >= 2){
                jsonObj.position2d = {x:pos3d[0],y:pos3d[1]};
            }else{
                jsonObj.position2d = pos3d;
            }
            //else if(pos3d instanceof Array && pos3d.length == 2){
            //    jsonObj.position2d = {x:pos3d[0],y:pos3d[1]};
            //}
        }
//        delete  jsonObj.position; // 免得混淆，直接去掉
        data.fromJson(jsonObj);
        data.setUserData('side', jsonObj.side);
        dataType.addTemplateData(data);
    },

    /**
     * 将json转换成templatedatas,并添加至datatype中
     * @param json
     */
    addTemplateDataFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            this.addTemplateData(jsonObject);
        }
    },

    removeDataType : function(dataType){
       if(!dataType){
          return false;
       }
       var id = dataType.getId();
       if(!this._dataTypeMap[id]){
           return false;
       }
       var index = this._dataTypes.indexOf(dataType);
       if(index === -1){
       	 return false;
       }
       if(this._dataTypeDatas[id]){ // 如果已经使用，不能删除。
       	  return false;
       }
       delete this._dataTypeMap[id];
       this._dataTypes.splice(index,1);
    },

    removeDataTypeById : function(id){
       this.removeDataType[this._dataTypeMap[id]];
    },

    getCategoryForDataType : function(dateTypeOrId){
        var dataType = dateTypeOrId;
        if(typeof dateTypeOrId === 'string'){
          dataType = this._dataTypeMap[dateTypeOrId];
        }
        if(!dataType){
            return null;
        }
        var categoryId = dataType.getCategoryId();
        return this._categoryMap[categoryId];
    },

    getCategoryForData : function(dataOrId){
        var dataType = this.getDataTypeForData(dataOrId);
        if(dataType){
          var categoryId = dataType.getCategoryId();
          return this._categoryMap[categoryId];
        }
        return null;
    },

    getDataTypeForData : function(dataOrId){
    	if(!dataOrId){
    		return;
    	}
    	var data = dataOrId;
        if(typeof data === "string"){ // 说明是id
            data = this._dataMap[data];
        }
        if(!data){
          return;
        }
        if(!(data instanceof it.Data) && !(data instanceof it.Link) ){
            return;
        }
        if(!data.getDataTypeId){
          console.log("data.getDataTypeId");
        }
        var dataTypeId = data.getDataTypeId();
        return this._dataTypeMap[dataTypeId];
    },

   getDataTypeById: function(linkId) {
      if (!linkId) {
        return null;
      }
      return this._dataTypeMap[linkId];
   },

    addDataTypeFromJson : function(dataTypes){
        var i = 0,len = dataTypes.length;
        for(;i < len;i ++){
          var dataType = new it.DataType();
          dataType.fromJson(dataTypes[i]);

          this.addDataType(dataType);
        }
    },

    /**
     * 设置data的父子关系
     * 注意：第一次加载了很多的数据的时候，这个方法执行了无数次，估计对速度有些影响
     * @param data
     * @returns {null}
     */
    setParentAndChildren : function(data){
        if(!data){
            return null;
        }
        var parentId = data.getParentId();
        if(parentId){
           var parentData =  this._dataMap[parentId];
            if(parentData){
                parentData.addChild(data);
            }
        }
        var children = this.getChildren(data);
        data.addChildren(children);
    },

    /**
     * 设置所有的data的父子关系
     * 对于一下子从后来查询了数千条数据来说，一个一个的setParentAndChildren是比较慢的，再说有很多的重复而无效的搜索和计算
     * 这里只要遍历一次，将其加入到其父亲的孩子中即可，并不需要找其的孩子
     */
    setAllParentAndChildren : function(){
        for(var id in this._dataMap){
            var data = this._dataMap[id];
            if(data && data.getParentId()){
                var parentData = this._dataMap[data.getParentId()];
                if(parentData){
                    parentData.addChild(data);
                }
            }
        }
    },

    addData : function(data,fireEvent,setParentAndChildren){
       if(!data){
       	 return;
       }
       if(fireEvent === undefined){
          fireEvent = true;
       }
        if(setParentAndChildren === undefined){
            setParentAndChildren = true;
        }
       var id = data.getId();
       var dataTypeId = data.getDataTypeId();

       if(this._dataMap[id]){
       	  throw "Data for '" + id +"' already exists";
       }
       var dataType = this.getDataTypeForData(data);
       if(!dataType){
       	 throw "DataType '" + dataTypeId + "' does not exist";
       }
       this._datas.push(data);
       this._dataMap[id] = data;
       var parentId = data.getParentId();
       if(!parentId){
       	  this._roots.push(data);
       	  this._rootMap[id] = data;
       }
        if(setParentAndChildren){
            this.setParentAndChildren(data);
        }
       // 冗余存储，方便查找
       var typeDatas = this._dataTypeDatas[dataTypeId];
       if(typeDatas == null){
       	  typeDatas = {};
       	  this._dataTypeDatas[dataTypeId] = typeDatas;
       }
       typeDatas[id] = data;
       
       // 冗余存储，方便查找
       var category = this.getCategoryForData(data);
       if(category){
         var categoryDatas = this._categoryDatas[category.getId()];
         if(categoryDatas == null){
            categoryDatas = {};
            this._categoryDatas[category.getId()] = categoryDatas;
         }
         categoryDatas[id] = data;
       }
       data.addPropertyChangeListener(this.handleDataPropertyChange, this);
       if(fireEvent){
          this._dataManagerChangeDispatcher.fire({
             kind : 'add',
             data : data,
             source : this
          });
       }

    },

    addDataFromJson : function(json){
       var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       // checkData
       var i = 0,len = jsonObjects.length;
       for(;i < len;i ++){
          var id = json.id;
          var dataTypeId = json.dataTypeId;
       } 

       for(i = 0;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var data = new it.Data();
          data.fromJson(jsonObject);
          this.addData(data,true,false);
       }
        this.setAllParentAndChildren();
    },

    /**
     * 删除data
     * data是it.Data实例或id
     */
    removeData : function(data,removeChild){ // TODO
        if (!data) {
            return false;
        }
        var id = data.getId ? data.getId():data;
        if (!this._dataMap[id]) {
            return false;
        }
        var data = this._dataMap[id];
        var index = this._datas.indexOf(data);
        if (index === -1) {
            return false;
        }
        //只要从父亲中移除即可，因为其孩子不需要处理，接下来都从datamaanger中去掉了
        if (data.getParentId()) {
            var parentData = this._dataMap[data.getParentId()];
            if (parentData) {
                parentData.removeChild(data);
            }

        }
        var childArray = data.getChildren();//this.getChildren(data);
        if (childArray && childArray.size() && !removeChild) {
            return false;
        } else if (childArray && childArray.size()) {
            for (var i = 0; i < childArray.size(); i++) {
                this.removeData(childArray.get(i), removeChild);
            }
        }

        delete this._dataMap[id];
        this._datas.splice(index, 1);

        var dataTypeId = data.getDataTypeId();
        var typeDatas = this._dataTypeDatas[dataTypeId];
        if (typeDatas != null) {
            delete typeDatas[id];
        }

        var category = this.getCategoryForData(data);
        if (category) {
            var categoryDatas = this._categoryDatas[category.getId()];
            if (categoryDatas != null) {
                delete categoryDatas[id]
            }
        }
        data.removePropertyChangeListener(this.handleDataPropertyChange, this);
        this._dataManagerChangeDispatcher.fire({
            kind: 'remove',
            data: data,
            source: this
        });
        return true;
    },

    addLink : function(link){
        var id = link.getId();
        if (this._linkMap[id]) {
            return;
        }
        var fromId = link.getFromId();
        var toId = link.getToId();

        if (!this._dataMap[fromId]) {
            console.log("From Id does not exist");
            return;
        }
        if (!this._dataMap[toId]) {
            console.log("To Id does not exist");
            return;
        }
        this._linkMap[id] = link;
        this._links.push(link);

        this._dataMap[fromId].addLink(link); // 将link关联到data上
        this._dataMap[toId].addLink(link);

        this._dataManagerChangeDispatcher.fire({
            kind: 'add',
            data: link,
            source: this
        });
        return true;
    },

    removeLink : function(link){
       var id = link.getId();
       if(this._linkMap[id]){
          var index = this._links.indexOf(link);
          this._links.splice(index,1);
          delete this._linkMap[id];
       }

        var fromId = link.getFromId();
        var toId = link.getToId();

        this._dataMap[fromId].removeLink(link); // 将link关联到data上
        this._dataMap[toId].removeLink(link);

        this._dataManagerChangeDispatcher.fire({
          kind : 'remove',
          data : link,
          source : this
       });
    },

    addTemperatureField : function(field){
        if(!field){
            return ;
        }
        if(this._temperatureFields && this._temperatureFields[field.getId()]){
            throw "Temparature Field for '" + field.getId() +"' already exists";
        }
        this._temperatureFields[field.getId()] = field;
        if(this._collectors){
            for (var cid in this._collectors){
                var collector = this._collectors[cid];
                if(collector.getType() == $Collector.Type.temperature && collector.getParentId() == field.getId()){
                     field.addCollector(collector);
                }
            }
        }

    },

    addTemperatureFieldFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            var field = new $TemperatureField();
            field.fromJson(jsonObject);
            this.addTemperatureField(field);
        }
    },

    removeTemparatureField : function(field){
        if(!field){
            return ;
        }
        var collectors = field.getCollectors();
        if(collectors && collectors.size() > 0){
            var self = this;
            collectors.forEach(function(collector){
                if(collector){
                    delete self._collectors[collector.getId()];
                }
            })
        }
        delete this._temperatureFields[field.getId()];

    },

//        this._temperatureFields = {}; //温度场
//        this._collectors
    addCollector : function(collector){
        if(!collector){
            return ;
        }
        if(this._collectors && this._collectors[collector.getId()]){
            throw "Collector for '" + collector.getId() +"' already exists";
        }
        this._collectors[collector.getId()] = collector;
        // if(collector.getType() == 'temperature'){ // remove 2017-09-04，今后的传感器可能同时包含了温度和湿度的值
            var tepField = this._temperatureFields[collector.getParentId()];
            if(tepField){
                tepField.addCollector(collector);
            }
        // }
        var collectorType = collector.getType();
        var typeCollectors = this._typeCollectors[collectorType];
        if(typeCollectors == null){
            typeCollectors = {};
            this._typeCollectors[collectorType] = typeCollectors;
        }
        typeCollectors[collector.getId()] = collector;
    },

    addCollectorFromJson : function(json){
        var jsonObjects = json;
        if(typeof json === "string"){
            jsonObjects = JSON.parse(json);
        }
        var i = 0,len = jsonObjects.length;
        for(;i < len;i ++){
            var jsonObject = jsonObjects[i];
            var collector = new $Collector();
            collector.fromJson(jsonObject);
            this.addCollector(collector);
        }
    },

    removeCollector : function(collector){
        if(!collector){
            return ;
        }
        delete this._collectors[collector.getId()];
        if(collector.getType() == 'temperature'){
            var tepField = this._temperatureFields[collector.getParentId()];
            if(tepField){
                tepField.removeCollector(collector);
            }
        }
        var collectorType = collector.getType();
        var typeCollectors = this._typeCollectors[collectorType];
        if(typeCollectors){
            delete typeCollectors[collector.getId()];
        }
    },

    getParent : function(data){
        if(!data){
            return null;
        }
        if(data instanceof it.Data){
           var parentId = data.getParentId();
           return this._dataMap[parentId];
        }
    },

    getChildren : function(data,dataTypeId){
//        var now = new Date();
       var childArray = [];
       if(!data){
        return childArray;
       }
       var pId = data.getId();
       for(var id in this._dataMap){
         var data = this._dataMap[id];
         if(!dataTypeId || data.getDataTypeId() == dataTypeId){
            if(data.getParentId() === pId){
              childArray.push(data);
            }
         }
         
       }
//        console.log(" getChild-------: "+((new Date()).getTime() - now.getTime()));
       return childArray;
    },

    /**
     * 判断ancestorId是不是data的祖先id
     * @param ancestorId 祖先id
     * @param data
     */
    isAncestor : function(ancestorId,data,scop){
        if(!data || !ancestorId){
            return false;
        }
        if(data.getId() === ancestorId || data.getParentId() === ancestorId){
            return true;
        }
        var scop = scop||this;
        if(data.getParentId()){
            var parent = this._dataMap[data.getParentId()];
            if(parent){
                return scop.isAncestor(ancestorId,parent,scop);
            }
        }
        return false;
    },

    /**
     * 获取data的子孙(不仅仅只是孩子)
     * @param data
     */
    getDescendants : function(data,results,scope){
        var descendants = results || [];
        var scope = scope || this;
        if(!data){
            return descendants;
        }
//        var pId = data.getId();
//        for(var id in this._dataMap){
//            var data = this._dataMap[id];
//                if(this.isAncestor(pId,data)){
//                    descendants.push(data);
//                }
//        }
        var children = data.getChildren();
        if(children && children.size() > 0){
            children.forEach(function(child){
                descendants.push(child);
                scope.getDescendants(child,descendants,scope);
            });
        }
        return descendants;
    },



    getDataMap : function(){
      return this._dataMap;
    },

    getLinkMap : function(){
      return this._linkMap;
    },

    /**
     * 根据linkId获取link
     * @param id
     */
    getLinkById : function(id){
        if(!id){
            return null;
        }
        return this._linkMap[id];
    },

    getFromLinks : function(dataOrId){

    },

    getToLinks : function(dataOrId){

    },

    getDataMapByCategory : function(categoryOrId){
       var id = categoryOrId;
       if(id instanceof it.Category){
          it = id.getId();
       }
       return this._categoryDatas[id];
    },

    getDataById : function(id){
      if(!id){
         return null;
      }
      var data = this._dataMap[id];
      if(!data && typeof(id) === 'string' &&  id.indexOf('@') > 0){
         var ids = id.split("@");
         var childId = ids[0],parentId = ids[1]
         var parent = this.getDataById(parentId);
         if(parent){
            return null;
         }
         var dataType = this.getDataTypeForData(parent);
         if (!dataType) {
           return null;
         };
         var templateData = dataType.getTemplateDataById(childId);
         if(templateData){
            var templateDataType = this.getDataTypeForData(templateData);
            if(!templateDataType){
                return null;
            }
            var newData = templateData.clone(id);
            newData.setParentId(parentId);
            this.addData(newData);
            return newData;
         }
      }
      return data;
    },

    getCollectorById : function(cid){
       return this._collectors[cid];
    },

    getDatas : function(){
       return this._datas;
    },

    getLinks : function(){
        return this._links;
    },

    getAncestors : function(data,array){
       array = array || [];
       var parent = this.getDataById(data.getParentId());
       if(parent){
          array.push(parent);
          this.getAncestors(parent,array);
       }
       return array;
    },

    getAncestor : function(data,filterFunction){
        var dataType = this.getDataTypeForData(data);
        var category = this.getCategoryForData(data);
        if(filterFunction(data,dataType,category)){
           return data;
        }
        var parent = this.getParent(data);
        if(parent == null){
          return null;
        }else{
          return this.getAncestor(parent,filterFunction);
        }
    },

    getRootMap : function(){
       return this._rootMap;
    },

    getRoots : function(){
       return this._roots;
    },

    getTemperatureFields : function(){
        return this._temperatureFields;
    },

    isLazyable : function(data){
      if(!data){
        return false;
      }
      var dataType = this.getDataTypeForData(data);
      if(dataType.isLazyable()){
         return true;
      }
      var parentData = this.getParent(data);
      if(this.isLazyable(parentData)){ // 可是parent有可能是其他的场景了 
         return true;
      }
      return false;
    },

    fromJson : function(json){
       json = $Util.translateJson(json);
       var categories = json.categories || [];
       var dataTypes = json.dataTypes || [];
       var datas = json.datas || [];
       
       var categoryMap = {},dataTypeMap = {},i = 0;
       for(;i < categories.length;i ++){
          var  category = categories[i];
          categoryMap[category.id] = category;
       }

       for(i = 0;i < dataTypes.length;i ++){
          var dataType = dataTypes[i];
          if(dataType.categoryId && !categoryMap[dataType.categoryId] && !this._categoryMap[dataType.categoryId]){
             throw "Category for '" + dataType.categoryId + "' does not exist";
          }
          dataTypeMap[dataType.id] = dataType;
       }

       for(i = 0;i < datas.length;i ++){
           var data = datas[i];
           var dataTypeId = data.dataTypeId;
           if(!dataTypeMap[dataTypeId] && !this._dataTypeMap[dataTypeId]){
                 throw "DataType '" + dataTypeId + "' does not exist"; 
           }
       }

       if(categories && categories.length){
         this.addCategoryFromJson(categories);
       }
       if(dataTypes && dataTypes.length){
         this.addDataTypeFromJson(dataTypes);
       }
       if(datas && datas.length){
         this.addDataFromJson(datas);
       }
    },

    handleDataPropertyChange:function(event){
        var data = event.source;
        if (event.property === "parentId") {
           var oldValue = event.oldValue,newValue = event.newValue;
           if(newValue == null){
              this._roots.push(data);
              this._rootMap[data.getId()] = data;
           }else if(oldValue == null){
              delete this._rootMap[data.getId()];
              var index = this._roots.indexOf(data);
              if(index != -1){
                this._roots.splice(index,1);
              }
           }
        } 
        this.onDataPropertyChanged(data, event);
        this._dataPropertyChangeDispatcher.fire(event);
    },

    onDataPropertyChanged : function(data,event){
       
    },

    addDataPropertyChangeListener : function(listener, scope, ahead) {
        this._dataPropertyChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataPropertyChangeListener : function(listener, scope) {
        this._dataPropertyChangeDispatcher.remove(listener, scope);
    },

    addDataManagerChangeListener: function (listener, scope, ahead) {
        this._dataManagerChangeDispatcher.add(listener, scope, ahead);
    },
    addDataBoxChangeListener: function (listener, scope, ahead) {
        this._dataManagerChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataManagerChangeListener: function (listener, scope) {
        this._dataManagerChangeDispatcher.remove(listener, scope);
    },


    /**
     * 返回data是否阻止了告警传播
     * 默认是不阻止,返回false
     * 第一步: 判读dataType存在,并且阻止了传播,立即返回true
     * 第二步: 判断category存在,并且阻止了传播,立即返回true
     * 第三步: 返回false
     * @param data {it.Data} data对象
     * @returns {boolean}
     */
    isStopAlarmPropagation:function(data){

        if(!data){
            return false;
        }
        var dataType = this.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        if (dataType.isStopAlarmPropagationable()) {
            return true;
        }
        var category = this.getCategoryForData(data);
        if (!category) {
            return false;
        }
        if (category.isStopAlarmPropagationable()) {
            return true;
        }
        return false;
    },
});

it.DataManager = $DataManager;
/**
 * terry 场景对象，SceneManager管理场景对象，并加载场景
 */
var $Scene = function (parameters) {
    $Base.call(this);
	parameters = parameters || {};
    if(typeof parameters === 'string'){
       parameters = {id : parameters};
    }
	this._id = parameters.id;
	this._categoryId = parameters.categoryId;
    this._root =  false || parameters.root;
	this._sceneType = parameters.sceneType || "ShowSelf";
    this._twod = parameters.twod||false; //twod
    this._withGis = parameters.withGis || false;
    this.zoomLevel = parameters.zoomLevel|| 5;
    this.center = parameters.center;
    this._description = "";
    //场景的灯光，network的背景色，镜头的角度，动画等
    this.lights = [];
    this.networkParameters = {};
    this.cameraParameters = {};
    this.animateParameters = {};
    this.showStaticInfo = parameters.showStaticInfo;
    this.defaultInteractionParameters = parameters.defaultInteractionParameters;
    this._preRender = parameters.preRender || false;
};

mono.extend($Scene,$Base,{
   ___accessor : ["categoryId","sceneType","root",'twod','withGis','description','preRender'],

    getId : function(){
     return this._id;
    },

    isRoot : function(){
      return this._root;
    },

    isShowStaticInfo : function(){
        return this.showStaticInfo;
    },

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._categoryId = json.categoryId;
        this._root =  false || json.root;
        this._sceneType = json.sceneType || "ShowSelf";
        this._twod = json.twod||false; //twod
        this._withGis = json.withGis || false;
        this.zoomLevel = json.zoomLevel|| 5;
        this.center = json.center;
        this._description = json.description;
        this.networkParameters = json.networkParameters;
        this.cameraParameters = json.cameraParameters;
        this.showStaticInfo = json.showStaticInfo;
        this.defaultInteractionParameters = json.defaultInteractionParameters;
        this._preRender = json.preRender || false;
//        this._dialog = json.dialog;
    }
});

it.Scene = $Scene;

/**
 * Create By: Bozai 
 * 自定义场景视图,方便用户扩展来定制自己的场景，包括新的视图(视图可能是新的network，或div)
 * 根据scene和rootData来创建CustomSceneView
 * 可以将ViewManager和ViewManager2D当做系统内部的两个视图
 */
var $CustomSceneView = function(sceneId, sceneManager) {
	this.sceneManager = sceneManager;
	this.sceneId = sceneId;
	// this.scene = this.sceneManager.dataManager._sceneMap[sceneId];
	this.defaultEventHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
	// this.rootData = rootData;
	// this.init();
};

mono.extend($CustomSceneView, Object, {

	// init: function() {
	// },

    /**
     * 返回自定义视图的View
     * 注意：当返回null时，表示的是更viewManager3D共用一个视图
     */
	getContainer: function() {
		return null;
	},

	getNetwork3D : function(){
		return null;
	},

	getCamera : function(){
		return null;
	},

	adjustBounds : function(w, h, left, top){
		// 调整该view的大小和位置
	},

	/**
	 * 显示该场景的view
	 */
	show: function(rootData) {

	},

	/**
	 * 卸载该场景视图
	 */
	clear: function() {
		return null;
	},

    /**
     * 自定义场景视图中处理获取焦点
     */
	setFocusNode : function(node){

	},
    
    /**
     * 自定义场景视图中的lookAt的处理
     */
	lookAt : function(node){

	},

	isLoadData : function(){
		return true;
	}

});

it.CustomSceneView = $CustomSceneView;


/**
 * 管理联系的数据
 */
var $Link = function(parameters){
    $Base.call(this);
    parameters = parameters || {};
    if (typeof parameters === 'string') {
        parameters = {id: parameters};
    }
    this._id = parameters.id;
    this._name = parameters.name || '';
    this._dataTypeId = parameters.dataTypeId || '';
    this._type = parameters.type || '';
    this._fromId = parameters.fromId;// 支持表达式 比如F01_01.1设备的第一个端口
    this._fromSide = parameters.fromSide||0; //是设备的正面还是反面，0是正面，1是反面
    this._toId = parameters.toId;
    this._toSide = parameters.toSide||0;//是设备的正面还是反面，0是正面，1是反面
    this._userDataMap = {}; //类似DataInfo的数据，可以放在userDataMap 里面
    // this._controls = null;
    this._fromControls = parameters.fromControls || null;
    this._toControls = parameters.toControls || null;
    this._radius = 2;
    this._alarmState = new it.AlarmState(this);
    this._fromPortId = parameters.fromPortId;
    this._toPortId = parameters.toPortId;
    this._routeType = parameters.routeType;
    this._fromIpAddress = parameters.fromIpAddress;
    this._toIpAddress = parameters.toIpAddress;
    // "$p0.front + $p0.depth/2","$p1"
};
mono.extend($Link,$Base,{
   ___accessor : ['name','type','dataTypeId','fromId','fromSide','toId','toSide','fromControls','toControls','radius','alarmState','fromPortId','toPortId','routeType','fromIpAddress','toIpAddress'],
    IT_Data:true,
   getId : function(){
      return this._id;
   },
   
   setId : function(id){
       if(this._id === undefined){
          this._id = id;
       }else{
          throw 'Can\'t change id';
       }
   },

   setUserData : function(key,value){
       if(value == null){
         delete this._userDataMap[key];
       }else{
         this._userDataMap[key] = value;
       }
    },
   
    getUserData  :function(key){
       return this._userDataMap[key];
    },
});
it.Link = $Link;

/**
 * 数据采集点，如：温/湿度采集器
 * 注意：如果type是湿度的话，那这个parentId就是dataId；
 *      如果type是温度的话，那这个parentId就是temperatureFieldId(即温度场id)
 * @constructor
*/

var $Collector = function(parameters){
    $Base.call(this);
    parameters = parameters || {};
    this._parentId = parameters.parentId||""; // 如温度场的id，表示该采集器在哪里
    this._id = parameters.id || "";
    this._position = parameters.position || new mono.Vec3();
    this._location = parameters.location||''; //逻辑坐标，可以是data的id
    this._value = parameters.value || "0";
    this._data = parameters.data||{}; //也是传感器的值，这个data是个obj对象，它可能包含了多个值，如：温度、湿度等
    // 采集器的长宽高
    this._width = parameters.width || 0;
    this._height = parameters.height || 0;
    this._depth = parameters.depth ||0;
    this._description = parameters.description;
    this._type = parameters.type || "temperature";
};
/**
 * 采集器的类型
 * @type {string}
 */
$Collector.Type = {};
$Collector.Type.humidity = 'humidity';
$Collector.Type.temperature = 'temperature';

mono.extend($Collector,$Base,{
    ___accessor: ['id','parentId','value','data','width',"height","depth","type","position","location"],

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentId = json.parentId;
        this._description = json.description;
        this._width = json.width;
        this._height = json.height;
        this._depth = json.depth;
        this._type = json.type;
        this._value = json.value;
        this._data = json.data;
        if(json.position && (json.position.x!== undefined || json.position.y!== undefined || json.position.z!== undefined)){
            this._position = new mono.Vec3(json.position.x || 0,json.position.y || 0,json.position.z || 0);
        }else if(mono.Utils.isArray(json.position)){
            this._position = new mono.Vec3(json.position[0] || 0,json.position[1] || 0,json.position[2] || 0);
        }
        this._location = json.location;
    },

});

it.Collector = $Collector;

/**
 * 采集器的类型
 * @type {string}
 */
//it.Collector.Type = {};
//it.Collector.Type.humidity = 'humidity';
//it.Collector.Type.temperature = 'temperature';
//it.Collector.Type.humidity = 'humidity';

/**
 * 温度场类，该类用来生成温度云图
 * @constructor
 */
var $TemperatureField = function(parameters){
    $Base.call(this);
//    this.sceneManager = sceneManager;
    parameters = parameters || {};
    this._parentDataId = parameters.parentDataId; // 资产id，也就是该温度场在哪里(如那个楼层，哪个area等)
    this._id = parameters.id || "";
    this._width = parameters.width || null; // 如果温度场不是矩形，那暂时没法搞了
    this._height = parameters.height || null;
    this._position = parameters.position || new mono.Vec3();
    this._description = parameters.description || "";
//    this.heatMap = null;
    //最小/大阀值，超过就通过特殊或加深颜色来特殊标识,应该放到上一层(即manager中)
    this._minValue = parameters.minValue || null;
    this._maxValue = parameters.maxValue ||null;
    this._withBg = parameters.withBg || false; //该温度云图上是不是加上蓝底

//    this.tempBillbords = {};
//    this.parentNode = this.sceneManager.getNodeByDataOrId(this._parentDataId);
    this.collectors = new mono.List(); // 采集器
//    this.dataBox = this.sceneManager.network3d.getDataBox();
    //温度云图时，通常需要虚化其他的设备,其实可以进一步封装，放到上一层，所有个温度场共用一个
//    this.isVirtualElementFunction = function(){ //默认是虚化的
//        return true;
//    };
//    this.virtualFilter = new it.VirtualManager(this.sceneManager);
//    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualFilter);
//    this.tempBoard = null;
};

mono.extend($TemperatureField,$Base,{

    ___accessor: ['id',"parentDataId",'width','height',"position","minValue","maxValue","withBg"],

    fromJson : function(json){
        if(typeof json === 'string'){
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._parentDataId = json.parentDataId;
        this._description = json.description;
        this._width = json.width;
        this._height = json.height;
        this._withBg = json.withBg;
        this._minValue = json.minValue;
        this._maxValue = json.maxValue;
        if(json.position && (json.position.x!== undefined || json.position.y!== undefined || json.position.z!== undefined)){
            this._position = new mono.Vec3(json.position.x || 0,json.position.y || 0,json.position.z || 0);
        }else if(mono.Utils.isArray(json.position)){
            this._position = new mono.Vec3(json.position[0] || 0,json.position[1] || 0,json.position[2] || 0);
        }
    },

    addCollector : function(collector){
        if(collector){
            this.collectors.add(collector);
        }
    },

    removeCollector : function(collector){
        if(collector){
            this.collectors.remove(collector);
        }
    },

    getCollectors : function(){
        return this.collectors;
    }

});

it.TemperatureField = $TemperatureField;

var $Light = function(params){
   var params = params||{};
   this._id = params.id||'';
   this._description = params.description;
   this._sceneId = params.sceneId;
   this._type = params.type; // 灯光类型
   this._color = params.color || 'PointLight';
   this._intensity = params.intensity;
   this._distance = params.distance;
   this._position = params.position||new mono.Vec3;
};

mono.extend($Light,$Base,{
   ___accessor: ['id','sceneId','type','color', 'intensity', "distance", "position"],
	
	fromJson: function (json) {
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._description = json.description;
        if (json.position && (json.position.x !== undefined || json.position.y !== undefined || json.position.z !== undefined)) {
            this._position = new mono.Vec3(json.position.x || 0, json.position.y || 0, json.position.z || 0);
        } else if (mono.Utils.isArray(json.position)) {
            this._position = new mono.Vec3(json.position[0] || 0, json.position[1] || 0, json.position[2] || 0);
        }
        
        this._sceneId = json.sceneId;
        this._type = json.type;
        this._color = json.color;
        this._intensity = json.intensity;
        this._distance = json.distance;
    },
});

it.Light = $Light;

/**
 * 温度场管理器
 * @param sceneManager
 * @constructor
 */
var $TemperatureFieldManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.isVirtualElementFunction = function(){ //默认是虚化的
        return true;
    };
    this.virtualFilter = new it.VirtualManager(this.sceneManager);
    this.oldOpacityValue = this.virtualFilter.opacityValue;
    this.virtualFilter.opacityValue = 0.20;
    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualFilter);
    this.fields = null;
    this.dataBox = this.sceneManager.network3d.getDataBox();
    this.heatMaps = {};
    this.tempBoards = {};
    this.bgMap = {}; //背景map {'blue':[minValue,maxValue]} add By Kevin 2016-11-16，因此可以考虑将TemperatureField中的_minValue和_maxValue去掉
    this.isAnimate = true; // 是不是云图从下到上循环移动
    this.deltaY = 0;
    this.billboardCanvasMap = {};//用来保存billboard上的canvas,使得刷新的时候不必重新创建canvas
    this.highestValue = 70.0;//最高温度，最高值转换成1(因为绘制温度云图时，热点的范围是0-1)，这里表示70.0对应的是温度场中的1
    this.isBillboardVertical = true;
};

mono.extend($TemperatureFieldManager,Object,{

    getAllCollectors : function(){
        return this.sceneManager.dataManager._typeCollectors[$Collector.Type.temperature];
    },

    /**
     * 显示当前场景下的温度值，没有温度场
     */
     showWithoutTempField : function(withIntervalRefresh,interval){
        this.tempBillbords = {};
        this.tempCollectors = this.getAllCollectors();//this.sceneManager.dataManager._typeCollectors[$Collector.Type.temperature];
        if(!this.tempCollectors){
            return 0;
        }
        if(this.intervalId){
            return 0;
        }
        var count = 0;
        for(var id in this.tempCollectors){
            var collector =  this.tempCollectors[id];
            if(collector){
                if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                    this.createBillboard(collector);
                    count++;
                }
            }
        }
        if(count < 1){
            return 0;
        }
        var self = this;
        if (withIntervalRefresh) {
            interval = parseInt(interval)||5000;
            this.intervalId = window.setInterval(function() {
                self.updateBillboards();
            }, interval);
        }else {
            this.intervalId = window.setInterval(function() { //不能没有intervalId，是否正在显示温度云图是通过是否有这个值来判断的
                // do nothing
            }, 10000);
        }
        return count;
     },

     getCollectorById : function(id){
         return this.dataManager._collectors[id];
     },

     beforeUpdateBillboards : function(){
         return;
     },

     updateBillboards : function(){
        this.beforeUpdateBillboards();
        if(!this.tempBillbords){
            return ;
        }
        for(var id in this.tempBillbords){
            var collector = this.getCollectorById(id);//this.dataManager._collectors[id];
            this.createBillboard(collector);
        }
     },

    /**
     * 显示“当前场景”下温度云场
     * “当前场景”:
     * 1、如果当前的scene不存在，那就认为是没有scene的机房，因此显示所有的tempfeild；
     * 2、如果存在scene，那就显示root下所有的field；如果root不存在（也就是一开始加载场景）该怎么整；
     */
    show : function(){
        var tempFieldSetting = [4,50];
        this.fields = this.dataManager.getTemperatureFields();
        if(this.intervalId){ // 表示已经有
            return ;
        }
        if(this.tempFieldArr && this.tempFieldArr.length){
            this.tempFieldArr.forEach(function(field){
                if(field.name.toLowerCase() == 'layernum'){
                    tempFieldSetting[0] = parseInt(field.value);
                }
                if(field.name.toLowerCase() == 'spacing'){
                    tempFieldSetting[1] = parseInt(field.value);
                }
            })
        }
        var currentFields = this.getCurrentSceneFields();
        if (!currentFields || currentFields.length < 1) {
            return ;
        }
        for(var i = 0 ; i < currentFields.length ; i++){
            this.createTempFieldByField(currentFields[i]);
        }
        this.virtualAllElement();
        this.sceneManager.network3d.dirtyNetwork();

        // 以下是3秒钟刷新一次:
        var self = this;
        this.intervalId = window.setInterval(function(){

            self.beforeRefresh();

            self.refresh(function(fid) {
                var hm = self.heatMaps[fid];
                var tempBoard = self.tempBoards[fid];
                if (self.isAnimate) {
                    var py = parseFloat(tempBoard.orgPositionY) + parseFloat(self.deltaY);
                    tempBoard.setPositionY(py);
                }
                if (tempBoard) {
                    tempBoard.setStyle('m.texture.image', hm.heatMapCanvas);
                    tempBoard.invalidateTexture();
                    // tempBoard.setStyle('m.texture.image', hm.getImage());
                    if (hm.heatMapCanvas.parentNode) {
                        document.body.removeChild(hm.heatMapCanvas);
                    }
                }
            });
            if(self.deltaY > tempFieldSetting[1]*(tempFieldSetting[0]-2)){
                self.deltaY = 0;
             }else{
                self.deltaY += tempFieldSetting[1];
            }
        },2000);
    },

    beforeRefresh : function(){

    },

    /**
     * 为了提高效率，统一刷新
     */
    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
        var fun = function(){
            for(var fid in self.heatMaps) {
                var hm = self.heatMaps[fid];
                if(self.isAnimate && self.deltaY > 0){
                    if(hm.datas && hm.datas.length > 0){
                        for(var i = 0 ; i < hm.datas.length ; i++){
                            var data = hm.datas[i];
                            if(data && data.length == 3){
                                data[2] = data[2] + 0.05; //多层变动时，上一层的比下一层高0.05
                            }
                        }
                    }
                    self.refreshColletor(self.fields[fid],hm);
                }else{// 如果同一个floor上有多个温度场，那除了最先调用的那个温度场会被清空外，其他的都不会被清空，所以deltaY++要放到refresh后
                    hm.clear();
                    self.setDataByField(self.fields[fid],hm);
                }
                document.body.appendChild(hm.getCanvas());
                if (callback) {
                    callback(fid);
                }
            }
        };
        raf(fun);
    },

    /**
     * 隐藏温度场
     */
    hide : function(){
        if(this.intervalId) {
            window.clearInterval(this.intervalId);
            delete this.intervalId;
        }else{
            return;
        }
        this.virtualFilter.clearAll();
        this.sceneManager.network3d.setSelectTransparencyThreshold(this.oldOpacityValue + 0.1); //阀值设置回去
        if(this.tempBoards){
            for(var fid in this.tempBoards){
                var board = this.tempBoards[fid];
                this.dataBox.remove(board);
                delete this.heatMaps[fid];
                delete this.tempBoards[fid];
            }
        }
        if(this.tempBillbords) {
            for (var collectorId in this.tempBillbords) {
                if (collectorId) {
                    var billboard = this.tempBillbords[collectorId];
                    if (billboard) {
                        billboard.setParent(null);
                        this.dataBox.remove(billboard);
                    }
                }
            }
            delete this.tempBillbords;
        }
        this.sceneManager.network3d.dirtyNetwork();
    },

    isShowing : function(){
        if(this.intervalId){
            return true;
        }
        return false;
    },

    /** 
     * 获取不虚化的类别
     * 显示温度场时，默认的是处理floor和room不虚幻外，其他的都虚幻
     */
    getNnVirtualCategorys : function(){
        return ['floor','room'];
    },

    virtualAllElement : function(){
        //到了查看温度场时，透明度调高了，因此点中的阀值也要适当的调高
        this.sceneManager.network3d.setSelectTransparencyThreshold(this.virtualFilter.opacityValue + 0.01);
        if(this.isVirtualElementFunction &&  this.isVirtualElementFunction()){
            this.virtualFilter.addAll();
            /*
            //但是地板和墙都不隐藏
            var categoryDatas = this.dataManager.getDataMapByCategory('floor');
            if(categoryDatas){
                for(var id in categoryDatas){
                    var data = categoryDatas[id];
                    if(data){
                        this.virtualFilter.remove(data);
                    }
                }
            }
            var roomDatas = this.dataManager.getDataMapByCategory('room');
            if(roomDatas){
                for(var id in roomDatas){
                    var data = roomDatas[id];
                    if(data){
                        this.virtualFilter.remove(data);
                    }
                }
            }
            */
            var nuVirtualCategorys = this.getNnVirtualCategorys();
            if (nuVirtualCategorys && nuVirtualCategorys.length > 0) {
                for (var i = 0; i < nuVirtualCategorys.length; i++) {
                    var cId = nuVirtualCategorys[i];
                    var categoryDatas = this.dataManager.getDataMapByCategory(cId);
                    if (categoryDatas) {
                        for (var id in categoryDatas) {
                            var data = categoryDatas[id];
                            if (data) {
                                this.virtualFilter.remove(data);
                            }
                        }
                    }
                }
            }
        }
    },

    createTempFieldByField: function (field) {
        if (!field) return null;
        var parentNode = this.sceneManager.getNodeByDataOrId(field.getParentDataId());
        if (!parentNode) { // 如果parent都没有（通常是没有加载）就不显示它了
            return null;
        }
        var position = field.getPosition();
        var withBg = field.getWithBg();
        // heatMap的位置(position)应该是相对于parent的位置，因此这里需要换算一下
//        var p_w_pos = parentNode.getWorldPosition();
        var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
        var px = p_w_pos.x + position.x;
        var py = p_w_pos.z + position.y;
        var heatMap = new it.HeatMap({
            width: field.getWidth(),
            height: field.getHeight(),
            positionX: px,
            positionY: py,
            withBg : withBg,
        });
        this.setDataByField(field, heatMap);
        this.heatMaps[field.getId()] = heatMap;
        var tempBoard = heatMap.getTemperatureBoard();
        this.tempBoards[field.getId()] = tempBoard;
        var height = position.z||0;//因为y被水平用了，当初没有设计好，如今position被多个地方用到了，以及老数据的问题，所以用z来表示高度
        var bpy = parentNode.getWorldPosition().y+50+height;
        tempBoard.setPositionY(bpy);
        var parentWorldPos = parentNode.getWorldPosition();
        // tempBoard.setPositionX(parentWorldPos.x - position.x);// 有可能parentNode坐标的中心点不是其自身的中心点
        // tempBoard.setPositionZ(parentWorldPos.z - position.y);
        tempBoard.setPositionX(position.x+parentWorldPos.x);// 有可能parentNode坐标的中心点不是其自身的中心点
        tempBoard.setPositionZ(position.y+parentWorldPos.z);
        tempBoard.orgPositionY = bpy;
        tempBoard.setRotationZ(parentNode.getRotationY()*(-1));//本来是转y轴，由于所有的温度的board都已经沿X轴旋转了90度，转完后那以前的"正Y"就变成了"负Z"
        tempBoard.setClient(it.SceneManager.CLIENT_EXT_VITUAL,true);//它的透明不需要filter来处理
        this.dataBox.add(tempBoard);
        return heatMap;
    },

    setDataByField : function(field,heatMap){
        if(!field) return ;
        if(!field.collectors || field.collectors.length < 1){
            return;
        }
        this.dataBox.startBatch();
        for(var i = 0 ; i < field.collectors.size(); i++){
            var collector = field.collectors.get(i);
            if(collector){
                this.createHeatPoint(collector,heatMap,field);
            }
        }
        this.dataBox.endBatch();
    },

    refreshColletor: function(field) {
        if (!field) return;
        if (!field.collectors || field.collectors.length < 1) {
            return;
        }
        for (var i = 0; i < field.collectors.size(); i++){
            var collector = field.collectors.get(i);
            if (collector) {
                if (this.showBillboard(collector)){
                    this.createBillboard(collector, field);
                }
            }
        }
    },

    format: function (value) {
        return "温度:\n" + value.toFixed(1) + "°C";
    },

    /**
     * 是否创建billboard
     * @returns {boolean}
     */
    showBillboard : function(collector){
        return true;
    },

    getToFixed : function(){
        return 0;
    },

    /**
     * @param assetNode
     * @param humValue
    */
    createBillboard : function(collector,field){
        if(!collector) return;
        var collectorId = collector.getId();
        if(!this.tempBillbords){
            this.tempBillbords = {};
        }
        var billboard = this.tempBillbords[collectorId];
        if(!billboard){
            var parentDataId = null;
            if (field) {
                parentDataId = field.getParentDataId();
            }else{
                parentDataId = collector.getParentId();
            }
            var parentNode = this.sceneManager.getNodeByDataOrId(parentDataId);
            var position = collector.getPosition();
            var location = collector.getLocation();//这个也可以是data的id，如果是data的id的话，就以其3D对象的位置计算
            var px,pz,py;
            var p_w_pos = parentNode.getWorldPosition();
            if(location && typeof(location) == 'string' && this.dataManager.getDataById(location)){
                var dataNode = this.sceneManager.getNodeByDataOrId(location);
                if(dataNode){
                    var p_w_pos = it.Util.getNodeCenterPosition(dataNode);
                    px = p_w_pos.x;
                    pz = p_w_pos.z;
                }
            }else{
                px = p_w_pos.x + position.x; 
                pz = p_w_pos.z + position.z;
            }
            var py = p_w_pos.y + position.y;
            var pbb = parentNode.getBoundingBox();
            if(pbb){
                var height = (pbb.max.y-pbb.min.y)/2;
                if(height < 10){ //shapeNode(area)的话。太矮了
                    height = 100;
                }
                py = py + height;
            }else {
                py = py + 100;
            }
            // var canvas = this.createCanvas(collectorId,'','温度:','',null);
            // billboard = it.Util.createSpecailTextBillboard("text",null,true,canvas);//createHumidityBoard
            billboard = new mono.Billboard();
            billboard.s({
                   'm.texture.image':this.createCanvas(collectorId,0,'','',null),
                   'm.transparent': true,
                   'm.alignment': mono.BillboardAlignment.bottomCenter,
                   'm.vertical': !!this.isBillboardVertical, //tue 2017-05-16 Kevin
            }); 
            //如果创建了collector的3d对象的话，应该是该3D对象，否则的话就设置成collector的“父亲”吧(也就是collector的position是相对于那个obj)，
//            billboard.setParent(parentNode);
            billboard.setPositionX(px);
            billboard.setPositionY(py);
            billboard.setPositionZ(pz);
            this.tempBillbords[collectorId] = billboard;
            this.dataBox.add(billboard);
        }
        var value = collector.getValue()||0;
        value = Number(parseFloat(value).toFixed(this.getToFixed()));
        if (billboard._tvalue == value) { //值没有变的话就直接退出
            return;
        }
        var bg = null;
        if(this.bgMap){
            for (var color in this.bgMap) {
                var values = this.bgMap[color];
                if (!values) {
                    continue;
                }
                if (values.length == 2) {
                    if (values[0] != undefined 
                        && values[1] != undefined && value >= values[0] && value < values[1]) {
                        bg = color;
                        break;
                    }else if((values[0] == undefined || values[0] == '') 
                        && values[1] != undefined && value <= values[1]){
                        bg = color;
                        break;
                    }else if(values[0] != undefined 
                        && (values[1] == undefined || values[1] == '') && value >= values[0]){
                        bg = color;
                        break;
                    }
                }else if(values.length == 1 
                    && values[0] != undefined 
                    && value >= values[0]){
                     bg = color;
                     break;
                }
            }
        }
        billboard._tvalue = value;
        var newCanvas = this.createCanvas(collectorId,value,'温度:','°C',bg);
        billboard.setStyle('m.texture.image',newCanvas);
        // billboard.setScale(newCanvas.width / 2, newCanvas.height / 2, 1);
        this.setBillboardScale(billboard,newCanvas);
        billboard.setStyle("m.transparent",false);
        billboard.setStyle("m.alphaTest",0.5);
        var image = it.Util.getImageById(bg, value);
        var scaleX = newCanvas.width/2,scaleY = newCanvas.height/2;
        if (image && image.client) {
            if (image.client['scaleX']) {
                scaleX = parseFloat(image.client['scaleX']);
            }
            if (image.client['scaleY']) {
                scaleY = parseFloat(image.client['scaleY']);
            }
        }
        billboard.setScale(scaleX,scaleY,1);
        billboard.invalidateTexture();
        this.afterCreateBillboard(parentNode,billboard);
    },

    afterCreateBillboard : function(parentNode,billboard){
        // 便于扩展，有可能需要对创建好的billboard做一些扩展
    },

    setBillboardScale : function(billboard,canvas){
        if (billboard && canvas) {
             billboard.setScale(canvas.width / 2, canvas.height / 2, 1);
        }
    },

    createCanvas : function(collectorId,text,titleText,unit,bgcolor){
        var canvas = this.billboardCanvasMap[collectorId];
        // var newCanvas = it.Util.getSpecialTextBillboard(text,titleText,unit,bgcolor,true,canvas);
        // var newCanvas = it.Util.getHumOrTempCanvas(text,titleText,unit,bgcolor,canvas);
        // var newCanvas = this.drawCanvas(text,unit,bgcolor,canvas);
         var newCanvas = it.Util.createHumOrTempCanvas(text,unit,bgcolor,canvas);
        if (!canvas) {
           this.billboardCanvasMap[collectorId] = newCanvas; 
        }
        return newCanvas;
    },

    /*
    drawCanvas: function(text,unit,bgcolor,canvas) {
        var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = parseInt(image.client['fontFamily'])||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = 'bold '+csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
            if (image.client['withUnit']) {
                var width = context.measureText(text).width;
                var unitSize = parseInt(csize/2)||5;
                context.font = 'bold '+unitSize + 'px "Microsoft Yahei"';
                if (image.client['stroke']) {
                     context.strokeText('°C', x+width, y);
                }else{
                     context.fillText('°C', x+width, y);
                }
            }

        }
        return canvas;
    },
    */

    /**
    * b相对于a的位置
    * a是parent或祖宗，b是孩子或子孙
    **/
    getRelativePosition: function(a, b) {
        var m1, m2;
        m1 =  new mono.Mat4().getInverse(a.worldMatrix.clone());
        m2 =  new mono.Mat4().multiplyMatrices(m1, b.worldMatrix.clone());
        var position = new mono.Vec3().getPositionFromMatrix(m2);
        return position;
    },

    createHeatPoint : function(collector,heatMap,field){
        if(!collector || !heatMap) return;
        // var position = collector.getPosition();
        var parentNode = this.sceneManager.getNodeByDataOrId(field.getParentDataId());
        //通过setRotation来计算相对坐标的位置的方法效率非常的低，改成通过getRelativeTransform方式，可是当dataNode本身也旋转了的注意一下
        // var rotationY = parentNode.getRotationY();
        // if (!rotationY) {
        //     parentNode.setRotationY(0);//先将Y轴的旋转设置成0，算好相对位置后再设置回去。这么设置对速度有很大的影响，估计要触发很多事件
        // }
        // var wpp = it.Util.getNodeCenterPosition(parentNode);//parentNode?parentNode.getWorldPosition():new mono.Vec3();
        var rpp = parentNode.getPosition(); //parent的相对坐标

        var position = collector.getPosition();
        var location = collector.getLocation();//这个也可以是data的id，如果是data的id的话，就以其3D对象的位置计算
        var px,pz;
        if(location && typeof(location) == 'string' && this.dataManager.getDataById(location)){
            var dataNode = this.sceneManager.getNodeByDataOrId(location);
            // var rto =  parentNode.getRelativeTransform(dataNode);
            var rto = this.getRelativePosition(parentNode,dataNode);
            if(dataNode){
                var p_w_pos = it.Util.getNodeCenterPosition(dataNode);
                // p_w_pos.x = p_w_pos.x - wpp.x; //将世界坐标转换成相对与floor的中心点的坐标
                // p_w_pos.z = p_w_pos.z - wpp.z;
                p_w_pos.x = rto.x; //rto.position.x; //将世界坐标转换成相对与floor的中心点的坐标
                p_w_pos.z = rto.z; //rto.position.z;
                p_w_pos.x = p_w_pos.x + rpp.x; //因为创建温度场时是按相对与父亲的节点来算的(计算时将其减掉了)，这里需要将其加上,如果
                p_w_pos.z = p_w_pos.z + rpp.z; //是通过getRelativeTransform计算获得的就不需要再加上
                px = p_w_pos.x;
                pz = p_w_pos.z;
            }
        }else{
            var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
            // p_w_pos.x = p_w_pos.x - wpp.x; //将世界坐标转换成相对与floor的中心点的坐标
            // p_w_pos.z = p_w_pos.z - wpp.z;
            // p_w_pos.x = rto.position.x; //将世界坐标转换成相对与floor的中心点的坐标
            // p_w_pos.z = rto.position.z;
            p_w_pos.x = p_w_pos.x ;//+ rpp.x; //因为创建温度场时是按相对与父亲的节点来算的(计算时将其减掉了)，这里需要将其加上
            p_w_pos.z = p_w_pos.z ;//+ rpp.z; 
            px = p_w_pos.x + position.x;
            pz = p_w_pos.z + position.z;
        }
        // if (!rotationY) {
        //    parentNode.setRotationY(rotationY);
        // }

        // p_w_pos 都是算的世界坐标，当floor发生了旋转，那这些坐标其实也发生了旋转。而温度云图最后又转了一把，
        // 解决的办法1：p_w_pos不是世界坐标，而是转换成相对与floor旋转之前的相对坐标;

        var value = collector.getValue();//这是温度值，需要将其转成0-1之间的值(当然是可以超过1的)
        if(value){
            value = parseFloat(value/(this.highestValue||70.0)); //认为70就对应1
        }

        if(px!=undefined && pz!=undefined){
//            heatMap.addPoint(px,pz,collector.getValue() || 0);
            var obj = {
                x: px || 0,
                y: pz || 0,
                w: collector.getWidth() || 0,
                l: collector.getDepth() || 0,
                value: value || 0,
//            axis:axis //旋转轴
            };
            heatMap.addPointWithArea(obj);
        }
        if(this.showBillboard(collector)){
            this.createBillboard(collector,field);
        }
    },

    /**
     * 获取当前场景中的温度场
     */
    getCurrentSceneFields : function(){
        var tFields = [];
        var fields = this.dataManager.getTemperatureFields();
        for(var fid in fields) {
            var tempField = fields[fid];
            if (!tempField) {
                continue;
            }
            if (this.sceneManager.isCurrentSceneInstance(tempField.getParentDataId(),true)) {
                tFields.push(tempField);
            }
        }
        return tFields;
    }

});

it.TemperatureFieldManager = $TemperatureFieldManager;

var $HumidityManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.dataBox = this.sceneManager.network3d.getDataBox();
    this.humCollectors = null;
    this.tempBillbords = {};
    this.bgMap = {}; //背景map {'blue':[minValue,maxValue]} add By Kevin 2016-11-16
    // this._minValue = null; //去掉，改用bgMap来代替
    // this._maxValue = null;
    this.billboardCanvasMap = {};
    this.isBillboardVertical = false;
};

mono.extend($HumidityManager,Object,{

    /**
     * 显示湿度：
     * 显示的是当前场景下的所有的湿度的billboard
     * @returns {number} 返回的是显示的billboard的数量
     */
    show:function(){
        this.humCollectors = this.sceneManager.dataManager._typeCollectors[$Collector.Type.humidity];
        if(!this.humCollectors){
            return 0;
        }
        if(this.intervalIndex){
            return 0;
        }
        var count = 0;
        for(var id in this.humCollectors){
            var collector =  this.humCollectors[id];
            if(collector){
                if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                    this.createBillboard(collector);
                    count++;
                }
            }
        }
        if(count < 1){
            return 0;
        }
        var self = this;
        this.intervalIndex = window.setInterval(function(){
            self.update();
        },5000);
        return count;
    },

    update : function(){
        if(!this.tempBillbords){
            return ;
        }
        for(var id in this.tempBillbords){
            var collector = this.dataManager._collectors[id];
            this.createBillboard(collector);
        }
    },

    hide:function(){
        if(this.intervalIndex){
            window.clearInterval(this.intervalIndex);
            delete this.intervalIndex;
        }
        if(this.tempBillbords){
            for(var id in this.tempBillbords){
                var billboard = this.tempBillbords[id];
                if(billboard){
                    this.dataBox.remove(billboard);
                }
                delete this.tempBillbords[id];
            }
        }
    },

    isShowing : function(){
        if(this.intervalIndex){
            return true;
        }
        return false;
    },

    getToFixed : function(){
        return 2;
    },

    // format: function (value) {
    //     return "湿度:\n" + value.toFixed(1) + "°";
    // },

    createBillboard:function(collector){
        if(!collector) return null;
        var collectorId = collector.getId();
        var billboard = this.tempBillbords[collectorId];
        if(!billboard){
            var parentNode = this.sceneManager.getNodeByDataOrId(collector.getParentId());
            if(!parentNode){
                console.log('parent does not exists!');
                return null;
            }
            var position = collector.getPosition();
            var p_w_pos = it.Util.getNodeCenterPosition(parentNode);
            var px = p_w_pos.x + position.x;
            var pz = p_w_pos.z + position.z;
            var py = p_w_pos.y + position.y; //应该是在parent的顶端+自己
            var pbb = parentNode.getBoundingBox();
            var height = 0;
            if(pbb){
                height =  (pbb.max.y-pbb.min.y)/2;
            }

            if (height < 10) {
                height = 100;
            }
            py = py + height;

            // var canvas = this.createCanvas(collectorId,'','湿度:','',null);
            billboard = new mono.Billboard();
            billboard.s({
                   'm.texture.image':this.createCanvas(collectorId,0,'','',null),
                   'm.transparent': true,
                   'm.alignment': mono.BillboardAlignment.bottomCenter,
                   'm.vertical': !!this.isBillboardVertical, //false
            }); 
        // billboard = it.Util.createSpecailTextBillboard("text",null,true,canvas);//createHumidityBoard
            //如果创建了collector的3d对象的话，应该是该3D对象，否则的话就设置成collector的“父亲”吧(也就是collector的position是相对于那个obj)，
            billboard.setPositionX(px);
            billboard.setPositionY(py);
            billboard.setPositionZ(pz);
            // billboard.setStyle('m.vertical', true);
            this.tempBillbords[collectorId] = billboard;
            this.dataBox.add(billboard);
        }
        var value = parseFloat(collector.getValue()||0);
         if (billboard._tvalue == value) { //值没有变的话就直接退出
            return billboard;
        }
        var bg = null;
        if(this.bgMap){
            for (var color in this.bgMap) {
                var values = this.bgMap[color];
                if (!values) {
                    continue;
                }
                if (values.length == 2) {
                    if (values[0] != undefined 
                        && values[1] != undefined && value >= values[0] && value <= values[1]) {
                        bg = color;
                        break;
                    }else if((values[0] == undefined || values[0] == '')
                        && values[1] != undefined && value <= values[1]){
                        bg = color;
                        break;
                    }else if(values[0] != undefined 
                        && (values[1] == undefined || values[1] == '') && value >= values[0]){
                        bg = color;
                        break;
                    }
                }else if(values.length == 1 
                    && values[0] != undefined 
                    && value >= values[0]){
                     bg = color;
                     break;
                }
            }
        }
        billboard._tvalue = value;
        var canvas = this.createCanvas(collectorId,value.toFixed(this.getToFixed()),'湿度:','%',bg);
        var image = it.Util.getImageById(bg, value);
        var scaleX = canvas.width/2,scaleY = canvas.height/2;
        if (image && image.client) {
            if (image.client['scaleX']) {
                scaleX = parseFloat(image.client['scaleX']);
            }
            if (image.client['scaleY']) {
                scaleY = parseFloat(image.client['scaleY']);
            }
        }
        billboard.setScale(scaleX,scaleY,1);
        // billboard.setScale(canvas.width*1.5,canvas.height*1.5,1);
        billboard.setStyle('m.texture.image',canvas);
        billboard.setStyle("m.transparent",false);
        billboard.setStyle("m.alphaTest",0.5);
        billboard.invalidateTexture();
        return billboard;
    },

    createCanvas : function(collectorId,text,titleText,unit,bgcolor){
        var canvas = this.billboardCanvasMap[collectorId];
        // var newCanvas = it.Util.getHumOrTempCanvas(text,titleText,unit,bgcolor,canvas);
        // var newCanvas = this.drawCanvas(text,unit,bgcolor,canvas);
        var newCanvas = it.Util.createHumOrTempCanvas(text,unit,bgcolor,canvas);
        if (!canvas) {
           this.billboardCanvasMap[collectorId] = newCanvas; 
        }
        return newCanvas;
    },

/*
    drawCanvas: function(text,unit, bgcolor, canvas) {
        var image = it.Util.getImageById(bgcolor, text);
        var canvas = canvas || document.createElement('canvas');
        if (!image) {
            return canvas;
        }
        if (!image.client) {
            image.client = {
                width: 256,
                height: 123,
                size: 50,
                lineWidth: 5,
                color: '#FFFFFF',
                startX: 20,
                startY: 60
            };
        };
        color = image.client['color'] || '#888888';
        var width = image.width,
            height = image.height;
        var context = canvas.getContext('2d');
        width = image.client['width'] || image.width * 2, height = image.client['height'] || image.height * 2;
        canvas.height = height;
        canvas.width = width;
        context.drawImage(image, 0, 0, width, height);
        var x = parseInt(image.client['startX']) || (height - 50);
        var y = parseInt(image.client['startY']) || (height - 50);
        if (text) {
            var csize = parseInt(image.client['size']) || 80;
            var fontFamily = parseInt(image.client['fontFamily'])||'"Microsoft Yahei"';
            // context.font = '80px DigifaceWide';            
            context.font = csize + 'px ' + fontFamily;
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.lineWidth = parseInt(image.client['lineWidth']) || 8;
            if (image.client['stroke']) {
                context.strokeStyle = color;
                context.strokeText(text, x, y);
            } else {
                context.fillStyle = color;
                context.fillText(text, x, y);
            }
        }
        return canvas;
    },
    */

    getsCurrentCollector : function(){
        this.humCollectors = this.sceneManager.dataManager._typeCollectors[$Collector.Type.humidity];
        if(!this.humCollectors)return;
        var currentCollector = [];
        for(var id in this.humCollectors){
            var collector =  this.humCollectors[id];
            if(!collector)continue;
            if(this.sceneManager.isCurrentSceneInstance(collector.getParentId())){
                currentCollector.push(collector);
            }
        }
        return currentCollector;
    }

});


it.HumidityManager = $HumidityManager;
/**
 * terry 处理鼠标点击事件 或许应该改成EventHandler
 */
var $EventHandler = function  () {
	
}

mono.extend($EventHandler,Object,{
    getQueue : function(){
       return 1000;
    },

	shouldHandleDoubleClickElement : function(element,network,data,clickedObj){
       return false;
	},

	shouldHandleMouseUpElement : function(element,network,data,clickedObj){
		return false;
	},

	shouldPropogateDoubleClickElement : function(element,network,data,clickedObj){
       return false;
	},

	shouldHandleDoubleClickBackground : function(network, event){
		return false;
	},

	shouldHandleMouseUpBackground : function(network, event){
		return false;
	},

	shouldPropogateDoubleClickBackground : function(network){
       return false;
	},

	shouldHandleClickElement : function(element,network,data,clickedObj){
       return false;
	},
    
    shouldPropogateClickElement : function(element,network,data,clickedObj){
       return false;
    },

	shouldHandleClickBackground : function(network){
        return false;
	},

	shouldPropogateClickBackground : function(network){
		return false;
	},

	handleDoubleClickBackground : function(network){
        
	},

	handleClickBackground : function(network){
        
	},

	handleDoubleClickElement : function(element,network,data,clickedObj,callback){
	    
	}, 

    handleClickElement : function(element,network,data,clickedObj){
        
    },

    handleMouseMoveElement : function(node,network,data,clickedObj,event){

    },

    handleMouseMoveBackground : function(network){

    },

	handleMouseUpElement : function(node,network,data,clickedObj,event){

	},

	handleMouseUpBackground : function(network){

	},
});

it.EventHandler = $EventHandler;

/**
 * 管理与Network相关的一切事务
 */
var $ViewManager = function (sceneManager, network, for2d) {
    mono.PropertyChangeDispatcher.call(this);
    this.sceneManager = sceneManager;
    this.network = network || this.initView();
    this.network.getRootView().style.position = 'absolute';
    this._for2d = for2d;
    this._defaultNode = new mono.List();
    this.initResource();
    this.configView();
    this.networkParameters = {};
    this.cameraParameters = {};
    this.enableDBLClick = true; //有时想锁定交互时
    this.enableClick = false;
    this.enableMousemove = true;
    this.enableMouseup = false;
    this.visibleMap = {}; //用于缓存是否可见
};

mono.extend($ViewManager, mono.PropertyChangeDispatcher, {
    initView: function () {
        return new mono.Network3D();
    },

    initResource: function () {
        this._eventHandlers = [];
        this._materialFilters = [];
        this.visibleMap = {};
        this._visibleFilters = [];
        this._selectableFilters = [];
        this._renderCallbacks = [];
        this._focusNode = null;
    },

    initDefault: function () {
        this.defaultEventHandler = new it.DefaultEventHandler(this.sceneManager);
        this._eventHandlers.push(this.defaultEventHandler);

        this.defaultMaterialFilter = new it.VirtualManager(this.sceneManager);
        this._materialFilters.push(this.defaultMaterialFilter);

        this.defaultSelectableFilter = new it.SelectableManager(this.defaultMaterialFilter);
        this._selectableFilters.push(this.defaultSelectableFilter);

        var self = this;
        this.addPropertyChangeListener(function (event) {
            if (event.property == "focusNode") { // 注意：如果lookAt的是it.Link
                var node = event.newValue;
                if (self.isDealWithVirtual) {
                    self.dealWithVirtual(node);
                }
                /*
                if (self.defaultMaterialFilter) {
                    if(!node){ // 如果值为空的话，那就认为全部显示
                        self.defaultMaterialFilter.clear();
                    }else{
                        if (self.defaultMaterialFilter.isVirtualOther(self.getDataByNode(node))) {
                            self.defaultMaterialFilter.addAll();
                            self.defaultMaterialFilter.removeByDescendant(node);
                            if(self.sceneManager.isLink(node)){ //如果lookAt的是Link时，还要将fromNode和toNode都显示出来
                                var fromNode = node.getFromNode();
                                var toNode = node.getToNode(); 
                                //有可能是端口，所以得从业务上来获取:
                                var link = self.getDataByNode(node);
                                if (link) {
                                   if (link.getFromId()) {
                                      fromNode = self.sceneManager.getNodeByDataOrId(link.getFromId());
                                   }
                                   if (link.getToId()) {
                                      toNode = self.sceneManager.getNodeByDataOrId(link.getToId());
                                   }
                                }
                                self.defaultMaterialFilter.removeByDescendant(fromNode);
                                self.defaultMaterialFilter.removeByDescendant(toNode);
                            }
                        }else{ // 聚焦不虚幻其他时，则清空，而不是保存上一级虚幻的状态
                          self.defaultMaterialFilter.clear();
                        }
                    }
                }
                */
                /**
                 * add by kevin at 2017-05-25
                 * 这个resetCameraDistance需要谨慎处理，突然设置会导致镜头乱跳 
                 * 1、如果是maxdistance变大的话，如：从机柜跳到room或floor时，应该是先resetDistance。否则camera老是在局部变化
                 * 2、如果是maxdistance变小的话，如：从room或floor到rack时，放到移动好镜头之后。否则camera会突然跑到局部了
                 * 3、minDistance变
                 */
                // self.resetCameraDistance(node); 
                self.setCameraDistanceForBeforePlayCamere(node);
            }
        });

        /* Add 2017-08-23 setCameraDistance其实可以不用这么麻烦，在before时，min=1，max=2w。然后在lookAfter后再置成计算得到的值。
         * 如果before是min最小，max最大，然后after再整一把。这样distance永远不会超出一定的空间，但是当想在中间实现个超出这个范围的动画时，
         * 则总是出现很多的问题 —— 可以考虑这么改进，需要做些测试，确保没有问题
         */
        // 注意有些地方没有调lookAt，而是直接调setFocus，此时就永远不会执行下面的After了 ，注意，如直接进园区 2017-05-31
        // 注意：有可能是动画执行完后执行，但是切换的快的话，动画会掉用setFous时停止，
        //     此时这个会运行在setCameraDistanceForBeforePlayCamere之后执行,那在内部判断一下mainNode是不是以前的focusNode，不是的话就不执行
        this.defaultEventHandler.addAfterLookFinishedAtListener(function (mainNode, node) {
            if (self._focusNode == mainNode) {
                self.setCameraDistanceForAfterPlayCamere(mainNode);
            }
        });

        this.network.setPickingTexturePixel(false);

        // this.network.sortNodes = false; //透明叠加闪闪的问题 -- add By Kevin 2017-05-25
        this.network.sortNodes = true;

        this.tooltipManager = new it.TooltipManager(this.sceneManager);
        this.addEventHandler(this.tooltipManager);
        this.addRenderCallback(this.tooltipManager);
        this.addDefaultYRestrict();
        this.addCameraDistanceRestrict();
        this.setDefaultCamera();

        this.sceneManager.addSceneVisibleChangeListener(function (eve) {
            self.visibleMap = {};
        });
    },

    dealWithVirtual: function (node) {
        if (this.defaultMaterialFilter) {
            if (!node) { // 如果值为空的话，那就认为全部显示
                this.defaultMaterialFilter.clear();
            } else {
                if (this.defaultMaterialFilter.isVirtualOther(this.getDataByNode(node))) {
                    this.defaultMaterialFilter.addAll();
                    this.defaultMaterialFilter.removeByDescendant(node);
                    if (this.sceneManager.isLink(node)) { //如果lookAt的是Link时，还要将fromNode和toNode都显示出来
                        var fromNode = node.getFromNode();
                        var toNode = node.getToNode();
                        //有可能是端口，所以得从业务上来获取:
                        var link = this.getDataByNode(node);
                        if (link) {
                            if (link.getFromId()) {
                                fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                            }
                            if (link.getToId()) {
                                toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                            }
                        }
                        this.defaultMaterialFilter.removeByDescendant(fromNode);
                        this.defaultMaterialFilter.removeByDescendant(toNode);
                    }
                } else { // 聚焦不虚幻其他时，则清空，而不是保存上一级虚幻的状态
                    // this.defaultMaterialFilter.clear();

                    //聚焦不虚化其他改为不虚化它的父亲（杨兴康）
                    this.defaultMaterialFilter.addAll();
                    var data = this.sceneManager.getNodeData(node);
                    this.defaultMaterialFilter.remove(data);
                    var parentId = data._parentId;
                    var parentData = this.sceneManager.dataManager.getDataById(parentId);
                    this.defaultMaterialFilter.remove(parentData);
                }
            }
        }
    },


    getSetMethod: function (key) {
        var setMethod = 'set' + key.charAt(0).toUpperCase() + key.slice(1);
        return setMethod;
    },

    /**
     * 给network设置默认的参数
     */
    setNetworkValue: function (key, value) {
        if (!key) {
            return;
        }
        var setMethod = this.getSetMethod(key);
        if (this.network[setMethod] && (typeof (this.network[setMethod]) === 'function')) {
            this.network[setMethod](value);
        } else {
            this.network[key] = value;
        }
        this.networkParameters[key] = value;
    },

    /**
     * 设置network和camera，使之回到初始化的状态
     */
    resetNetwork: function () {
        if (this.networkParameters) {
            for (var key in this.networkParameters) {
                this.setNetworkValue(key, this.networkParameters[key]);
            }
        }
    },

    /**
     * 给camera设置默认的参数
     */
    setCameraValue: function (key, value) {
        if (!key) {
            return;
        }
        var camera = this.network.getCamera();
        var setMethod = this.getSetMethod(key);
        if (camera[setMethod] && (typeof (camera[setMethod]) === 'function')) {
            camera[setMethod](value);
        } else {
            camera[key] = value;
        }
        this.cameraParameters[key] = value;
    },

    /**
     * 设置camera，使之回到初始化的状态
     */
    resetCamera: function () {
        if (this.cameraParameters) {
            for (var key in this.cameraParameters) {
                this.setCameraValue(key, this.cameraParameters[key]);
            }
        }
    },

    // 除了保留默认的初始话的对象外，删除的其他所有的data
    clear: function () {
        this.defaultMaterialFilter.clearAll();
        var box = this.network.getDataBox();
        box.clear();
        this.network.pm.currentEntity = null; 
        this.network.pm.currentGroup = null; 
        this.network.pm.currentMaterial = null;
        if (this._defaultNode.size() > 0) {
            this._defaultNode.forEach(function (node) {
                if (!(node instanceof mono.Light)) {
                    box.add(node);
                }
            });
        }
    },

    addDefaultNode: function (node) {
        if (!node) {
            return;
        }
        var box = this.network.getDataBox();
        if (!(node instanceof mono.Light)) {
            this._defaultNode.add(node);
        }
        box.add(node);
    },

    initLights: function () { // 用户可以自己定义这个方法。
        var ambientLight = new mono.AmbientLight(0xFFFFFF);
        // var box = this.network.getDataBox();
        this.addDefaultNode(ambientLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(0,1000,-1000);                              
        // this.addDefaultNode(pointLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(0,1000,1000);                               
        //  this.addDefaultNode(pointLight);

        // var pointLight = new mono.PointLight(0xFFFFFF,0.05);                
        // pointLight.setPosition(1000,-1000,-1000);                          
        //  this.addDefaultNode(pointLight);


        var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 10000, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(-10000, 10000, -10000);
        this.addDefaultNode(pointLight);
        var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 10000, -10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(-10000, 10000, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, 10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, -10000);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(10000, 0, 0);
        this.addDefaultNode(pointLight);
        pointLight = new mono.PointLight(0xFFFFFF, 0.05);
        pointLight.setPosition(0, 0, -10000);
        this.addDefaultNode(pointLight);
    },

    addDefaultYRestrict: function () {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        defaultInteraction.yRistrict = true;
        defaultInteraction.yLowerLimitAngle = 0; //-Math.PI/20;
        defaultInteraction.yUpLimitAngle = Math.PI / 4;
        defaultInteraction.minDistance = 200;
        defaultInteraction.maxDistance = 10000;
    },

    removeDefaultYRestrict: function () {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        defaultInteraction.yRistrict = true;
        defaultInteraction.yLowerLimitAngle = -Math.PI / 2;
        defaultInteraction.yUpLimitAngle = Math.PI / 2;
        defaultInteraction.minDistance = 0;
        defaultInteraction.maxDistance = Infinity;
    },

    setDistance: function (minDistance, maxDistance) {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        if (minDistance || minDistance == 0) {
            defaultInteraction.minDistance = 0;
        }
        if (maxDistance) {
            defaultInteraction.maxDistance = Infinity;
        }
    },

    configView: function () {
        // this.initLights(); // remove to lightManager

        //        var networkView = this.network.getView();
        //        if(networkView
        //            && networkView.parentNode
        //            && networkView.parentNode.parentNode
        //            && networkView.parentNode.parentNode == document.body){ //只有当view的parent为body时才调整一把，由于是在appendChild之前就调用了,所以这里老是null
        //            mono.Utils.autoAdjustNetworkBounds(this.network,document.documentElement,'clientWidth', 'clientHeight', 0, 35);
        //        }
        var self = this,
            mousedown = false,
            mousemove = false;
        this.network.getRootView().addEventListener('dblclick', function (e) {
            if (!self.enableDBLClick) {
                return;
            }
            var element = self.filterDoubleClickElement(e);
            if (element && self.isHandleDoubleClickable(element.element)) {
                self.handleDoubleClick(element);
            } else if (element && element.element.getClient('bid') == 'unableDBLClick') { //bid为unableDBLClick资产不处理dblclick（处理添加资产问题） --loda
                return false;
            } else {
                self.handleDoubleClickBackground();
            }
        });

        this.network.getRootView().addEventListener('click', function (e) {
            if (!self.enableClick) { //默认情况下我们的click是关闭的，如果模型的面比较复杂的话，如在我们内置的datacenter中，picker比较耗时，一般情况下我们的click是没有用到的
                return;
            }
            var element = self.filterClickElement(e);
            if (element) {
                self.handleClick(element);
            } else {
                self.handleClickBackground();
            }
        });

        this.network.getRootView().addEventListener('mousedown', function (e) {
            mousedown = true;
            mousemove = false;
        });

        this.network.getRootView().addEventListener('mouseup', function (e) {
            mousedown = false;

            if (!self.enableMouseup) { //默认情况下我们的click是关闭的，如果模型的面比较复杂的话，如在我们内置的datacenter中，picker比较耗时,目前的mousemove用于显示tooltip
                return;
            }
            e._mousemove = mousemove;
            mousemove = false;
            var element = self.filterMouseMoveElement(e); //比较耗时，鼠标一移动就去判断是不是有picker相交
            if (element) {
                var node = element.element;
                self.handleMouseUpElement(element, e);
            } else {
                self.handleMouseUpBackground(e);
            }

        });

        this.network.getRootView().addEventListener('mousemove', function (e) {
            mousemove = true;
            if (!self.enableMousemove) { //默认情况下我们的click是关闭的，如果模型的面比较复杂的话，如在我们内置的datacenter中，picker比较耗时,目前的mousemove用于显示tooltip
                return;
            }
            e._mousedown = mousedown;
            if (mousedown) {
                return;
            }
            var element = self.filterMouseMoveElement(e); //比较耗时，鼠标一移动就去判断是不是有picker相交
            if (element) {
                var node = element.element;
                self.handleMouseMoveElement(element, e);
            } else {
                self.handleMouseMoveBackground(e);
            }
        });

        this.setOverLoadMaterial();
        this.setVisibleFunction();
        this.setSelectableFunction();
        this.setNetworkRenderCallback();
    },

    /**
     * 该Element是否可以双击，默认是可以双击
     * 为了扩展，先天空盒这个node,双击它其实不应该触发handleDoubleClick，而应该触发handleDoubleClickBackground，
     *         为了处理类似这样的对象，这里提供这样的方式可供扩展。
     */
    isHandleDoubleClickable: function (node) {
        return true;
    },

    getDataByNode: function (node) {
        if (!node) {
            return null;
        }

        var data = this.sceneManager.getNodeData(node);
        if (data == null && node.getParent()) {
            var parent = node.getParent();
            data = this.sceneManager.getNodeData(parent);
            if (data == null && parent.getParent()) {
                data = this.sceneManager.getNodeData(parent.getParent());
            }
        }
        return data;
    },

    setFocusNode: function (node, dealWithVirtual) {
        if (dealWithVirtual == undefined) {
            dealWithVirtual = true;
        }
        if (this._focusNode == node) {
            return;
        }
        var data = this.getDataByNode(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().indexOf('earth') >= 0) { //why？？？
            this._focusNode = null; // 至少也应该为null吧，否则在Floor场景中点击Earth回到地球时，会有混乱的情况
            return;
        }
        var oldNode = this._focusNode;
        this._focusNode = node;
        this.isDealWithVirtual = dealWithVirtual;
        this.firePropertyChange("focusNode", oldNode, node);
        this.isDealWithVirtual = true;
    },

    getFocusNode: function () {
        return this._focusNode;
    },

    getDefaultEventHandler: function () {
        return this.defaultEventHandler;
    },

    removeDefaultEventHandler: function () {
        if (this.defaultEventHandler) {
            this.removeEventHandler(this.defaultEventHandler);
            this.defaultEventHandler = null;
        }
    },

    getDefaultVirtualMaterialFilter: function () {
        return this.defaultMaterialFilter;
    },

    removeDefaultMaterialFilter: function () {
        if (this.defaultMaterialFilter) {
            this.removeMaterialFilter(this.defaultMaterialFilter);
            this.defaultMaterialFilter = null;
        }
    },

    getDefaultInteraction: function () {
        return this.network.getDefaultInteraction();
    },

    addMaterialFilter: function (materialFilter) {
        if (!this.includeMaterialFilter(materialFilter)) {
            this._materialFilters.push(materialFilter);
        }
    },

    removeMaterialFilter: function (materialFilter) {
        var index = this._materialFilters.indexOf(materialFilter);
        if (index !== -1) {
            if (materialFilter.destoryBillboard) {
                materialFilter.destoryBillboard(); // 删除materialFilter前的先clear它所设置的Billboard
            }
            if (materialFilter.destoryParticle) {
                materialFilter.destoryParticle();
            }
            this._materialFilters.splice(index, 1);
        }
    },

    includeMaterialFilter: function (materialFilter) {
        var index = this._materialFilters.indexOf(materialFilter);
        if (index !== -1) {
            return true;
        }
        return false;
    },

    addVisibleFilter: function (visibleFilter) {
        if (!this.includeVisibleFilter(visibleFilter)) {
            this.visibleMap = {};
            this._visibleFilters.push(visibleFilter);
        }
    },

    removeVisibleFilter: function (visibleFilter) {
        var index = this._visibleFilters.indexOf(visibleFilter);
        if (index !== -1) {
            this.visibleMap = {};
            this._visibleFilters.splice(index, 1);
        }
    },

    includeVisibleFilter: function (visibleFilter) {
        var index = this._visibleFilters.indexOf(visibleFilter);
        if (index !== -1) {
            return true;
        } else {
            return false;
        }
    },

    addSelectableFilter: function (selectableFilter) {
        this._selectableFilters.push(selectableFilter);
    },

    removeSelectableFilter: function (selectableFilter) {
        var index = this._selectableFilters.indexOf(selectableFilter);
        if (index !== -1) {
            this._selectableFilters.splice(index);
        }
    },

    addEventHandler: function (eventHandler, index) {
        if (eventHandler instanceof it.EventHandler) {
            if (index === undefined) {
                return this._eventHandlers.push(eventHandler);
            } else {
                return this._eventHandlers.splice(index, 0, eventHandler);
            }
        }
    },

    removeEventHandler: function (eventHandler) {
        var index = this._eventHandlers.indexOf(eventHandler);
        if (index !== -1) {
            this._eventHandlers.splice(index, 1);
        }
    },

    addRenderCallback: function (renderCallback, index) {
        if (this._renderCallbacks.indexOf(renderCallback) >= 0) { //已经加过的话，直接返回
            return;
        }
        if (renderCallback.onRenderCallback) {
            if (index === undefined) {
                return this._renderCallbacks.push(renderCallback);
            } else {
                return this._renderCallbacks.splice(index, 0, renderCallback);
            }
        }
    },

    removeRenderCallback: function (renderCallback) {
        var index = this._renderCallbacks.indexOf(renderCallback);
        if (index !== -1) {
            this._renderCallbacks.splice(index, 1);
        }
    },

    filterMouseMoveElement: function (event) {
        return this.network.getFirstElementByMouseEvent(event, false);
    },

    handleMouseMoveElement: function (element, event) {
        var node = element.element;
        var data = this.getDataByNode(node);
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            eventHandler.handleMouseMoveElement(node, this.network, data, element, event);
        }
    },

    handleMouseMoveBackground: function (event) {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            eventHandler.handleMouseMoveBackground(this.network, event);
        }
    },

    handleMouseUpElement: function (element, event) {
        var node = element.element;
        var data = this.getDataByNode(node);
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleMouseUpElement(node, this.network, data, element, event)) {
                eventHandler.handleMouseUpElement(node, this.network, data, element, event);
                return;
            }
        }
    },

    handleMouseUpBackground: function (event) {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleMouseUpBackground(this.network, event)) {
                eventHandler.handleMouseUpBackground(this.network, event);
                return;
            }
        }
    },

    /**
     * 是否过滤掉虚化的对象
     */
    isFilterVirtualElement: function () {
        return true;
    },

    filterDoubleClickElement: function (event) {
        var filterFunction = null;
        // 天空盒在天空盒那块已经处理好了
        // var currentScene = this.sceneManager.getCurrentScene();
        // if(currentScene && currentScene.getCategoryId().toLowerCase().indexOf('datacenter')>=0){
        //   filterFunction = function(ele){
        //       if(ele.getClient('type') == 'parkSkybox'){
        //          return false;
        //      }
        //       return true;
        //   }
        // }
        var self = this;
        if (this.isFilterVirtualElement()) {
            filterFunction = function (ele) {
                return self.isVirtual(ele);
            }
        }
        return this.network.getFirstElementByMouseEvent(event, false, filterFunction);
    },

    getFirstElementInIntersectsByMouseEvent: function (intersects, event, intersectUnVisible, filterFunction) {
        var picking = this.network.getPickingByEvent(event);
        var list = intersects;
        if (intersects instanceof mono.List) {
            list = intersects.toArray();
        }
        var objects = picking.intersectObjects(list, false, intersectUnVisible);
        if (objects.length) {
            for (var i = 0; i < objects.length; i++) {
                var first = objects[i];
                var object3d = first.element;
                if (filterFunction == null || filterFunction.call(null, object3d)) {
                    return first;
                }
            }
        }
        return null;
    },

    getAnimation: function (element) {
        var node = element.element ? element.element : element;
        var animation = node.getClient('animation');
        return animation;
    },

    playAnimation: function (element, animation) {
        animation = animation || this.getAnimation(element);
        if (animation) {
            //          mono.AniUtil.playAnimation(element.element || element, animation);
            make.Default.playAnimation(element.element || element, animation);
        }
    },

    filterClickElement: function (event) {
        return this.network.getFirstElementByMouseEvent(event, false);
    },


    handleDoubleClick: function (element) {
        var node = element.element;
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if (eventHandler.shouldHandleDoubleClickElement(node, this.network, data, element)) {
                eventHandler.handleDoubleClickElement(node, this.network, data, element);
                return;
            }
        }
        var animation = this.getAnimation(node);
        if (animation) {
            this.playAnimation(node, animation);
        }
    },

    handleClick: function (element) {
        var node = element.element;
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if (eventHandler.shouldHandleClickElement(node, this.network, data, element)) {
                eventHandler.handleClickElement(node, this.network, data, element);
                return;
            }
        }
    },

    handleDoubleClickBackground: function () {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleDoubleClickBackground(this.network)) {
                eventHandler.handleDoubleClickBackground(this.network);
                return;
            }
        }
    },

    handleClickBackground: function () {
        var i = 0,
            eventHandler;
        for (; i < this._eventHandlers.length; i++) {
            eventHandler = this._eventHandlers[i];
            if (eventHandler.shouldHandleClickBackground(this.network)) {
                eventHandler.handleClickBackground(this.network);
                return;
            }
        }
    },

    clearVisibleMap: function () {
        this.visibleMap = {};
        this.network.dirtyNetwork();
    },

    setOverLoadMaterial: function () { // 虚幻管理
        var network = this.network;
        // network.sortOpaqueOrderByMaterial = false; // 2018-01-16就按照默认的，true表示的是按距离排序
        var self = this,
            mfs = this._materialFilters;
        network.getOverLoadMaterial = function (node, material) {
            // if (!node.isVisible() || !self.visibleMap[node.getId()]) {
            //    return null;
            // } // update by Kevin 2017-06-09 有的Visible是在虚化的里面处理的，若直接返回则无法还原
            var isVirtual = false;
            var filterdMaterial = null;
            for (var i = 0; i < mfs.length; i++) {
                var mf = mfs[i];
                filterdMaterial = mf.filterMaterial(material, filterdMaterial, node);
                if (mf && mf.isVirtual && mf.isVirtual(node)) {
                    isVirtual = true;
                }
            }
            // if (isVirtual) {
            //    if (node._orgDepthMask == undefined) {
            //       node._orgDepthMask = node.getStyle('m.depthMask');
            //    }
            //    node.setStyle('m.depthMask', false); // Kevin 2018-01-23 如果是虚化的对象，那就让透明的背景色不是network的背景色
            // }else{
            //    if (node._orgDepthMask != undefined) {
            //       node.setStyle('m.depthMask', node._orgDepthMask); 
            //    }
            // }
            return filterdMaterial;
        };
    },

    setVisibleFunction: function () {
        var network = this.network;
        var self = this;
        network.isVisible = function (node) {
            /*if (node) {
              if (!node.isVisible()) { //优先级最高，因为这里没有监听它(node的的visible)改变
                    return false;
              }
              if (self.visibleMap[node.getId()] == true) {
                 return true;
              }else if(self.visibleMap[node.getId()] == false){
                 return false;
              }else{
                if(node instanceof TGL.Link || node instanceof TGL.PathLink){
                      if(!this.isVisible(node._fromNode)){
                          self.visibleMap[node.getId()] = false;
                          return false;
                      }
                      if(!this.isVisible(node._toNode)){
                          self.visibleMap[node.getId()] = false;
                          return false;
                      }
                }
                var vf = self._visibleFilters;
                for(var i = 0;i < vf.length;i ++){
                    var filter = vf[i];
                    if(!filter.isVisible(node,self.getDataByNode(node),network)){ //注意，只处理不可见对象,可见的才会继续找下一个filter
                        self.visibleMap[node.getId()] = false;
                        return false;
                    }
                }
              }
            }
            self.visibleMap[node.getId()] = true;
            return true;
            */
            return self.isVisible(node);
        }
    },

    setSelectableFunction: function () {
        var self = this;
        this.network.selectableFunction = function (node) {
            if (node) {
                var sfs = self._selectableFilters;
                if (!sfs || sfs.length < 1) {
                    return true;
                }
                for (var i = 0; i < sfs.length; i++) {
                    var sf = sfs[i];
                    if (!sf.isSelectable(node, self.network)) {
                        return false;
                    }
                }
            }
            return true;
        }
    },

    setNetworkRenderCallback: function () {
        var self = this;
        var rcs = this._renderCallbacks;
        this.network.renderCallback = function () {
            for (var i = 0; i < rcs.length; i++) {
                var renderCallback = rcs[i];
                renderCallback.onRenderCallback(self.network);
            }
        };
    },

    /**
     * 根据node计算其minDistance
     */
    _computeMinDistanceByNode: function (node) {
        if (!node) {
            return 0;
        }
        var bb = node.getBoundingBox();
        var minDistance = 0;
        if (bb && bb.size()) {
            minDistance = bb.size().x;
            if (bb.size().y < minDistance) { // add By Kevin 2017-06-08 以最小的为标准
                minDistance = bb.size().y;
            }
            if (bb.size().z < minDistance) {
                minDistance = bb.size().z;
            }
            if (minDistance) {
                minDistance += this.network.getCamera().getNear() * 0.6;
            }
        }
        return minDistance;
    },

    getMinDistanceByNode: function (node) {
        var data = this.sceneManager.getNodeData(node);
        if (data && data instanceof $Link) {
            var fromNode = this.sceneManager.getNodeByDataOrId(data.getFromId());
            var toNode = this.sceneManager.getNodeByDataOrId(data.getToId());
            var fromMinDistance = this._computeMinDistanceByNode(fromNode);
            var toMinDistance = this._computeMinDistanceByNode(toNode);
            if (fromMinDistance < toMinDistance) {
                return fromMinDistance;
            } else {
                return toMinDistance;
            }
        }
        return this._computeMinDistanceByNode(node);
    },

    getCameraDistanceByNode: function (lookAtNode) {
        if (!lookAtNode) {
            return null;
        }
        var fov = this.network.getCamera().getFov() || 70;
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) { //自定义的第一人称视角时可能就没有defaultInteraction了
            return;
        }
        var data = this.sceneManager.getNodeData(lookAtNode);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        var _minDistance = defaultInteraction.minDistance;
        var _maxDistance = defaultInteraction.maxDistance;
        var comNode = lookAtNode.getClient('complexNode');
        if (comNode == 'unload') {
            comNode = this.sceneManager.loadComplexNode(data);
        }
        lookAtNode = comNode || lookAtNode;
        if (!lookAtNode || !lookAtNode.getBoundingBoxWithChildren) { // 是billboard
            return null;
        }
        var bb = lookAtNode.getBoundingBoxWithChildren();
        var minDistance = this.getMinDistanceByNode(lookAtNode);
        if (!category) { //有可能是link
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
            return;
        }
        var cId = category.getId().toLowerCase();
        var currentScene = this.sceneManager.getCurrentScene();
        if (cId.indexOf('datacenter') >= 0) {
            var maxDistance = 1500;
            var maxSize = 0
            if (bb && bb.size().x) {
                maxSize = bb.size().x;
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
            }
            if (maxSize > 0) {
                maxDistance = maxSize * Math.atan(Math.PI * (90 - fov / 2) / 360);
            }
            _minDistance = 300;
            _maxDistance = maxDistance; //2000
        } else if (cId.indexOf('building') >= 0) { //这里要注意一下，有可能building的floors是整合到了dc中
            if (currentScene && currentScene.getCategoryId().toLowerCase().indexOf('building') >= 0) {
                _minDistance = 100;
                _maxDistance = 10000;
            } else {
                var rootNode = this.sceneManager.getCurrentRootNode();
                if (rootNode) {
                    var comNode = rootNode.getClient('complexNode');
                    if (comNode == 'unload') {
                        comNode = this.sceneManager.loadComplexNode(this.sceneManager.getNodeData(rootNode));
                    }
                    rootNode = comNode || rootNode;
                }
                var bb = rootNode ? rootNode.getBoundingBox() : null;
                var maxDistance = 2000;
                if (bb) {
                    var maxLength = bb.size().x;
                    if (bb.size().y > maxLength) {
                        maxLength = bb.size().y;
                    }
                    if (maxLength) {
                        maxDistance = maxLength * Math.atan(Math.PI * (90 - fov / 2) / 180);
                    }
                }
                if (maxDistance == -Infinity) {
                    maxDistance = 2000;
                }
                _minDistance = 200;
                _maxDistance = maxDistance; //2000
            }
        } else if (cId.indexOf('floor') >= 0 || cId.indexOf('channel') >= 0 || cId.indexOf('area') >= 0 || cId.indexOf('room') >= 0) {
            _minDistance = 100;
            _maxDistance = 10000;
            if (bb && bb.size()) { // 有可能floor超级大
                var maxSize = 0;
                if (bb.size().x > maxSize) {
                    maxSize = bb.size().x;
                }
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
                if (bb.size().y > maxSize) {
                    maxSize = bb.size().y;
                }
                if (maxSize > 10000) {
                    _maxDistance = maxSize;
                }
            }
        } else if (cId.indexOf('rack') >= 0 || cId.indexOf('equipment') >= 0 || cId.indexOf('card') >= 0) {
            minDistance = this.calcCameraMinDistance(lookAtNode, minDistance);
            _minDistance = minDistance || 50;
            _maxDistance = 500; //1000太大 ，update by Kevin 2017-05-26
        } else {
            _minDistance = minDistance || 200;
            _maxDistance = 10000;
        }
        if (currentScene && category && currentScene.defaultInteractionParameters && currentScene.getCategoryId() == category.getId()) {
            var defParams = currentScene.defaultInteractionParameters;
            if (parseInt(defParams.maxDistance)) {
                _maxDistance = parseInt(defParams.maxDistance);
            }
            if (parseInt(defParams.minDistance)) {
                _minDistance = parseInt(defParams.minDistance);
            }
        }
        return { maxDistance: _maxDistance, minDistance: _minDistance };
    },

    calcCameraMinDistance: function (node, minDistance) {
        var bb = node.getBoundingBox();
        if (!bb && !bb.size()) {
            return;
        }
        var x = bb.size().x;
        var y = bb.size().y;
        var z = bb.size().z;
        var arr = [];
        arr.push(parseInt(Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))));
        arr.push(parseInt(Math.sqrt(Math.pow(y, 2) + Math.pow(z, 2))));
        arr.push(parseInt(Math.sqrt(Math.pow(x, 2) + Math.pow(z, 2))));
        var near = this.network.getCamera().near;
        arr.push(near);
        arr = arr.sort(function (pre, next) {
            return pre - next
        });
        var max = arr[arr.length - 1];
        if (minDistance < max) {
            minDistance = max + near * 0.2;
        }
        return minDistance;
    },

    /**
     * 为了防止camera在play一开始时镜头突然乱跳的问题，将resetCameraDistance拆成setCameraDistanceForBeforePlayCamere和setCameraDistanceForAfterPlayCamere
     * setCameraDistanceForBeforePlayCamere：在play lookAt动画之前
     * 这时：当maxDistance变大了才改变camera的maxDistance，当minDistance变小才改变camera的minDistance
     */
    setCameraDistanceForBeforePlayCamere: function (node) {
        if (!this.cameraDistanceRestrict || !node) {
            return;
        }
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var distanceObj = this.getCameraDistanceByNode(node);
        if (!distanceObj) {
            return;
        }
        var orgMaxDistance = defaultInteraction.maxDistance;
        var orgMinDistance = defaultInteraction.minDistance;
        var minDistance = distanceObj.minDistance;
        var maxDistance = distanceObj.maxDistance;
        if (maxDistance && maxDistance > orgMaxDistance) {
            defaultInteraction.maxDistance = maxDistance;
        }
        if (minDistance && minDistance < orgMinDistance) {
            defaultInteraction.minDistance = minDistance;
        }
        // */ 
        // defaultInteraction.minDistance = 1;
        // defaultInteraction.maxDistance = 20000;
    },

    /**
     * setCameraDistanceForAfterPlayCamere lookAt的动画完成之后
     * 这时：当maxDistance变小了才改变camera的maxDistance，当minDistance变大了才改变camera的minDistance
     */
    setCameraDistanceForAfterPlayCamere: function (node) {
        if (!this.cameraDistanceRestrict || !node) {
            return;
        }
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var distanceObj = this.getCameraDistanceByNode(node);
        if (!distanceObj) {
            return;
        }

        var orgMaxDistance = defaultInteraction.maxDistance;
        var orgMinDistance = defaultInteraction.minDistance;
        var minDistance = distanceObj.minDistance;
        var maxDistance = distanceObj.maxDistance;
        // if (maxDistance && maxDistance < orgMaxDistance) {
        //    defaultInteraction.maxDistance = maxDistance;
        // }
        // if (minDistance && minDistance > orgMinDistance) {
        //    defaultInteraction.minDistance = minDistance;
        // } 
        if (maxDistance) {
            defaultInteraction.maxDistance = maxDistance;
        }
        if (minDistance) {
            defaultInteraction.minDistance = minDistance;
        }
    },

    /**
     * 这些应该放到数据库中，让用户自己来决定到底是多少，有的DC大，有的DC小
     * @param lookAtNode
     */
    resetCameraDistance: function (lookAtNode) {
        if (!this.cameraDistanceRestrict || !lookAtNode) {
            return;
        }
        var fov = this.network.getCamera().getFov() || 70;
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        var data = this.sceneManager.getNodeData(lookAtNode);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        var comNode = lookAtNode.getClient('complexNode');
        if (comNode == 'unload') {
            comNode = this.sceneManager.loadComplexNode(data);
        }
        lookAtNode = comNode || lookAtNode;
        // var bb = lookAtNode.getBoundingBox();
        var bb = lookAtNode.getBoundingBoxWithChildren();
        //minDistance 应该根据自身的boundingBox计算所得
        var minDistance = this.getMinDistanceByNode(lookAtNode);
        if (!category) { //有可能是link
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
            return;
        }
        var cId = category.getId().toLowerCase();
        var currentScene = this.sceneManager.getCurrentScene();
        if (cId.indexOf('datacenter') >= 0) {
            var maxDistance = 1500;
            var maxSize = 0
            if (bb && bb.size().x) {
                maxSize = bb.size().x;
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
            }
            if (maxSize > 0) {
                maxDistance = maxSize * Math.atan(Math.PI * (90 - fov / 2) / 360);
            }
            defaultInteraction.minDistance = 300;
            defaultInteraction.maxDistance = maxDistance; //2000
        } else if (cId.indexOf('building') >= 0) { //这里要注意一下，有可能building的floors是整合到了dc中
            if (currentScene &&
                currentScene.getCategoryId().toLowerCase().indexOf('building') >= 0) {
                defaultInteraction.minDistance = 100;
                defaultInteraction.maxDistance = 10000;
            } else {
                var rootNode = this.sceneManager.getCurrentRootNode();
                if (rootNode) {
                    var comNode = rootNode.getClient('complexNode');
                    if (comNode == 'unload') {
                        comNode = this.sceneManager.loadComplexNode(this.sceneManager.getNodeData(rootNode));
                    }
                    rootNode = comNode || rootNode;
                }
                var bb = rootNode ? rootNode.getBoundingBox() : null;
                var maxDistance = 2000;
                if (bb) {
                    var maxLength = bb.size().x;
                    if (bb.size().y > maxLength) {
                        maxLength = bb.size().y;
                    }
                    if (maxLength) {
                        maxDistance = maxLength * Math.atan(Math.PI * (90 - fov / 2) / 180);
                    }
                }
                if (maxDistance == -Infinity) {
                    maxDistance = 2000;
                }
                defaultInteraction.minDistance = 200;
                defaultInteraction.maxDistance = maxDistance; //2000
            }
        } else if (cId.indexOf('floor') >= 0 ||
            cId.indexOf('channel') >= 0 ||
            cId.indexOf('area') >= 0 ||
            cId.indexOf('room') >= 0) {
            defaultInteraction.minDistance = 100;
            defaultInteraction.maxDistance = 10000;
            if (bb && bb.size()) { // 有可能floor超级大
                var maxSize = 0;
                if (bb.size().x > maxSize) {
                    maxSize = bb.size().x;
                }
                if (bb.size().z > maxSize) {
                    maxSize = bb.size().z;
                }
                if (bb.size().y > maxSize) {
                    maxSize = bb.size().y;
                }
                if (maxSize > 10000) {
                    defaultInteraction.maxDistance = maxSize;
                }
            }
        } else if (cId.indexOf('rack') >= 0 || cId.indexOf('equipment') >= 0 || cId.indexOf('card') >= 0) {
            defaultInteraction.minDistance = minDistance || 50;
            defaultInteraction.maxDistance = 1000;
        } else {
            defaultInteraction.minDistance = minDistance || 200;
            defaultInteraction.maxDistance = 10000;
        }
        if (currentScene && category &&
            currentScene.defaultInteractionParameters &&
            currentScene.getCategoryId() == category.getId()) {
            var defParams = currentScene.defaultInteractionParameters;
            if (parseInt(defParams.maxDistance)) {
                defaultInteraction.maxDistance = parseInt(defParams.maxDistance);
            }
            if (parseInt(defParams.minDistance)) {
                defaultInteraction.minDistance = parseInt(defParams.minDistance);
            }
        }
    },

    /**
     * 动态的设置minDistance和maxDistance
     */
    setCameraDistance: function (minDistance, maxDistance) {
        var defaultInteraction = this.getDefaultInteraction();
        if (!defaultInteraction) {
            return;
        }
        if (minDistance != null && minDistance != undefined && parseInt(minDistance)) {
            defaultInteraction.minDistance = parseInt(minDistance);
        }
        if (maxDistance != null && maxDistance != undefined && parseInt(maxDistance)) {
            defaultInteraction.maxDistance = parseInt(maxDistance);
        }
    },

    setSelectedStype: function (nodes, selectColor) {
        if (!nodes) {
            return;
        } else if (nodes instanceof Array && nodes.length < 1) {
            return;
        }
        this.defaultInteractions = this.network.getInteractions();
        var interaction = new mono.DefaultInteraction(this.network);
        interaction.maxDistance = 3000;
        interaction.minDistance = 800;
        this.network.setInteractions([interaction]);
        var selectColor = selectColor || '#0431B4';
        var smodel = this.network.getDataBox().getSelectionModel();
        if (nodes instanceof Array) {
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                node.s({
                    'm.type': 'phong',
                    'select.style': 'outline.glow',
                    'select.color': selectColor
                });
                smodel.appendSelection(node);
            }
        } else {
            nodes.s({
                'm.type': 'phong',
                'select.style': 'outline.glow',
                'select.color': selectColor
            });
            smodel.appendSelection(nodes);
        }

    },

    //    clearSelectedStyle :function(){
    //        if(this.defaultInteractions){
    //
    //        }
    //    },

    addCameraDistanceRestrict: function () {
        this.cameraDistanceRestrict = true;
    },

    removeCameraDistanceRestrict: function () {
        delete this.cameraDistanceRestrict;
    },

    lookAt: function (node) {
        if (this.defaultEventHandler && this.defaultEventHandler.lookAt) {
            this.defaultEventHandler.lookAt(node);
        }
    },

    setDefaultCamera: function () {
        var camera = this.network.getCamera();
        camera.setNear(50);
        camera.fov = 70;
    },

    /**
     * 判断data或node是不是可见，因为该SDK中是否可见不仅仅是通过node自身的isVisible来控制，很多都是通过visibleFilter来控制
     * @param dataOrNode
     * @returns {*}
     */
    /*
    isVisible : function(dataOrNode){
        if(!dataOrNode){
            return false;
        }
        var data = null;
        if(dataOrNode instanceof it.Data){
            data = dataOrNode;
        }else if(dataOrNode instanceof mono.Element){
            data = this.sceneManager.getNodeData(dataOrNode);
        }else if(typeof(dataOrNode) == 'string'){
            data = this.sceneManager.dataManager.getDataById(dataOrNode);
        }
        if(!data){
            return false;
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        if(!node){
            return false;
        }
        if(!this._visibleFilters ||  this._visibleFilters.length < 1){
            return node.isVisible();
        }
        for(var i = 0 ; i < this._visibleFilters.length ; i++){
            var vf = this._visibleFilters[i];
            if(vf && !vf.isVisible(node,data,this.network)){
                return false;
            }
        }
        return true;
    },
    */

    isVisible: function (dataOrNode) {
        if (!dataOrNode) {
            return false;
        }
        var data = null;
        var node = dataOrNode;
        if (dataOrNode instanceof it.Data) {
            data = dataOrNode;
            node = null;
        } else if (node instanceof mono.Billboard && node.getClient('_alarmBillboard')) { //告警的billboard也要处理的
            data = node.getClient('_alarmBillboard');
        } else if (dataOrNode instanceof mono.Element) {
            data = this.sceneManager.getNodeData(dataOrNode);
        } else if (typeof (dataOrNode) == 'string') {
            data = this.sceneManager.dataManager.getDataById(dataOrNode);
            node = null;
        }
        if (!data && !node.getClient('itv_data')) {
            return node.isVisible();
        }
        if (!node) {
            node = this.sceneManager.getNodeByDataOrId(data);
        }
        if (!node) {
            return false;
        }
        if (!node.isVisible()) {
            return false;
        }
        if (this.visibleMap[node.getId()] == true) {
            return true;
        } else if (this.visibleMap[node.getId()] == false) {
            return false;
        } else {
            if (node instanceof TGL.Link || node instanceof TGL.PathLink) {
                if (!this.isVisible.call(this, node._fromNode)) {
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
                if (!this.isVisible.call(this, node._toNode)) {
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
            }
            var vf = this._visibleFilters;
            for (var i = 0; i < vf.length; i++) {
                var filter = vf[i];
                if (!filter.isVisible(node, data, this.network)) { //注意，只处理不可见对象,可见的才会继续找下一个filter
                    this.visibleMap[node.getId()] = false;
                    return false;
                }
            }
        }
        this.visibleMap[node.getId()] = true;
        return true;
    },

    /**
     * 判断该node是不是虚化的，是不是判断在defaultVirtual中是不是虚幻的
     * @param dataOrNode
     */
    isVirtual: function (dataOrNode) {
        // return this.defaultMaterialFilter.isVirtual(dataOrNode);
        for (var i = 0; i < this._materialFilters.length; i++) {
            var vm = this._materialFilters[i];
            if (vm && vm.isVirtual && vm.isVirtual(dataOrNode)) {
                return false;
            }
        }
        return true;
    }



});

it.ViewManager = $ViewManager;

var $ViewManager2D = function(sceneManager,network){
    mono.PropertyChangeDispatcher.call(this);
    this.sceneManager = sceneManager;
    this.map = null;
    this.network = network;
    if(!network){
      if(window.BMap){
        this.network = new twaver.canvas.Network();
        this.network.setRectSelectEnabled(false);
      }else{
        this.network = new twaver.vector.Network();
      }
    }
    this.container = document.createElement('div');
    this.container.style.position = 'absolute';
    this.mapView = null;
    this._visibleFilters = [];
    this._selectableFilters = [];
    this._eventHandlers = [];
    var self =  this;
    this.dbClickHandle = function (event) {
        if(event){
            var element = self.network.getElementAt(event);
            if(element){
                self.handleDoubleClick({element:element});
            }else{
                self.handleDoubleClickBackground();
            }
        }
    };
    //无效，需先将view加到document中方可
    this.network.adjustBounds({ x: 0, y: 0, width:1,height:1});
    this.left = 1;
    this.top = 0;
    this.width = document.documentElement.clientWidth;
    this.height = document.documentElement.clientHeight;
    this.adapter = null;
    this.isCreateMap = false;
//    this.createMap();
    this.focusData = null;
    this.isGis = null;
    var box = this.network.getElementBox();
    this.tree = new twaver.controls.Tree(box);
    this.table = new twaver.controls.Table(box);
    this.tableRule = {}; //table的规则，先注册一个,注册格式为{ID：[{column1},{column2},...]}，id是category或datatype,但是type优先
    this.treeRule = {}; // tree的规则，先注册，格式：{id:{}};
//    this.centerSplit,this.mainSplit;
    this.addTableAndTree();
};

mono.extend($ViewManager2D,mono.PropertyChangeDispatcher,{

    /**
     * @param container,父div，gis将放在该div上，并且这个container在初始化前就应该存在
     */
    createMap : function(){
        this.registerNormalImage('./images/building1.png','b1');
        this.registerNormalImage('./images/building2.png','b2');
        this.registerNormalImage('./images/building3.png','b3');
        if(window.BMap){
            var mainView;
          if(!document.getElementById("mainView")){
            mainView = document.createElement('div');
            mainView.id = "mainView";
            mainView.style.height = "100%";
            document.body.appendChild(mainView);
          }else{
            mainView = document.getElementById("mainView");
          }
          
          mainView.appendChild(this.container);
          this.container.style.height = "100%";
          this.container.style.width = "100%";
          this.mapView = document.createElement('div');
          this.mapView.id = "MapView";
          this.mapView.style.height = "100%";
          this.container.appendChild(this.mapView);

          this.map = new BMap.Map("MapView");
          var map = this.map;
          var point = new BMap.Point(108.95, 34.27);
          map.centerAndZoom(point, 7);
          map.addControl(new BMap.NavigationControl());
          map.enableScrollWheelZoom();
          var networkDom = this.network.getView();
          document.getElementsByClassName("BMap_mask")[0].appendChild(networkDom);
          this.network.adjustBounds({x:0,y:0,width:document.documentElement.clientWidth,height:document.documentElement.clientHeight});


          var network = this.network;
          var self = this;
          network.addInteractionListener(function(event) {
              if(event.kind = "liveMoveBetween") {
                  map.disableDragging();
                  var list = network.getSelectionModel().getSelection();
                  list.forEach(function(element) {
                      var pixel = new BMap.Pixel(element.getX(),element.getY());
                      var point = map.pixelToPoint(pixel)
                      // element.setClient("coordinate", point);
                  });

              }
          });
          network.getView().addEventListener("dbclick", function(event) {
              if(network.getElementAt(event)) {
                  map.disableDoubleClickZoom();
                  event.preventDefault();
              } else {
                  map.enableDoubleClickZoom();
              }
          });
          network.getView().addEventListener("mousedown", function(event) {
              if(!network.getElementAt(event)) {
                  map.enableDragging();
              } else {
                  map.disableDragging();
              }
          });
          network.getView().addEventListener("mousedown", function(event) {
              clickPoint = network.getLogicalPoint(event);
          });
          network.getView().addEventListener("mouseup", function(event) {
              clickPoint = null;
          });

          map.addEventListener("movestart", function(){
              networkDom.style.opacity = 0;
          });
          map.addEventListener("moveend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          map.addEventListener("dragstart", function(){
              networkDom.style.opacity = 0;
              self.changePostionWithMap();
          });
          map.addEventListener("dragend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          map.addEventListener("zoomstart", function(){
              networkDom.style.opacity = 0;
              self.changePostionWithMap();
          });
          map.addEventListener("zoomend", function(){
              networkDom.style.opacity = 1;
              self.changePostionWithMap();
          });
          this.isCreateMap = true;
        }else{
            this.mapView = document.createElement('div');
    //        GisManager.registerDefaultSetting(TWaverGisConst.MAPDRIVER_MAPABC,"http://emap3.mapabc.com/mapabc/maptile?");
            var map = this.map = new twaver.gis.Map(this.mapView,"MapView");
            map.setSize({width:document.documentElement.clientWidth,height:document.documentElement.clientHeight});
            map.setEnableDoubleZoom(false); //设置不能够双击缩放地图
            map.addLayer("BINGMAP",GISConsts.EXECUTOR_TYPE_BINGMAP);//以MapABC作为地图，注意（这里访问的是MapABC的在线地图）
            //如果有地图服务器，并且把地图发布为tile图片，可以把图片放在tomcat之类的服务器中发布起来，然后直接访问
            //map.addLayer("google",GISConsts.EXECUTOR_TYPE_MAPABC,"http://localhost:8080/localecache");
            map.setZoomLevel(5);//设置地图的缩放级别
            map.setCenter(new twaver.gis.geometry.GeoCoordinate(31.41,121.48));//设置地图的中心位置
            this.adapter = new twaver.gis.Adapter();//创建一个适配器对象，用来绑定地图和拓扑
            
            this.isCreateMap = true;
        }
        
    },

    changePostionWithMap:function() {
      if(window.BMap){
        var self = this;
        this.network.getElementBox().forEach(function(element) {
            if(element instanceof twaver.Node) {
                var point = element.getClient("coordinate");
                var pixel = self.map.pointToPixel(point);
                element.setCenterLocation(pixel.x,pixel.y);

            }
        });
      }
    },

    clearContainer : function(){
        var children = this.container.childNodes;
        if(children && children.length > 0){
            for(var i = 0 ; i < children.length ; i++){
                this.container.removeChild(children[i]);
            }
        }
    },

    bindGIS : function(){
        if(this.isGis != null && this.isGis){
            return;
        }
        if(!this.isCreateMap){
            this.createMap();
        }
        if(this.adapter && this.map){
            this.adapter.bindNetworkAndMap(this.network,this.map);
        }
        this.clearContainer();
        this.container.appendChild(this.mapView);
        this.network.getView().removeEventListener("dblclick",this.dbClickHandle);
        if(window.BMap){
            this.map.addEventListener("dblclick",this.dbClickHandle);
        }else{
            this.map.getView().addEventListener("dblclick",this.dbClickHandle);
        }
//        if(!isAdjustBound){ // 如果一开始没有GIS时,那创建好gis后需要在adjust一下，否则node在gis和network上都不显示
//            this.adjustViewBounds(parseInt(this.width)+1);
//        }
        this.adjustViewBounds();
        this.isGis = true;
    },

    unbindGIS : function(){
        if(this.isGis != null && !this.isGis){
            return;
        }
        if(this.adapter){
            this.adapter.unbindNetworkAndMap();
        }
        this.clearContainer();
//        if(this.mainSplit){
//            this.container.appendChild(this.mainSplit.getView());
//        }else{
            this.container.appendChild(this.network.getView());
//        }
//        this.network.adjustBounds({ x: this.left, y: this.top, width: this.width, height: this.height});
        //unbindGis时也的adjust一下，有可能之前都没有2D的场景（之前是一开始和有Gis时才会adjust）,
        // 可是一开始时view并没有append到浏览器中时调用反而导致后来不显示,
        // 可以通过判断container的parentNode是否为空来确定是不是加到了body中,只有加到Body中才可以adjust. 其实这里只要调用一次即可
        if(this.container.parentNode){
            this.adjustViewBounds();
        }
        if(this.map){
            if(window.BMap){
                this.map.removeEventListener("dblclick",this.dbClickHandle);
            }else{
                this.map.getView().removeEventListener("dblclick",this.dbClickHandle);
            }
        }
        this.network.getView().addEventListener("dblclick",this.dbClickHandle);
        this.isGis = false;
    },

    getContainer : function(){
        return this.container;
    },

    removeGis : function(){
            this.unbindGIS();
            this.hideNavigator();
            this.hideOverView();
    },

    addGis : function(showNav,showOverView){
        this.bindGIS();
        if(showNav){
            this.showNavigator();
        }
        if(showOverView){
            this.showOverView();
        }
    },

    /**
     * 2D的network需要先加到body中，然后在adjustBounds，否则无效并且显示不出来
     * 这里既要处理network的bounds，还要处理map的bounds
     * 注意，每次从3D切换回来时都需要重新ajdust一把，并且要使得四个参数中至少有一个参数不一样，如果都一样twaver内部是会直接返回的
     */
    adjustViewBounds : function(width,height,left,top){
        if(arguments.length < 1){
            if(!this.flag){
                this.flag = 1;
            }else{
                this.flag++
            }
            this.width = this.width + Math.pow(-1,parseInt(this.flag));
        }else{
            this.flag = 0;
        }
        this.left = left || this.left;
        this.top = top || this.top;
        this.width = width || this.width;
        this.height = height || this.height;
//        if(this.container.contains(this.network.getView())){ //不管是不是包含，都得adjust，否则node不会显示出来
            this.network.adjustBounds({ x: this.left, y: this.top, width: this.width, height: this.height});
//        }
        if(this.isCreateMap && this.map){
          if(window.BMap){

          }else{
            this.map.setSize({width:this.width,height:this.height});
            this.map.content.style.left = this.left + 'px';
            this.map.content.style.top = this.top + 'px';
          }
        }
//        this._createNetwork2D = true;
    },

    setZoomLevel : function(zoomLevel){
      if(zoomLevel && this.isCreateMap && this.map){
        if(window.BMap){

        }else{
          this.map.setZoomLevel(5);
        }
      }
    },

    setCenter : function(center){
        if(this.isCreateMap && this.map && center && center.x && center.y){
          if(window.BMap){
            var point = new BMap.Point(center.y, center.x);
            this.map.centerAndZoom(point, 7);
          }else{
            this.map.setCenter(new twaver.gis.geometry.GeoCoordinate(center.x,center.y));
          }
        }
    },

    showNavigator :function(x,y){
        if(!this.isCreateMap) {
            return;
        }
        if(window.BMap){
          return;
        }
        var nav = document.getElementById('navigator_id');
        if(nav){
            nav.style.display = 'block';
        }else{
            var navigator = new twaver.gis.gadget.Navigator("navigator_id",this.map);
            if(!x){
                x = 20;
            }
            if(!y){
                y = 50;
            }
            this.map.installGadget(navigator,{x:x,y:y});
        }
    },

    hideNavigator : function(){
        if(!this.isCreateMap) {
            return;
        }
        var nav = document.getElementById('navigator_id');
//        if(nav && nav.parentElement){
//            nav.parentElement.removeChild(nav);
//        }
        if(nav){
            nav.style.display = 'none';
        }
    },

    showOverView : function(right,bottom,width,height){
        if(!this.isCreateMap) {
            return ;
        }
        if(window.BMap){
          return;
        }
        if(this.overview && this.overview.getView()){
            this.overview.getView().style.display = 'block';
        }else{
            var overview = this.overview = new twaver.gis.gadget.Overview("overview_id",this.map);
            if(width == null || width == undefined || width < 0){
                width = 150;
            }
            if(height == null || height == undefined || height <0){
                height = 150;
            }
            overview.setSize({width:width,height:height});
            overview.map.addLayer("BINGMAP",GISConsts.EXECUTOR_TYPE_BINGMAP);
            overview.setBorder("1px solid red");
            if(right){
                right = right-width+5;
            }else{
                right = width+5;
            }
            if(bottom){
                bottom = bottom - height+5;
            }else{
                bottom = height+5;
            }
            this.map.installGadget(overview,{right:right,bottom:bottom});
        }
    },

    hideOverView : function(){
        if(this.overview && this.overview.getView()){
            this.overview.getView().style.display = 'none';
        }
    },

    registerNormalImage : function (url, name) {
        var self = this;
        var image = new Image();
        image.src = url;
        image.onload = function () {
            twaver.Util.registerImage(name, image, image.width/2, image.height/2);
            image.onload = null;
            self.network.invalidateElementUIs();
        };
    },

    setPosition : function(node,x,y){
        if(!node) return;
        if(this.container.contains(this.mapView)){
            if(window.BMap){
                var point = new BMap.Point(y, x);
                node.setClient("coordinate",point);
                var location = this.map.pointToPixel(point)
                node.setCenterLocation(location.x,location.y);
            }else{
                var geo = new twaver.gis.geometry.GeoCoordinate(parseInt(x)||0,parseInt(y)||0);
                node.setClient(GISSettings.GEOCOORDINATE, geo);
            }
            this.setDefaultImage(node); // test
        }else{
            node.setLocation(parseInt(x)||0,parseInt(y)||0);
        }
    },

    setDefaultImage : function(node,index){
        if(!node) return;
        if(index == 1){
            node.setImage('b1');
        }else if(index == 2){
            node.setImage('b2');
        }else if (index == 3){
            node.setImage('b3');
        }else{
            var i = parseInt(Math.random()*3+1);
            node.setImage('b'+i);
        }
    },

    /**
     * 2D的规则和3D的是一样的
     * @param node
     * @returns {*}
     */
    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return this.sceneManager.getNodeData(node);
    },

    handleDoubleClick : function (element) {
        var node = element.element;
        var i = 0,eventHandler;
        for(; i < this._eventHandlers.length;i ++){
            eventHandler = this._eventHandlers[i];
            var data = this.getDataByNode(node);
            if(eventHandler.shouldHandleDoubleClickElement(node,this.network,data,element)){
                eventHandler.handleDoubleClickElement(node,this.network,data,element);
                this.focusData = data;
                return;
            }
        }
    },

    handleDoubleClickBackground : function(){
        if(this.focusData && this.focusData.getParentId()){
           var parentNode = this.sceneManager.dataNodeMap[this.focusData.getParentId()];
           if(parentNode){
              this.sceneManager.viewManager3d.setFocusNode(parentNode);
           }
        }
        var i = 0,eventHandler;
        for(; i < this._eventHandlers.length;i ++){
            eventHandler = this._eventHandlers[i];
            if(eventHandler.shouldHandleDoubleClickBackground(this.network)){
                eventHandler.handleDoubleClickBackground(this.network);
                return;
            }
        }
    },

    addEventHandler : function(eventHandler,index){
        if(eventHandler instanceof it.EventHandler){
            if(index === undefined){
                return this._eventHandlers.push(eventHandler);
            }else{
                return this._eventHandlers.splice(index,0,eventHandler);
            }
        }
    },

    removeEventHandler : function(eventHandler){
        var index = this._eventHandlers.indexOf(eventHandler);
        if(index !== -1){
            this._eventHandlers.splice(index,1);
        }
    },

    createColumn: function (table, name, propetyName, propertyType, valueType, width) {
        var column = new twaver.Column(name);
        column.setName(name);
        column.setPropertyName(propetyName);
        column.setPropertyType(propertyType); //accessor,client,Styles
        if (valueType) {
            column.setValueType(valueType);
        }
        if(width){
            column.setWidth(width);
        }else{
            column.setClient('pack',true);
        }
        column.renderHeader = function (div) {
            var span = document.createElement('span');
            span.style.whiteSpace = 'nowrap';
            span.style.verticalAlign = 'middle';
            span.style.padding = '1px 2px 1px 2px';
            span.innerHTML = column.getName() ? column.getName() : column.getPropertyName();
            span.setAttribute('title', span.innerHTML);
            span.style.font = 'bold 12px Helvetica';
//            div.style.backgroundColor = '#ffab00';// 'rgba(255,0,0,1)';
            div.style.textAlign = 'center';
            div.appendChild(span);
        };
        table.getColumnBox().add(column);
        return column;
    },

    addTableAndTree : function(){
        var view = this.network.getView();
        var tablePane = new twaver.controls.TablePane(this.table);
        var tableHeader = tablePane.getTableHeader().getView();
        tableHeader.style.backgroundColor = 'rgba(255,255,255,0.1)';
        var tableDom = tablePane.getView();
        tableDom.style.position = 'absolute';
        tableDom.style.bottom = '30px';
        tableDom.style.left = '400px';
        tableDom.style.width = "500px";
        tableDom.style.height = "120px";
        view.appendChild(tableDom);

        var treeView = this.tree.getView();
        treeView.style.position = 'absolute';
        treeView.style.top = '30px';
        treeView.style.left = '30px';
        treeView.style.width = "160px";
        treeView.style.height = "250px";
        view.appendChild(treeView);

        this.tree.getToggleImage = function (data) {
            if (data.getChildrenSize()>0) {
                return this.isExpanded(data) ?  '../images/collapse_icon.png':'../images/expand_icon.png';
            }
            return null;
        };

        this.tree.getIcon = function (data) { return null; };

    },

    /**
     * table的样式应该是根据scene来的，不同scene有不同的table
     * @param scene
     */
    initTable : function (scene) {
        this.table.setEditable(true);
        this.createColumn(this.table,'编号', 'toolTip', 'accessor', 'string').setWidth(80);
        var column = this.createColumn(this.table, '端口接入', 'toId', 'client', 'string', true);
        column.setWidth(150);
        this.createColumn(this.table, '当前流量', 'flow', 'client', 'string', true).setWidth(120);
        var timeColumn = this.createColumn(this.table, '启用日期', 'raisedTime', 'client','Date');
        timeColumn.setWidth(150);
        timeColumn.setHorizontalAlign('center');
        timeColumn.renderCell = function (params) {
            var span = document.createElement('span');
            span.innerHTML = it.Util.formatDate(params.value, 'yyyy-MM-dd hh:mm:ss');
            span.style.whiteSpace = 'nowrap';
            params.div.appendChild(span);
        }
    },

    refreshTable : function(){
        var view = this.network.getView();
        var tablePane = new twaver.controls.TablePane(this.table);
        var tableHeader = tablePane.getTableHeader().getView();
//        tableHeader.style.backgroundColor = 'rgba(255,255,255,0.1)';
        var tableDom = tablePane.getView();
        tableDom.style.position = 'absolute';
        tableDom.style.bottom = '30px';
        tableDom.style.left = '400px';
        tableDom.style.width = "500px";
        tableDom.style.height = "120px";
        view.appendChild(tableDom);
    },

    showTable : function(scene){
        this.table.getColumnBox().clear();
//        if(this.sceneManager._currentScene.getTwod()){
            this.table.getView().style.display = 'block';
            this.table.setVisibleFunction(function(node){
                if(node.getName()){
                    return false;
                }
                if(!node.getName() && !node.getToolTip()){
                    return false;
                }
                if(node.getClient('group_id')){
                    return false;
                }
                return true;
            });
            this.initTable(scene);
            this.refreshTable();
//        }else{
//            this.table.getView().style.display = 'none';
//        }
    },

    showTree : function(scene){
//        if(this.sceneManager._currentScene.getTwod()){
            this.tree.getView().style.display = 'block';
            this.tree.setLineType('dotted');//线条类型 solid
            this.tree.setLineColor('#000000');//线条颜色 #ffab00
            this.tree.setLineAlpha(1);//线条透明度
            this.tree.setLineThickness(0.5);//线条厚度
            this.tree.setLineDash([1,1]);
            this.tree.setVisibleFunction(function(node){
                if(!node.getName() && !node.getToolTip()){
                    return false;
                }
                return true;
            });
            this.tree.getLabel = function(data){
                return data.getToolTip() || data.getName();
            };
            this.tree.expandAll();
//        }else{
//            this.tree.getView().style.display = 'none';
//        }
    },

});

it.ViewManager2D =$ViewManager2D;


// 场景加载的管理，把dataManager里面的数据加载成为3D对象呈现在viewManager里面的Network里面。
// 用户可以重载这个类，实现自己的逻辑;
// 默认是基于Scene.js数据的实现;

it.SceneManager = function (dataManager) {
    $Util.checkNotNull(dataManager, "dataManager");
    $EventHandler.call(this);
    this.dataManager = dataManager;
    this.initViewManager();
    this.network3d = this.viewManager3d.network;
    this.network2d = this.viewManager2d && this.viewManager2d.network;
    this.prefabMap = {}; // 预制管理，可以提供加载速度
    this.dataNodeMap = {};
    this.dataNode2DMap = {}; // 不放到dataNodeMap中，2D的单独分开，其实也可以合并，但是得加个标记，并且程序内有些地方的改进
    this.linkMap = {};
    this.categoryNodeMap = {};
    this.assetTypeNodeMap = {};
    this.locationManager = new it.LocationManager(this); // TODO
    // 用于监听进入场景等的监听。
    this._sceneManagerChangeDispatcher = new mono.EventDispatcher();
    this._sceneChangeDispather = new mono.EventDispatcher();
    this._sceneVirtualChangeDispather = new mono.EventDispatcher();//场景，记得是当前场景虚化派发，注意效率，由于是批量处理，最好是一批量弄好后派发一个
    this._sceneVisibleChangeDispather = new mono.EventDispatcher();
    this._scenes = [];
    this._sceneMap = []; 
    this._sceneNodeMap = {}; //用来存储当前场景的所有对象
    this._sceneNodes = [];
    this.cameraManager = new $CameraManager(this);
    this.viewManager3d.initDefault();
    this._linkTemplateMap = {};
    var AlarmManagerClass = this.getAlarmManagerClass();
    this._alarmManager = new AlarmManagerClass(this.dataManager, this);
    this.doubleClickBackgroundGotoUpLevelScene = false;
    this.linkControlsFunction = function(link,fromNode,toNode){
        var bb1 = fromNode.getBoundingBox(),bb2 = toNode.getBoundingBox();
        var maxZ = 20, maxY = Math.max(bb1.max.y,bb2.max.y) ;
        var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ),pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ);
        var controls = [];
        controls.push(pos1);
        controls.push(pos1.clone().add(new mono.Vec3(0,maxY,0)));
        controls.push(pos2.clone().add(new mono.Vec3(0,maxY,0)));
        controls.push(pos2);
        return controls;
    };
    this.gcsManager = new it.GCSManager({sceneManager:this});
    this.postManager = new $PortManager(this);
    this.beforeLoadSceneFunction = null;
    this.afterLoadSceneFunction = null;
    this.isBindingBuildingAndFloor = true; //是否将floor绑定到building上，默认是绑定上去
    this.sceneChangeWithOutAnimate = false;
    this.resetCameraWhenSceneChange = true; 
    
    this.lightManager = new $LightManager(this);
    // this.cameraManager = new $CameraManager(this);
    this.adapterManager = new $PropertyChangeAdaperManager(this);
    this.invisibleFilter = new it.VisibleManager(this);
    this.viewManager3d.addVisibleFilter(this.invisibleFilter);
    this.sceneViewMap = {};
    this._focusNode = null;
    this.isClearCache = false;

    var self = this;
    dataManager.addDataManagerChangeListener(function(event){
       if(self._loaded){
          var kind = event.kind;
          if(kind === 'add'){
             self.handleDataAdd(event);
          }else if(kind === 'remove'){
             self.handleDataRemove(event);
          }
       }
    });

    dataManager.addDataPropertyChangeListener(function(event){
        if(self._loaded){
           self.handleDataPropertyChange(event);
        }
    });

    this.removeAndAddAllChildrenWhenSetFocusFilter = null;

    this.addSceneChangeListener(function(eve){
        // self.setSceneNetworkAndLight(eve.data);
        self.setDefaultInteractionValue(eve.data);
    });

};
it.SceneManager.CLIENT_IT_DATA = 'it_data';
it.SceneManager.CLIENT_IT_DATA_ID = 'it_data_id';
//表示的是该node是扩展的，比如空间可视化时，会动态创建彩色的机柜，但这些机柜的id和data都是和真的一样，但是虚化和隐藏不一定真的机柜的影响，
//若想单独管理这些动态机柜的虚化和隐藏，可以给这些临时的node加上CLIENT_EXT
it.SceneManager.CLIENT_EXT_VITUAL = 'it_extend_virtual_node';
it.SceneManager.CLIENT_EXT_VISIBLE = 'it_extend_visible_node';

it.SceneManager.getNodeData =function(node){
    return node.getClient(it.SceneManager.CLIENT_IT_DATA);
},

it.SceneManager.getNodeDataId = function(node){
    if(!node){
        return null;
    }
    return node.getClient(it.SceneManager.CLIENT_IT_DATA_ID);
},

mono.extend(it.SceneManager,$EventHandler,{

	  getSceneView : function(sceneCategory){
          // if(show2D){
              //场景View，可能会同时包括3D和2D的network，目前只考虑3D
          var mainView ;
          if(!document.getElementById("mainView")){
              mainView = this.mainView = document.createElement('div');
              mainView.id = 'mainView';
          }else{
              mainView = this.mainView = document.getElementById("mainView");
              // mainView.appendChild(this.network3d.getRootView());
          }

          if (sceneCategory 
              && this.sceneViewMap[sceneCategory] 
              && this.sceneViewMap[sceneCategory].getContainer()) {
               mainView.appendChild(this.sceneViewMap[sceneCategory].getContainer());
               this.network3d.getRootView().style.display = 'none';
          }

          // var earthSceneView = this.sceneViewMap['earth'];
          // if (earthSceneView && earthSceneView.getContainer()) {
          //     mainView.appendChild(earthSceneView.getContainer());
          // }
          mainView.appendChild(this.network3d.getRootView());
          // this.network3d.getRootView().style.display = 'none';
          if (this.viewManager2d) {
             mainView.appendChild(this.viewManager2d.getContainer());
          };
          return mainView;
          // }else{
          //     return this.network3d.getRootView();
          // }
	  },

    /**
     * 2D的network需要先加到body中，然后在adjustBounds，否则无效并且显示不出来
     */
    adjust2DBounds : function(width,height,left,top){
        this.viewManager2d&&this.viewManager2d.adjustViewBounds(width,height,left,top);
    },

    adjust3DBounds : function(w, h, left, top) {
        if(!w){
            w = document.documentElement.clientWidth;
        }
        if(!h){
            h = document.documentElement.clientHeight;
        }
        left = left || 0;
        top = top || 0;
        this.network3d.adjustBounds(w - left, h - top);
        var self = this;
        if (window.addEventListener) {
            window.addEventListener('resize', function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            }, true);
        } else if (window.attachEvent) {
            window.attachEvent('onresize', function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            });
        } else {
            window.onresize = function () {
                self.network3d.adjustBounds(w - left, h - top, top, left);
            };
        }
    },

    /**
     * 当真-假对象切换时，是不是将孩子添加至Box中或重box中移除掉
     * @param node
     */
    removeAndAddAllChildrenWhenSetFocus : function(node){
        if(this.removeAndAddAllChildrenWhenSetFocusFilter){
            return this.removeAndAddAllChildrenWhenSetFocusFilter(node);
        }
        if(!node) return false;
        var data = this.getNodeData(node);
        if(data){
            var category = this.dataManager.getCategoryForData(data);
            if(category && category.getId() && category.getId().toLowerCase().indexOf('rack') >= 0 ){
                return true;
            }
        }
        return false;
    },

    isChild : function(parentNode,childNode){
        if(!parentNode || !childNode){
            return false;
        }
        var pdata = this.getNodeData(parentNode);
        if(!pdata) {
            return false;
        }
        var cdata = this.getNodeData(childNode);
        if(!cdata || !(cdata instanceof $Data)){
            return false;
        }
        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
            return true;
        }
        return false;
    },

    adjustBounds : function(width,height,left,top){
        this.adjust2DBounds(width,height,left,top);
        this.adjust3DBounds(width,height,left,top);
    },

    getDataBox : function(){
      var sceneView = this.getCurrentSceneView();
      if (sceneView && sceneView.getNetwork3D()) {
        return sceneView.getNetwork3D().getDataBox();
      }
      return this.network3d.getDataBox();
    },

    getDataBox2d : function(){
        return this.network2d.getElementBox();
    },

    setDefaultInteractionSpeed : function(rotateSpeed,panSpeed,zoomSpeed){
        var defaultInteraction = this.network3d.getDefaultInteraction();
        if(!defaultInteraction){
          return;
        }
        defaultInteraction.setRotateSpeed(rotateSpeed);
        defaultInteraction.setPanSpeed(panSpeed);
        defaultInteraction.setZoomSpeed(zoomSpeed);
    },

    shouldHandleDoubleClickBackground : function(network){
        
        if(!this.doubleClickBackgroundGotoUpLevelScene){    // 拓展给外面用的属性，用于当符合某情况时是否场景时过滤
          return false;
        }
        if(!this.dataManager.getRootScene()){
          return false;
        }
        if(this._currentScene === this.dataManager.getRootScene()){
          return false;
        }
        if(network instanceof mono.Network3D){
            var focusNode = this.viewManager3d.getFocusNode();
            //有可能focusNode不在当前场景中，如显示连线时将其他楼层的设备也给加载出来了，然后在lookAt其他楼层的那个设备，此时回到上一级就有问题？？？
            if(focusNode){
                focusNode = this.getMainNode(focusNode);
                if(this._currentRootNode !== focusNode){
                    return false;
                }
            }
        }
        return true;
    },
 
    handleDoubleClickBackground : function(network){
        this.gotoUpLevelScene();
    },

    shouldHandleDoubleClickElement : function(element,network,data,clickedObj){
       var dm = this.dataManager;
       if(!dm.getRootScene()){
         return false;
       }
        if(element.doubliClick){
            return true;
        }
       if(!data){
         return false;
       }
       var scene = null;
       var lastSceneAndRootData = this.getSceneAndRootByData(data);
       if (lastSceneAndRootData) {
          scene = lastSceneAndRootData.scene;
       }
       if(scene && this._currentScene != scene){
         return true;
       }
       return false;
    },

    handleDoubleClickElement : function(element,network,data,clickedObj,callback){
        var dm = this.dataManager;
        var lastSceneAndRootData = this.getSceneAndRootByData(data);
        var scene = lastSceneAndRootData.scene;
        var rootData = lastSceneAndRootData.rootData||data;
        var dataNode = this.getNodeByDataOrId(rootData);
        var doubliClick = element.doubliClick || (dataNode?dataNode.doubliClick:null);
        if(doubliClick){
            return doubliClick(element,network,data,clickedObj,callback);
        }
        if(this._currentScene == scene){
            callback && callback();
            return;
        }
        this.toScene(scene,rootData,callback);
        if (rootData) {
            this.viewManager3d.setFocusNode(this.dataNodeMap[rootData.getId()]);
        }
    }, 

    /**
     * 
     * “彻底“的清除掉相关的缓存对象，释放内存
     * 
     */
    clearCache : function(scene,rootData){
        scene = scene || this._currentScene;
        rootData = rootData || this._currentRootData;
        // 清除dataNodeMap中的引用
        if (scene && rootData) {
          for (var id in this.dataNodeMap) {
             var dataNode = this.dataNodeMap[id];
             var nodeData = this.getNodeData(dataNode);
             var dataType = this.dataManager.getDataTypeForData(nodeData);
             if (dataType && dataType.getModel()) {
                var model = dataType.getModel().replace('twaver.idc.','').replace('twaver.meeting.',''); //这种方式还正好避开了dc中的模型，dc就不是不用删除的 2017-10-13
                if (make.Default._objObject[model]) {
                  delete make.Default._objObject[model];
                }
                if (make.Utils3D._objObject[model]) {
                   delete make.Utils3D._objObject[model];
                }
             }
             // var sceneAndRootData = this.getSceneAndRootByData(this.getNodeData(dataNode));
             // if (sceneAndRootData 
             //    && sceneAndRootData.scene == scene 
             //    && sceneAndRootData.rootData == rootData) {
             if (scene 
                 && scene.getCategoryId() != 'earth' // 对于地球，园区也要弄掉
                 && this.isSceneInstance(scene,rootData,nodeData)) {
                  continue;
             }else{
                delete this.dataNodeMap[id];
             }
          }
        }else{
           this.dataNodeMap = {};
        }
        for(var name in make.Default._objMap){
           make.Default._objMap[name] = [];
        }//加载obj的队列，总是不会释放

        this.prefabMap = {};
        //清除当前场景的nodeMap
        this._sceneNodes = [];
        this._sceneNodeMap = {};
        //清除categoryMap中的引用
        // for(var id in this.categoryNodeMap){
        //    delete this.categoryNodeMap[id];
        // }
        this.categoryNodeMap = {};
        //清除assetTypeNodeMap中的引用
        // for(var id in this.assetTypeNodeMap){
        //   delete this.assetTypeNodeMap[id;]
        // }
        this.assetTypeNodeMap = {};
        //清除告警的billboard
        var datas = this.dataManager._datas
        for (var i = 0; i < datas.length; i++) {
           var boards = datas[i].boards; 
           if (boards && (boards instanceof Array)){
              for(var k = 0 ; k < boards.length ; k++){
                  var board = boards[k];
                  if (board) {
                    board.setParent(null);
                  }
              }
              delete datas[i].boards;
           } 
        }
        //清除告警的Map
        this._alarmManager._alarmBillboardMap = {};
        this._alarmManager._alarmNodeMap = {};
    },

    clear : function(scene,root){
        this.beforeClearFunction && this.beforeClearFunction();
        var nodes = new mono.List();
        for (var id in this.dataNodeMap) {
            var node = this.dataNodeMap[id];
            if (node) {
                node.setParent(null);
                nodes.add(node);
            }
        }
        this.viewManager3d.clear();
        this.getDataBox2d().clear();
        this.clearSceneNodeMap();
        this._sceneManagerChangeDispatcher.fire({
            kind:'clear',
            datas:nodes
        });
        if (this.isClearCache) {
           this.clearCache(scene,root);
        }
    },

    getCurrentScene : function(){
      return this._currentScene;
    },

    getParentScene : function(data){
        if(!data) return null;
        var parentData = this.dataManager.getParent(data);
        if (!parentData) {
            return null;
        }
        var category = this.dataManager.getCategoryForData(parentData);
        if (!category) {
            return this.getParentScene(parentData,this);
        }
        var parentScene = this.dataManager.getSceneByCategory(category);
        if (!parentScene) {
            return this.getParentScene(parentData,this);
        }else{
            return {scene:parentScene,data:parentData};
        }
    },

    gotoUpLevelScene : function(){
        var scene = this._currentScene;
        if(!scene) return false;
        if(scene.getTwod()){
            this.clear();//先去除3D对象的父子关系
            this.gotoUpLevelSceneFor2D();
        }else{
            this.gotoUpLevelSceneFor3D();
        }
    },

    /**
     * 到某个具体的场景中，对clear和loadOneScene进行了进一步的封装
     * 以前的设计思路是：到了一个新的scene，那之前的场景中的东西先全部clear，然后再装载新场景中的东西；
     * 现在有可能并不需要clear
     * @param scene
     * @param data
     */
    toScene : function(scene,data,callback,clientMap){
        if(!scene){
            return;
        }
        var self = this;
        var action = function(){
           self.clear(scene,data);
           self._loadOneScene(scene,data,callback,clientMap);
        }
        this.beforeLoadSceneAnimate(scene,data,this._currentScene,this._currentRootData,action,this);
    },
    
    /**
     * 切换场景
     */
    gotoScene : function(scene, data, callback,clientMap){
        if(!scene) {
            callback && callback('scene is null');
            return;
        }
        if(scene == this._currentScene){ //还得进一步判断，如果从一楼跳到二楼呢，场景一样
            var rootData = this.getNodeData(this._currentRootNode);
            if(data && rootData && data == rootData){
                callback && callback('scene is current scene, no change');
                return ;
            }
        }
        this.toScene(scene,data, callback,clientMap);
        if (data && !scene.getTwod()) {
            // this.viewManager3d.setFocusNode(this.dataNodeMap[data.getId()]);
            this.setFocusNode(this.dataNodeMap[data.getId()]); // 2017-08-11
        }
    },

    /**
     * 对于2D(比如2D面板)回到上一个层时，应该是回到显示机柜的那个scene（机柜本身没有设置scene），并且lookat到机柜
     */
    gotoUpLevelSceneFor2D : function(){
        var scene = this._currentScene;
        if (!scene) {
            return false;
        }
        var rootNode = this._currentRootNode;
        if (!rootNode) {
            return false;
        }
//        var lookAt = rootNode; // 转到2D中后，focus还是停留在3D场景的最后的那个focus，如果是一下子跨越了多个(如:从dc直接跳到了板卡，那板卡upto时，就到了dc——不合理)
        var data = this.getNodeData(rootNode);
        var sceneObj = this.getParentScene(data);
        if(sceneObj && sceneObj.scene && sceneObj.data){
            var self = this;
            var callback = function(){
//                if(lookAt){
                    var lookAtData = self.getNodeData(rootNode);
                    if(lookAtData && lookAtData.getParentId()){
                        var parentNode = self.dataNodeMap[lookAtData.getParentId()];
                        var box3D = self.network3d.getDataBox();
//                的再改改，因为getFocus很可能是dc，而当前的场景是板卡的上一级。
                        //不过将上面的lookAt改成了RootNode,应该是可以了
                        if(!parentNode //可是从面板到设备时，重新加载了对象，此时的机柜都是假的，因此设备很可能就不在box中了
                            || !box3D.getDataById(parentNode.getId())){
                            self.loadLazyData(lookAtData.getParentId());
                            parentNode = self.dataNodeMap[lookAtData.getParentId()];
                        }
                        if(parentNode){
                            self.viewManager3d.lookAt(parentNode);
                        }
                    }
//                }
            };
            this.toScene(sceneObj.scene, sceneObj.data);
            callback();
        }
        this.afterGotoUpLevelScene(data,scene,sceneObj.data,sceneObj.scene);
    },

    /**
     * 跳到上一层后所要执行的动作，便于扩展
     * 
     */
    afterGotoUpLevelScene : function(oldData,oldScene,data,scene){

    },

    /**
     * 根据当前的data获取其上一级的data，默认的是parentData。但是有可能有特殊情况，所以这里抽出来，便于扩展
     */
    getUpLevelDataByData : function(data){
       if (!data) {
          return null;
       }
       return this.dataManager.getParent(data);
    },

    gotoUpLevelSceneFor3D : function(){
        var scene = this._currentScene;
        if (!scene) {
            return false;
        }
        var rootNode = this._currentRootNode;
        var rootData = this._currentRootData;
        if (!rootNode && !rootData) {
            return false;
        } 

        var data = this.getNodeData(rootNode);
        if (!data) {
          data = rootData;
        }
        // var parentData = this.dataManager.getParent(data);
        var parentData = this.getUpLevelDataByData(data);
        if (!parentData) {
            return false;
        }
        var parentScene = this.getSceneAndRootByData(parentData);
        if(!parentScene){
            return false;
        }
        this.gotoScene(parentScene.scene, parentScene.rootData); //都走这个即可
        this.afterGotoUpLevelScene(data,scene,parentData,parentScene);
        return true;
    },

    gotoData : function(dataOrId){
      var dm = this.dataManager;
      var data = dataOrId;
      if(!(typeof dataOrId === $Data)){
         data = dm.getDataById(dataOrId);
      }
      if(!data){
        return false;
      }
      var category = dm.getCategoryForData(data);
      if(!category){
        return false;
      }

      var scene = this.dataManager.getSceneByCategory(category);
      if(!scene){
        return false;
      }
        this.toScene(scene,data);
        var dataNode = null;
        if (data) {
            dataNode = this.dataNodeMap[data.getId()];
        }
        // this.viewManager3d.setFocusNode(dataNode);
        this.setFocusNode(dataNode); //2017-08-11
        return true;
    },

    initViewManager : function(){
        this.viewManager3d = new it.ViewManager(this);
        this.viewManager3d.addEventHandler(this);
        if (it.ViewManager2D) {
           this.viewManager2d = new it.ViewManager2D(this);
           this.viewManager2d.addEventHandler(this);
        }
    },

    removeNodeChildren : function(dataOrNodeOrId,filterFunction){
       var node = dataOrNodeOrId;
       if(dataOrNodeOrId instanceof $Data || typeof dataOrNodeOrId === 'string'){
         node = this.getNodeByDataOrId(dataOrNodeOrId);
       }
       var box = this.getDataBox();
       var children = node.getChildren().toList();

       children.forEach(function(child){
          if(!filterFunction || filterFunction(child)){
              child.setParent(null);
              box.removeByDescendant(child);
          }
       });
    },

    setNodeData : function(data,node,root){
        if(!node) return ;
        // add 2017-11-06 表示业务数据已经设置了，不要再设置了，有可能node的parent没有置空，这里再设置的话导致
        if (node.getClient(it.SceneManager.CLIENT_IT_DATA) 
            && node.getClient(it.SceneManager.CLIENT_IT_DATA_ID)) {
              return ;
        }
       node.setClient(it.SceneManager.CLIENT_IT_DATA,data);
       node.setClient(it.SceneManager.CLIENT_IT_DATA_ID,data.getId());
        if(!root){
            root = node;
            node.setClient('modelParent',null);
        }else{
            node.setClient('modelParent',root);
        }
        var complexNode = node.getClient('complexNode');
        if(complexNode && complexNode != 'unload'){
          this.setNodeData(data,complexNode,root);
        }
        var self = this;
        if(node.getChildren() && node.getChildren().size() > 0 ){// 注意，有可能孩子是其他的类型，所以的注意先后顺序
            node.getChildren().forEach(function(child){
                self.setNodeData(data,child,root);
            });
        }
    },

    getMainNode : function(node){
        if(!node) return;
        if(node.getClient(it.SceneManager.CLIENT_IT_DATA) == null){
            node = node.getParent();
        }
        return this.getNodeByDataOrId(this.getNodeData(node));
    },

    getParentNode : function(data){
       var parentId = data.getParentId();
       if(parentId){
        return this.dataNodeMap[parentId];
       }
       return null;
    },

    getChildrenNodes : function(nodeOrData,dataTypeId){
      var data = nodeOrData;
      if(nodeOrData instanceof mono.Node){
        data = this.getNodeData(node);
      }
      var children,i = 0,nodes = [];
      if(data){
        children = this.dataManager.getChildren(data,dataTypeId);
        for(i = 0;i < children.length;i ++){
            nodes.push(this.getNodeByDataOrId(children[i]));
        }
      }

      return nodes;
    },

    getNodeData : function(node){
        if(!node || !node.getClient) return null;
       return node.getClient('it_data');
    },

    getNodeByDataOrId : function(dataOrId){
        if(!dataOrId) return null;
        var id = dataOrId.getId ? dataOrId.getId() : dataOrId;
        return this.dataNodeMap[id];
    },

    getNodeForDataOrId : function(data){
        if(!data) return null;
        var id = data.getId ? data.getId() : data;
        return this.dataNodeMap[id];
    },

    loadModel: function(model,params,prefabAble,prefabId,callback){
        var params = JSON.parse(JSON.stringify(params));
        var node = null;
        if(prefabAble && prefabId){
           node = this.prefabMap[prefabId];
           if(node && node.clonePrefab){
              node = node.clonePrefab();
           }
        }
        if(!node){
            params = params || {};
            params.type = params.type || model;
            var id = model || params.type;
            if(!id){
                return null;
            }
            var obj = {};
            if(params instanceof Array){
                obj.data = params;
                obj.id = id;
            //支持加载多个模型
            }else if(id === 'twaver.loader'){
                obj.id = id;
                obj.data = params;
            }else{
                obj = params || {};
                obj.id = id;
            }
            var prefaNode = make.Default.load(obj,callback);
            if(!prefaNode){
                return null;
            }
            if(prefabAble && prefabId && id != 'twaver.loader'){
               this.prefabMap[prefabId] = prefaNode;
               node = prefaNode.clonePrefab();
            }else{
              node = prefaNode;
            }
            // if (prefaNode && prefaNode.clonePrefab) {
            //   node = prefaNode.clonePrefab();
            // }else {
            //   node = prefaNode;
            // }
        }
        return node;
    },

    loadDataTypeTemplateModels : function(dataType,parentData,onLoadFinish) {
        var templateDatas = dataType.getTemplateDatas();
        if(templateDatas == null || templateDatas.length == 0){
            return;
        }
        var self = this;
        templateDatas.forEach(function(data){
            data = self._translateTemplateData(data,parentData)
            var parentNode = self.dataNode2DMap[parentData.getId()];
            var node = self.loadDataModel2D(data,onLoadFinish)
            if (node) {
               node.setMovable(false);
               node.setHost(parentNode);
               node.setParent(parentNode);
               node.setName("");
            }
        });
    },

    _loadDataModeCallback : function(data,node,onLoadFinish){
          var dm = this.dataManager,
          box = this.network3d.getDataBox();
          var id = data.getId();
          var assetType = dm.getDataTypeForData(data);
          var category = dm.getCategoryForData(data);
           box.addByDescendant(node);
           if (!this.dataNodeMap[id] && this.afterFirstLoadDataModelFunction) {
              this.afterFirstLoadDataModelFunction(data, node); //第一次创建好dataNode的时候调用
           }
           this.dataNodeMap[id] = node;
           var temp = this.assetTypeNodeMap[assetType.getId()];
           if(!temp){
              temp = {};
              this.assetTypeNodeMap[assetType.getId()] = temp;
           }
           temp[id] = node;
           if(category){
              temp = this.categoryNodeMap[category.getId()];
              if(!temp){
                temp = {};
                this.categoryNodeMap[category.getId()] = temp;
              }
              temp[id] = node;
           }
           this.setNodeData(data,node);
           this.addToSceneNodeMap(data,node);
           if (onLoadFinish) {
              onLoadFinish(node);
           }
           this._sceneManagerChangeDispatcher.fire({
               kind:'add',
               data:node
           });
    },

    /**
     * 创建data的3D对象
     * @includeInvisible 是否加载不可见的对象(目前用category中的visible来标识)
     *
     */
    loadDataModel : function(data,includeInvisible,onLoadFinish){
       var dm = this.dataManager;
       var dataType = dm.getDataTypeForData(data);
       var category = dm.getCategoryForData(data);
       if (category && !category.isVisible()) { 
            this.invisibleFilter.setVisible(data,false); // 虽然load了,但是load后依然是隐藏着的
            if (!includeInvisible) {
               return;
            }
       }
       var self = this,
           box = this.network3d.getDataBox(),
           id = data.getId();
       var node = this.dataNodeMap[id];
       var parameters = dataType.getModelParameters();
       var params = parameters;
       var prefabAble = dataType.isPrefabAble(),simplePrefabAble = dataType.isSimplePrefabAble();
       var simpleModel = dataType.getSimpleModel();
       var simpleModelParameters = dataType.getSimpleModelParameters();
       if(node){
          this._loadDataModeCallback(data,node,onLoadFinish);
       }else{
          var simpleNode;
          if(simpleModel){
              simpleNode = this.loadModel(simpleModel,simpleModelParameters,simplePrefabAble,dataType.getId() + '_simple');
          }
          if(simpleNode){
              // var boundingBox = node.getBoundingBoxWithChildren();
              var boundingBox = simpleNode.getBoundingBoxWithChildren && simpleNode.getBoundingBoxWithChildren();
              var size = {x:1,y:1,z:1} ; 
              if(boundingBox){
                size = boundingBox.size();
              }
              var fakeNode = new mono.Cube(size.x,size.y,size.z);
              fakeNode.s({
                'm.visible' : false
              });
              simpleNode.setParent(fakeNode);
              fakeNode.setClient("simpleNode",simpleNode);
              fakeNode.setClient("complexNode","unload");
              // fakeNode.setClient("complexNode",node);
              // callback(fakeNode);
              this._loadDataModeCallback(data,fakeNode,onLoadFinish);
          }else{
              // callback(node); 
              // this._loadDataModeCallback(data,node,onLoadFinish);
              this.loadComplexNode(data,onLoadFinish);
          }
       }
    },

    /**
     * 加载复杂模型，为了初次的加载速度，有可能一开始没有创建创建复杂对象，只是创建了简单对象
     * 存在两种情况：1、没有简单模型(fakeNode就是自己)，在当前场景下的话，就设置relaction和position
     *             2、有简单模型的情况
     * 有可能复杂对象是个obj模型
     */
    loadComplexNode : function(data,callback){
        if (!data) {
            callback&&callback(null);
            return null;
        }
        var dataNode = this.dataNodeMap[data.getId()];
        if (dataNode) {
           var complexNode = dataNode.getClient('complexNode');
           // if (!complexNode || complexNode != 'unload') {
          if (complexNode && complexNode != 'unload') { // 2017-10-31
              callback&&callback(complexNode);
              return complexNode;
           }
        }
        var dm = this.dataManager;
        var self = this;
        var dataType = dm.getDataTypeForData(data);
        var params = dataType.getModelParameters();
        var prefabAble = dataType.isPrefabAble(),simplePrefabAble = dataType.isSimplePrefabAble();
        
        var complexNode = this.loadModel(dataType.getModel(),params,prefabAble,dataType.getId()); // 为了可以支持异步加载，需要提供callback机制
        if(!complexNode) {
            this.loadModel(dataType.getModel(),params,prefabAble,dataType.getId(),function(node){
                if (self.dataNodeMap[data.getId()]) { 
                    return ;
                }
                if(node && node instanceof Array){
                   for(var i = 1 ; i < node.length ; i++){
                      console.log('load a lots of model');
                      node[i].setParent(node[0]); //让其他的是第一个的孩子
                   }
                   node = node[0];
                }
                if (dataNode) {
                   dataNode.setClient('complexNode',node);
                   self.setNodeData(data,node,dataNode);
                   callback&&callback(node);
                }else{
                    if (self.isCurrentSceneInstance(data)) { //那就没法强制创建了
                        self._loadDataModeCallback(data,node,null);
                        self.setRelationShipAndPosition(data); //当有真假对象时，并不需要设置真对象的这些值吧？
                        callback&&callback(node);
                    }else{
                       // 如果没有简单模型，并且不在当前场景就不管了
                       callback&&callback(node); // 2018-01-04 kevin callback还是需要调用
                    }
                }
            });
            return null;
        }else{
           if (complexNode instanceof Array) {
              for(var i =1 ; i< complexNode.length ; i++){
                complexNode[i].setParent(complexNode[0]);
              }
              complexNode = complexNode[0];
           }
           if (dataNode) {
              dataNode.setClient('complexNode',complexNode);
              this.setNodeData(data,complexNode,dataNode);
              callback&&callback(complexNode);
           }else{
              this._loadDataModeCallback(data,complexNode,null);
              this.setRelationShipAndPosition(data); // 解决孩子比父亲先创建的bug
              callback&&callback(complexNode);
           }
           return complexNode;
        }
    },

    /**
     * 根据model或params创建2D的Node，这块还需要扩展，是否也需要提供一个2d的Modellib
     * @param model
     * @param params
     * @returns {twaver.Node}
     */
    loadModel2D : function(model,params,data){
        if(model || mono.Utils.isArray(params)){
            var obj = {};
            if(params instanceof Array){
                params.forEach(function(node){
                    node.scale = 20;
                });
                obj.data = params;
                obj.id = model;
            }else{
                obj = params || {};
                obj.id = model;
            }
            return make.Default.load(obj);
        }else {
             console.log('unknown 2d model params: ' + params);
             return null;
        }
    },

    /**
     * 创建template的实例对象
     * @param data
     * @param parentData
     * @returns {*}
     * @private
     */
    _translateTemplateData : function(data,parentData) {
        var id = data.getId(),
            parentId = parentData.getId(),
            pos = data.getPosition2d()||new mono.Vec2,
            pPos = parentData.getPosition2d()||new mono.Vec2;
        var dataId = id + "@" + parentId;
        var newData = this.dataManager.getDataById(dataId);
        if(!newData){
            newData = data.clone(dataId);
            newData.setHostId(data.getHostId());
            this.dataManager.addData(newData,false);
            var newPos = newData.getPosition2d() || new mono.Vec2;
            //每次新建时才换算成绝对的位置
            // pPos有可能是{x:"0",y:"0",z:"0"}，所以的转换
            newPos.x = parseInt(pPos.x||0) + pos.x;
            newPos.y = parseInt(pPos.y||0) + pos.y;
//            newPos.z = parseInt(pPos.z||0) + pos.z; //没有z
        }
        //让dataType中的data的位置永远是相对的
//        pos.x = pPos.x + pos.x;
//        pos.y = pPos.y + pos.y;
//        pos.z = pPos.z + pos.z;
        newData.setParentId(parentId);
        return newData;
    },

    /**
     * 加载2D dataType的templateDatas，如：板卡中的端口,灯泡等对象
     * @param dataType
     * @param parentData
     * @param onLoadFinish
     */
    loadDataTypeTemplateModel2Ds : function  (dataType,parentData,onLoadFinish) {
        var templateDatas = dataType.getTemplateDatas();
        if(templateDatas == null || templateDatas.length == 0){
            return;
        }
        var self = this;
        var groups = {};
        templateDatas.forEach(function(data){ //可是child有groupID时呢(也就是data的hostId)
            data = self._translateTemplateData(data,parentData);
            var groupId = data.getHostId();
            var parentNode = self.dataNode2DMap[parentData.getId()];
            var node = self.loadDataModel2D(data,onLoadFinish);
            if (!node) {
               return ;
            }
            node.setMovable(false);
            if(groupId){
                self.setTemplatesGroup(node,groupId,parentNode,groups);
            }else{
                if(parentNode){
                    node.setHost(parentNode);
                    node.setParent(parentNode);
                }
            }
            node.setName("");
            var tooltip = data.getId();
            var parentId = parentData.getId();
            if(tooltip.length > (parentId.length+1)){
                tooltip = tooltip.substring(0,(tooltip.length-parentId.length-1));
            }
            node.setToolTip(tooltip);
        });
    },

    setTemplatesGroup : function(node,groupId,parentNode,groups){
        if(!node || !groupId){
            return null;
        }
        if(!groups){
            groups = {};
        }
        //并不是每次都要创建，一般第一次创建，后来再进入该面板(同一个面板实例)时就不需要创建了
        var nodeGroup = node.getParent();
        if(nodeGroup
            && nodeGroup.getClient('group_id')
            && nodeGroup.getClient('group_id') == groupId){
            return ;
        }
        var group = null;
        if(!groups[groupId]){
            var box = this.getDataBox2d();
            group = new twaver.Node();
            if(parentNode){
                var parentData = this.getNodeData(parentNode);
                group.setParent(parentNode);
                group.setClient('parent_data',parentData);
                group.setName('');
                group.setToolTip(groupId);
                group.setVisible(false);
            }
            group.setClient('group_id',groupId);
            groups[groupId] = group;
            box.add(group);
        }else{
            group = groups[groupId];
        }
        node.setHost(parentNode);//但是还是附着在面板上
        node.setParent(group);
    },

    /**
     * 加载2d的模型
     * @param data
     * @param onLoadFinish
     * @returns {*}
     */
    loadDataModel2D : function(data,onLoadFinish){
        if (!this.viewManager2d) {
            console.log('need add ViewManager2D model!');
            return null;
        }
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var box = this.getDataBox2d(),id = data.getId();
        var node = this.dataNode2DMap[id];
        var parameters = dataType.getModel2dParameters();
        if(!node){
            node = this.loadModel2D(dataType.getModel2d(), parameters,data);
            var parentNode = node;
            if(node instanceof Array){
                parentNode = node[0];
                if(parentNode){
                    parentNode.setMovable(false);
                    for(var i = 1 ; i < node.length ; i++){
                        var child = node[i];
                        if(child){
                            child.setMovable(false);
                            this.setNodeData(data,child);
                            parentNode.addChild(child);
                            child.setHost(parentNode);
                        }
                    }
                }
            }
            if(parentNode){
                parentNode.setName(data.getDescription() || id);
                this.setNodeData(data,parentNode);
                this.dataNode2DMap[id] = parentNode;
                var position = data.getPosition2d();
                if(position){
                   this.viewManager2d.setPosition(parentNode, position.x, position.y);
                }
            }
        }
        if(!box.getDataById(node.getId())){//如果板卡之前创建过，那一下子就会将其孩子加进去，所有接下来重新load child时会有重复的问题
            box.addByDescendant(node);
        }
        this.loadDataTypeTemplateModel2Ds(dataType,data,onLoadFinish);
        return node;
    },

    handleDataAdd : function(event){
       var data = event.data;
       if(data instanceof $Data){
          if(this.shouldLoadData(data)){
            this.loadOneData(data);
          }else if(this.shouldLoadData2D(data)){
            this.loadDataModel2D(data); 
          }
       }else if(data instanceof $Link){
          this.loadLink(data);
       }
    },

    /**
     * 这里判断的注意一下，有可能data是延时加载的，如：Equipment,我们只在需要的时候才会去加载创建，目前只在lookAt的时候会将其显示出来
     * @param data
     * @returns {boolean}
     */
    shouldLoadData : function(data,forParent){
        if(!data){
            return false;
        }
        if(forParent){
             var node = this.getNodeByDataOrId(data);
              if(node ){ //如果已经存在节点
                return true;
              }
        }
       
        var dataType = this.dataManager.getDataTypeForData(data);
        if(dataType && dataType.isLazyable()){
            var focusNode = this.viewManager3d.getFocusNode();
            var focusData = this.getNodeData(focusNode);
            if(focusData && (focusData.getId() == data.getId())){
                return true;
            }else{
                return false;
            }
        }else{ //不是延迟加载的话，就判断是不是在当前场景下
//            var currentScene = this.getCurrentScene();
//            if(currentScene == null){
//                return true;
//            }
//            var sceneData = this.getParentScene(data);
//            return sceneData.scene == this.getCurrentScene() && !currentScene.getTwod();
            var parentId = data.getParentId(),
            parent = this.dataManager.getDataById(parentId);
            return this.shouldLoadData(parent,true) && this.isCurrentSceneInstance(data);
        }
    },

    /**
     *
     * @param data
     * @returns {*}
     */
    shouldLoadData2D : function(data){
       var currentScene = this.getCurrentScene();
       if(currentScene == null){
          return false;
       }
       var sceneData = this.getParentScene(data)
       return sceneData.scene == this.getCurrentScene() && currentScene.getTwod();
    },

    handleDataRemove : function(event){
       var data = event.data;
       var dm = this.dataManager;
       var box = this.network3d.getDataBox();
       if(data instanceof $Data){
         var node = this.dataNodeMap[data.getId()];
         box.removeByDescendant(node);
       }else if(data instanceof $Link){
         var link = this.linkMap[data.getId()];
         box.removeByDescendant(link);
       }
    },

    handleDataPropertyChange : function(event){
        var data = event.source;
        var property = event.property;
        if(property === "parentId"){
           var oldParentId = event.oldValue;
           var parentId = data.getId();
           this.setParentRelationShip(data);
           this.translatePosition(data);
        }else if(property === "location" || property === "position"){
           this.translatePosition(data);
        }
    },

    setAllParentRelationShip : function(scene,rootData){
    	  for(var id in this.dataNodeMap){
    		    var node = this.dataNodeMap[id];
    		    var data = this.getNodeData(node);
            // this.setParentRelationShip(data); //不要所有都设置，这样还要常常去切断其他的场景中的父子关系
            /*
            if (scene && rootData) {
                var dataScene = this.getSceneAndRootByData(data);
                if (dataScene.scene == scene && dataScene.rootData == rootData) {
                   this.setParentRelationShip(data);
                }
            }else{*/
               this.setParentRelationShip(data);
            /*}*/
    	  }
    },

    //如果去掉了parent，那lookAt时，去掉虚化的byDecendant就会受到影响，通过data的parentid
    // 如果是地球的话，不来设置其Data的父子关系
    isNeedSetParent: function(data, node) {
        // return true;
        if (data) {
            var parentNode = this.dataNodeMap[data.getParentId()];
            if (this.earthScene && this.earthScene.rootData) {
                var earthNode = this.getNodeByDataOrId(this.earthScene.rootData);
                //如果parent是地球，那在地球场景中设置其parent，其他的场景下则不设置
                if (parentNode && parentNode == earthNode) {
                    if (this._currentScene 
                        && this._currentScene.getCategoryId().indexOf('earth') >= 0) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            //注意：如果lazyLoad其他场景的设备或机柜时，那这些对象的父子关系就没有了，尽然要加进来那一定会设置父子关系的，否则位置都不对 —— 注销于2017-09-28
            // var parentData = this.getNodeData(parentNode);
            // if (!this.isCurrentSceneInstance(parentData)) { // 如果父亲不在当前场景中，就不需要设置该孩子和它的父子关系了
            //     return false;
            // }
        }
        return true;
    },

    /**
     * 设置父子关系
     *
     */
    setParentRelationShip : function(data){
        if(!data) return;
        var node = this.dataNodeMap[data.getId()];
        if(!this.isNeedSetParent(data,node)){
            return ;
        }
        var parentNode = this.dataNodeMap[data.getParentId()];
        if(node && parentNode){
          node.setParent(parentNode);
        }
    },

    /**
     * 设置data的父子关系和位置，以及data的孩子的父子关系和位置
     * 使用场景：延迟加载，有可能孩子先加载出来，父亲的3D对象许久之后
     */
    setRelationShipAndPosition : function(data){
        if (!data) {
            return;
        }
        this.setParentRelationShip(data);
        this.translatePosition(data);
        var children = data.getChildren();
        if (!children || children.size() < 1) {
            return;
        }
        var node = this.dataNodeMap[data.getId()];
        var self = this;
        children.forEach(function(child){
            var childNode = self.dataNodeMap[child.getId()];
            if (childNode && self.isNeedSetParent(child,childNode)) {
                childNode.setParent(node);
            }
            self.translatePosition(child);
        });
    },

    translateAllPosition : function(){
       for(var id in this.dataNodeMap){
          var node = this.dataNodeMap[id];
          var data = this.getNodeData(node);
          this.translatePosition(data);
       }
    },
    
    // 独立处理，方便用户重载这个方法，实现特定的逻辑？
    computePosition : function(data,parentData,node,parentNode){
    	this.locationManager.computePosition(data,parentData,node,parentNode);
    },

    computeRotation : function(data,parentData,node,parentNode){
      this.locationManager.computeRotation(data,parentData,node,parentNode);
    },

    translatePosition : function(data){
  		if(!data){
  			return;
  		}
  		var dm = this.dataManager;
  	  var id = data.getId();
  	  var node = this.dataNodeMap[id];
  	  if(!node){
  	    	return;
  	  }
  		var parentId = data.getParentId();
  		var parentData = dm.getDataById(parentId);
  		var node = this.dataNodeMap[id];
  		var parentNode = this.dataNodeMap[parentId];
      // 注意，如果不是在同一个Scene时，应该不设置其parentNode,如楼层的parent不需要填上，否则building的缩放等会影响到楼层，需要的话从data上获取
      
      this.computePosition(data,parentData,node,parentNode);
      this.computeRotation(data,parentData,node,parentNode);
    },

    /**
     * 场景跳转前，这个方法不同于beforeLoadScene方法。
     * 由于存在“场景切换之前需要处理一系列的动画，然后在动画执行结束后在去切换场景”的情形，而动画都是异步的，
     * 所以提供了这样的方法来处理这样的情形
     * beforeLoadScene其实是在该方法内部执行的(即在callback中)。
     */
    beforeLoadSceneAnimate : function(scene,sceneRootData,oldScene,oldSceneRootData,callback,scope){
        if(callback){
          callback.call(scope);
        }
    },

    /**
     * 加载场景之前所要执行的方法
     * 有返回值，true和false，表示是否执行接下来的场景切换
     * 注意：该方法和beforeLoadSceneAnimate的区别
     */
    beforeLoadScene : function(scene,sceneRootData,clientMap){ // 通过此方法控制场景进入之前的工作
        if(this.beforeLoadSceneFunction){
            this.beforeLoadSceneFunction(scene,sceneRootData,clientMap);
        }
    	return true;
    },

    /**
     * 场景切换完成之后所执行的方法
     */
    afterLoadScene : function(scene,sceneRootData,oldScene,oldRootData,clientMap){ //for user use.
        this._sceneChangeDispather.fire({
            kind:'changeScene',
            data:scene,
            rootData:sceneRootData,
            oldData:oldScene,
            oldRootData:oldRootData,
            clientMap:clientMap
        });
        if(this.afterLoadSceneFunction){
            this.afterLoadSceneFunction(scene,sceneRootData);
        }
    },

    /**
     * 生成data的3D对象，并且设置位置和父子关系
     * @includeInvisible 是否加载不可见的对象
     */
    loadOneData : function(data,includeInvisible,onLoadFinish){
       var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !make.Default.getCreator(dataType._model)) {
          if (!dataType) {
             console.log('modelType is  null!');
          }else{
             console.log('model id ' + dataType._model+' does not exist!');
          }
          onLoadFinish && onLoadFinish();
          return ;
        }
       this.loadDataModel(data,includeInvisible,onLoadFinish);
       this.setParentRelationShip(data);
       this.translatePosition(data);
    },

    getSceneFromData : function(dataOrId){
        var dm = this.dataManager;
        if(dm.getRootScene() == null){
           return null;
        }
        if(!dataOrId){
          return null;
        }
        var dm = this.dataManager;
        var data = dataOrId;
        if(!dataOrId.getId){
         data = dm.getDataById(dataOrId);
        }
        var scene = dm.getSceneByData(data);
        if(scene == null){
          return data&&this.getSceneFromData(data.getParentId());
        }
        scene.__currentRootData = data;
        return scene;
    },

    /**
     * 懒加载
     * 注意：如果懒加载的node的Scene和当前的Scene不同时，该怎么办...
     *
     * @param dataOrId
     * @param callback 这个callback在加载完第一个后执行的
     */
    loadLazyData : function(dataOrId,callback){ //有个问题，如果dataOrId是floor呢，貌似直接返回了，所以下面判断scene时，若要返回则先loadData
        if (!dataOrId) {
            return;
        }
        var self = this;
        var dm = this.dataManager;
        var data = dataOrId;
        if (!dataOrId.getId) {
            data = dm.getDataById(dataOrId);
        }
        var parentId = data.getParentId();
        var parentScene = this.getSceneFromData(parentId);
        var dataScene = this.getSceneFromData(data);
        // 一步一步往上，然后AddByDescendant很容易重复; 这里加了个，不在同一个场景中中一定是没有必要在往上跑的
        if ((parentScene != null || dataScene != null) && parentScene != dataScene) {
           var node = this.getNodeByDataOrId(data); 
           if (!node) {
             this.loadOneData(data,null,callback);
           } else {
              var box = this.getDataBox();
              if (!box.contains(node)) {
                 box.addByDescendant(node,function(childNode){
                     var childData = self.getNodeData(childNode); 
                     if (childData && self.isCurrentSceneInstance(childData)) {
                        return true;
                     }
                     return false;
                 }); // 这个byDescendant有可能add了其他场景的对象
                 this.setParentRelationShip(data);
                 this.translatePosition(data);
              }
            }
            callback&&callback(node);
            return;
        }
        this.loadLazyData(parentId);
        var node = this.getNodeByDataOrId(data); 
        if (!node) {
            this.loadOneData(data,null,callback);
        } else {
            var box = this.getDataBox();
            if (!box.contains(node)) {
                box.addByDescendant(node);
                this.setParentRelationShip(data);
                this.translatePosition(data);
            }
            callback&&callback(node);
        }
    },

    /**
     * 加载孩子或者子孙，可以当孩子或孙子可这个data不在同一个场景下是不是会有点乱呢，loadChild之前已经判断了
     * @param dataOrNode
     * @param onlyNotLazy
     */
    loadLazyChildren : function(dataOrNode,onlyNotLazy){
       onlyNotLazy = onlyNotLazy || false;
       var data =  dataOrNode;
       var root = dataOrNode;
       if(dataOrNode instanceof mono.Data){
          data = this.getNodeData(dataOrNode);
       }else{
          root = this.getNodeByDataOrId(data);
       }
        if(!(data instanceof it.Data)){
            return null;
        }
       var parentScene = this.getSceneFromData(data);
       var children = new mono.List();
        if(data instanceof $Data){
            children = data.getChildren();
        }//this.dataManager.getChildren(data);
       var i =0,length = children.size(),child,childType,node;
       for(;i < length;i ++){
           child = children.get(i);
           node = this.dataNodeMap[child.getId()];
           if (!node) {
               childType = this.dataManager.getDataTypeForData(child);
               if (!(childType.isLazyable() && onlyNotLazy)) {
                   //先判断是否在该场景,再加载孩子 2017-10-25
                   // var dataScene = this.getSceneFromData(child);
                   // if ((parentScene != null || dataScene != null) && parentScene != dataScene) { 
                   //     continue;
                   // }
                   // if (this.isSceneInstance(parentScene,data,child)) {//2017-10-31 不可根据父亲的data来，这样会全部都加载的
                   if (this.isCurrentSceneInstance(child)) { // 只判断是否是当前场景就行
                      this.loadOneData(child);
                      this.loadLazyChildren(child, true);
                   }
                   // this.loadOneData(child);
                   // var dataScene = this.getSceneFromData(child);
                   //先判断是否在该场景,再加载孩子 2017-10-25
                   // if ((parentScene != null || dataScene != null) && parentScene != dataScene) { 
                   //     continue;
                   // }
                   // this.loadLazyChildren(child, true);
               }
           } else {
//             node.setParent(root);
               if (!this.isCurrentSceneInstance(child)) { // 2017-11-09 只判断是否是当前场景就行
                   continue;
               }
               var self = this;
               var childType = this.dataManager.getDataTypeForData(child);
               if (childType && !(childType.isLazyable() && onlyNotLazy)) {
               //这么添加的条件是，当parentData加载了，其孩子也一定加载了，其实不然，当跨楼层的link时，
               // 只加载了那个data和其所在场景的rootData,因此下面还有一个loadLazyChildren
               if (!this.network3d.getDataBox().getDataById(node.getId())) { 
                   this.network3d.getDataBox().addByDescendant(node,function(childNode){ 
                   // 加了一个filter，同一个场景中的才加进去
                   // 可是有存在这样的情况：data有自己的场景，可是data的parent又是一个场景，并且其parent的场景中有加载它data(即：showParentAndChildren)，
                   //   此时若是其parent的场景中加载自己时，则会把它的孩子也加载进来了，因为child和data是同一个。
                   // 但是这样是不是自己都有可能加不进去啊，因为自己有自己的场景
                       // var nodeScene = self.getSceneFromData(child);
                       var rootNodeScene = self._currentScene;
                       var childNodeScene = self.getSceneFromData(self.getNodeData(childNode));
                       var childNodeData = self.getNodeData(childNode);
                       if(childNodeData == child){ // 不管怎么着，如果是他自己的话一定加进去
                          return true;
                       }
                       if (childNode instanceof mono.Billboard 
                        && childNode.getClient('_alarmBillboard')) { // 2017-11-06 如果是告警气泡的话也不应该过滤掉
                          return true;
                       }
                       
                       // 如果lazyLoad的node已经创建了，此时判断并不是把孩子都load进去，如果有复杂模型的，只有add复杂模型时还把孩子加进去
                       var complexNode = node.getClient('complexNode'),simpleNode = node.getClient('simpleNode');
                       if (complexNode 
                           && simpleNode 
                           && complexNode != 'unload' 
                           && complexNode.getParent() != node
                           && simpleNode.getParent() == node) {
                          return false;
                       }
                       if ((rootNodeScene != null || childNodeScene != null) 
                        && rootNodeScene != childNodeScene) {
                           return false;
                       }else{
                           return true;
                       }
                   });
               }
               var dataScene = this.getSceneFromData(child);
               if ((parentScene != null || dataScene != null) && parentScene != dataScene) {
                   continue;
                }
                this.loadLazyChildren(child, true);
               }
               
           }
       }
       // this.loadLinks();
    },

    $P : function(level,dataOrId){
       
    },

    loadLinks : function(){
       var dm = this.dataManager;
       var linkMap = dm.getLinkMap();
       for(var id in linkMap){
           this.loadLink(linkMap[id]);
       }
    },

    loadLink : function(link){
        var dm = this.dataManager;
        var fromId = link.getFromId();
        var toId = link.getToId();
        var fromSide = link.getFromSide();
        var toSide = link.getToSide();
        var fromNode = this.dataNodeMap[fromId];
        var toNode = this.dataNodeMap[toId];
        if (!fromNode || !toNode) {
            return;
        }
        // add 2016-12-06 连线到端，注意：由于端口是单独管理的，所以加载/卸载link时，得通过业务数据来处理
        var fromPort = null,toPort = null;
        if (link.getFromPortId()) {
            fromPort = this.postManager.loadPortByPortId(fromId,link.getFromPortId(),fromSide);
        }
        if (link.getToPortId()) {
            toPort = this.postManager.loadPortByPortId(toId,link.getToPortId(),toSide);
        }
        if (fromPort) {
            fromNode = fromPort;
        }
        if (toPort) {
            toNode = toPort;
        }

        if (this.linkMap[link.getId()]) {
            return;
        }
        var monoLink = null;
        var color = '#21CD43'; //00FFFF
        var radius = link.getRadius() || 2;
        var linkTemplate = null;
        var dataTypeId = link.getDataTypeId();
        var dataType = dm._dataTypeMap[dataTypeId];
        var imageFlow = 'data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4RDARXhpZgAATU0AKgAAAAgABQESAAMAAAABAAEAAAExAAIAAAAuAAAIVgEyAAIAAAAUAAAIhIdpAAQAAAABAAAImOocAAcAAAgMAAAASgAAAAAc6gAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE1pY3Jvc29mdCBXaW5kb3dzIFBob3RvIFZpZXdlciA2LjEuNzYwMC4xNjM4NQAyMDE1OjA3OjMwIDE2OjU4OjA4AAAB6hwABwAACAwAAAiqAAAAABzqAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4TG4aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyI+PHhtcDpDcmVhdG9yVG9vbD5NaWNyb3NvZnQgV2luZG93cyBQaG90byBWaWV3ZXIgNi4xLjc2MDAuMTYzODU8L3htcDpDcmVhdG9yVG9vbD48L3JkZjpEZXNjcmlwdGlvbj48L3JkZjpSREY+PC94OnhtcG1ldGE+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSd3Jz8+/9sAQwACAQECAQECAgICAgICAgMFAwMDAwMGBAQDBQcGBwcHBgcHCAkLCQgICggHBwoNCgoLDAwMDAcJDg8NDA4LDAwM/9sAQwECAgIDAwMGAwMGDAgHCAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgBAAEAAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA/p8ooor+sD+SwooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACv5g6/p8r+YOvyfxQ/5hv+3/8A2w/WvC3/AJif+3P/AG8KKKK/Jz9aCiiigAooooAKKKKACiiigAooooA//9k=';
        if(dataType != null){
            linkTemplate = this._linkTemplateMap[dataTypeId];
            if(!linkTemplate){
                linkTemplate = this.loadModel(dataType.getModel(),dataType.getModelParameters());
            }
        }

        if(link.getType() && link.getType() == 'link'){
            monoLink = new mono.Link(fromNode, toNode);
            if(linkTemplate && linkTemplate instanceof mono.PathNode){
                // monoLink.s(linkTemplate.styleMap); // 这样会共用，当改变某个link的style时所有的link都会跟着一起变 ——2017-06-23 Kevin
                for(var key in linkTemplate.styleMap){
                    monoLink.setStyle(key,linkTemplate.styleMap[key]);
                }
            }else{
                monoLink.s({ // 设置默认的值
                    'm.type':'phong',
                    'm.color':'cyan',
                    'm.ambient':'cyan',
                });
            }
            monoLink.setStyle('m.linewidth',5);
        }else{
            monoLink = new mono.PathLink(fromNode, toNode);
//            if(dataType != null){
               // if(linkTemplate && linkTemplate instanceof mono.PathNode){ // if exists template,use template style;
               //    monoLink.setStartCap(linkTemplate.getStartCap());
               //    monoLink.setEndCap(linkTemplate.getEndCap());
               //    monoLink.setRadius(linkTemplate.getRadius());
               //    monoLink.s(linkTemplate.styleMap);
               // }else{
                 monoLink.s({ // 设置默认的值
                  'm.type':'phong',
                  'm.color':'cyan',
                  'm.ambient':'cyan',
                  // 'm.texture.image':imageFlow,//'./images/pipeline/flow.jpg',
                  // 'm.texture.repeat':new mono.Vec2(200,1),
                 });
               // }
        }

        if(!(linkTemplate instanceof mono.PathNode) && (monoLink instanceof mono.PathNode)){
            monoLink.setStartCap('plain');
            monoLink.setEndCap('plain');
            monoLink.setRadius(radius);
            monoLink.s({
                'm.specularStrength': 30,
                'm.ambient': '#C6FEFA',
                'm.type': 'phong',
            });
        }
        monoLink._adjustTimes = 10;
        if (this.linkControlsFunction) {
            fromNode.updateWorldMatrix();
            toNode.updateWorldMatrix();
            var controls = this.linkControlsFunction(link, fromNode, toNode);
            monoLink.setLinkType('control');
            monoLink.setControls(controls);
        } else {
            var fromControls = monoLink.getFromControls();
            var toControls = monoLink.getToControls();
            var controls = [];
        }
        monoLink.setClient('id', link.getId());
        monoLink.setClient(it.SceneManager.CLIENT_IT_DATA, link);
        this.linkMap[link.getId()] = monoLink;
        monoLink.setVisible(false);  //对于it.Link加载进来后都隐藏，只有需要显示时自己控制着将其显示
        this.network3d.getDataBox().add(monoLink);
    },

    _getControlPoint : function(dataOrId,exprObject){
       exprObject  = exprObject || {};
       var x = this._getControlNumber(dataOrId,exprObject.x,'x');
       var y = this._getControlNumber(dataOrId,exprObject.y,'y');
       var z = this._getControlNumber(dataOrId,exprObject.z,'z');
       return new mono.Vec3(x,y,z);
    },

    _getControlNumber : function (dataOrId,expr,axis) {
        if(!expr){
          return 0;
        }
        var data0 = dataOrId.getId ? dataOrId : this.dataManager.getDataById(dataOrId);
        var reg = /\$(p|P)\d/g;
        var $ps = expr.match(reg);
        var scope = {};
        var self = this;

        for(var i = 0;i < $ps.length;i ++){
           var $p = $ps[i];
           var num = $p.toLowerCase().replace("$p",'');
           var node = self.getNodeByDataOrId(getParent(num,data0));
           scope[$p] = self._wrapBoundingBox(node);
        }
        function getParent(level,data){
            if(level == 0){
               return data;
            }
            var parent = self.dataManager.getParent(data);
            if(!parent){
              return data;
            }else{
               return getParent(level - 1,parent);
            }
        }
        var text = " with (scope) {  return " + expr + "}";
        var myFunction = new Function('scope', text);  
        try{
          var value = myFunction(scope); 
          return value;
        }catch(e){
           console.error(e);
        }
        return 0;
    },

    _wrapBoundingBox : function(node){
        var boundingBox = node.getBoundingBox();
        boundingBox.front = function(value){
           value = value || 0;
           return node.frontWorldPosition(this.max.z + value).z;
        };
        boundingBox.top = function(value){
           value = value || 0;
           return node.worldPosition(new mono.Vec3(0,1,0),this.max.y + value).y;
        };
        return boundingBox
    },

    isLink : function(node){
        if(node && node.getClient(it.SceneManager.CLIENT_IT_DATA)
            && node.getClient(it.SceneManager.CLIENT_IT_DATA) instanceof $Link){
            return true;
        }
        return false;
    },

    getLinkNodeById : function (linkOrId){
        var linkId = linkOrId;
        if (linkOrId instanceof it.Link) {
            linkId = linkOrId.getId();
        }
        return this.linkMap[linkId];
    },

    dwRootScene: function(data, category) {  //可能有多个datacenter  by--loda 2017-11-30
        var self = this;
        var children = data.getChildren()._as;
        if (!children.length) {
            return false;
        } else {
            for(var i=0;i<children.length;i++){
                var childCty = self.dataManager.getCategoryForData(children[i]);
                var childCtyId = childCty.getId();
                if(category == childCtyId)return false;
            }
            return true;
        }      
    },

    _loadRootScene : function(){
        var dm = this.dataManager;
        var rootScene = dm.getRootScene();
        var self = this;
        var callback = function(){
          var rootData = null;
          if (rootScene) {
             var rootCategoryId = rootScene.getCategoryId();
             var dataMap = dm.getDataMapByCategory(rootCategoryId);
             for (var id in dataMap) {
                rootData = dataMap[id];
                var bo = self.dwRootScene(rootData, rootCategoryId);
                if (!bo)continue;
                break;
             }
          }
           self._loadOneScene(rootScene, rootData);
           if (self._currentRootNode) {
             // self.viewManager3d.setFocusNode(self._currentRootNode);
             self.setFocusNode(self._currentRootNode); // 2017-08-11
           }
        }
        this.beforeLoadSceneAnimate(rootScene,null,null,null,callback,this);
    },

    clearCustomSceneView : function(){
      if (!this.sceneViewMap) {
         return ;
      }
      for(var cid in this.sceneViewMap){
        var sv = this.sceneViewMap[cid];
        if (sv && sv.getContainer() && this.mainView.contains(sv.getContainer())) {
           this.mainView.removeChild(sv.getContainer());
        } 
      }
    },

    /**
     * 用于处理GPU占用内存不释放的问题，当场景多并且大时，不断的切换会使得浏览器崩溃
     * 记录当前状态下的textutes
     */
    _saveTextures : function(){
        if(!this.isClearCache) {
          return ;
        }
        this._textures = {};
        var self = this;
        this.network3d.getDataBox().forEach(function (data) {
             data.material 
             && data.material.materials 
             && data.material.materials.forEach(function(material) {
               material.uniformsList && material.uniformsList.forEach(function(uniform) {
                  if (uniform[0].type === 't' && uniform[0].value) {
                      self._textures[uniform[0].value.id] = true;
                  } else if (uniform[0].type === 'tv' 
                          && uniform[0].value 
                          && uniform[0].value.length) {
                     console.log(uniform[0].value);
                  }
               });
           });
      });
    },
    
    /**
     * 用于处理GPU占用内存不释放的问题，当场景多并且大时，不断的切换会使得浏览器崩溃
     * 清除_saveTextures下textures
     */
    _clearTextures : function(){
        if(!this._textures || !this.isClearCache) {
          return ;
        }
        var self = this;
        Object.keys(this._textures).forEach(function(t) {
            self.network3d._gl.deleteTexture(self.network3d.pm.glTextureMap[t]);
            delete self.network3d.pm.glTextureMap[t];
        });
        Object.keys(this._textures).forEach(function(id) {
           self.network3d.pm.textureUpdateFlags[id] = true;
        });
    },
    
    
    _loadOneScene : function(scene,rootData,callback,clientMap){
        if (!this.beforeLoadScene(scene, rootData,clientMap)) {
            return;
        }
        this._saveTextures(); //记录切换前的textures，好在切换后清除它
        this.setSceneCamera(scene); //切换前先设置其参数
        this.setSceneNetworkAndLight(scene);
        var oldScene = this._currentScene;
        var oldRootData = this.getNodeData(this._currentRootNode);
        var dm = this.dataManager;
        var categoryId = scene.getCategoryId();
        var sceneType = scene.getSceneType(), level;
        var is2d = scene.getTwod();
        var withGis = scene.getWithGis();
        if (sceneType == "ShowSelf") {
            level = 0;
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
            level = 1;
        } else if(sceneType === "ShowThird"){
            level = 2;
        } else {
            level = 100;
        }
        if(this.earthScene){
          this.earthScene.clear();
        }
        this.clearCustomSceneView();
        this._currentScene = scene;
         var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView) { // 自定义的场景视图
            if (sceneView.getContainer()) {
                this.network3d.getRootView().style.display = 'none';
                this.viewManager2d.getContainer().style.display = 'node';
                this.mainView.appendChild(sceneView.getContainer());
                sceneView.show(rootData);
                callback && callback();
            } else {
                callback && callback();
                //都自定义了，view都换了，
                // onloadfinish(setAllParentRelationShip、translateAllPosition、loadLinks、resetCamera)没有啥用
                // 除非view还是那个View3D
                // 但是：父子关系和位置信息还是需要设置的，这些流程在自定义视图中处理吧！！！。
            // this.afterLoadScene(scene, rootData, oldScene, oldRootData); //都得调用
            }
            this._currentRootData = rootData; 
            if (sceneView.isLoadData()) {
               this._loadSceneData(rootData, sceneType, level, is2d); //这里创建好的对象都
            }
            if (is2d) {
                this._currentRootNode = this.dataNode2DMap[rootData.getId()];
            } else {
                this._currentRootNode = this.dataNodeMap[rootData.getId()];
            }
            this._onLoadFinish(scene, rootData, oldScene, oldRootData,clientMap);
            this.afterLoadScene(scene, rootData, oldScene, oldRootData,clientMap);
            return;
        } else if (this._currentScene.getTwod()) {
            if (!this.viewManager2d) {
               console.log('need install viewManager2d model!');
               return;
            }
            if (withGis) {
                this.viewManager2d.addGis(true, true);
            } else {
                this.viewManager2d.removeGis();
            }
            if (this._currentScene.zoomLevel) {
                this.viewManager2d.setZoomLevel(this._currentScene.zoomLevel);
            }
            if (this._currentScene.center) {
                this.viewManager2d.setCenter(this._currentScene.center);
            }
            this.network3d.getRootView().style.display = 'none';
            this.viewManager2d.getContainer().style.display = 'block';
        }else if(withGis){ //3D并且with GIS ,这时我们就认为是3D地球了
            if(!this.earthScene){
                this.earthScene = this.createDefaultEarthScene(scene);
                if (!this.earthScene) {
                   return;
                }
                this._currentRootData = rootData; 
                setTimeout(function(){
                    if (self.earthScene && self._currentScene === self.earthScene.scene) { // 延迟了1秒，有在此期间已经跳到了其他的场景
                      self.earthScene.doPlay();
                    }
                },1000);
            }else{
                this._currentRootData = rootData; 
                this.earthScene.refresh();
            }
            if (this.viewManager2d) {
               this.viewManager2d.getContainer().style.display = 'none';
            }
            this.network3d.getRootView().style.display = 'block';

            if(this.earthScene && this.earthScene.rootData){
               this._currentRootNode = this.dataNodeMap[this.earthScene.rootData.getId()];
            }else{
                this._currentRootNode = null;
            }
            this.viewManager3d.setFocusNode(null); // 到了地球场景，focus置为null 2017-10-12
            
            if (callback) {
                callback();
            }
            this.resetCamera(scene, rootData,oldScene,oldRootData,clientMap);//镜头还是统一管理，否则各个地方的动画设置没用--2016-10-27
            this.afterLoadScene(scene, rootData,oldScene,oldRootData,clientMap);
            // var self = this;
            /* 为了统一 2017-07-13 ，还是用上data上的相关参数  */
            this.setAllParentRelationShip(scene,rootData);
            this.translateAllPosition();
            // if (this.viewManager2d) {
            //    this.viewManager2d.getContainer().style.display = 'none';
            // }
            // this.network3d.getRootView().style.display = 'block';
            
            return; // 3D地球中处理了其孩子的创建，并且network和camera什么的都由其自己管理 --2016-05
            // 这里直接返回了，联position、rotation等参数都没有使用data中的.但是回来时又将被设置，因为切换到其他场景时，会全部设置一番 -- 2017-07-13
        } else {
            if (this.viewManager2d) {
               this.viewManager2d.getContainer().style.display = 'none';
            }
            this.network3d.getRootView().style.display = 'block';
        }

        if (rootData == null) {
            var dataMap = dm.getDataMapByCategory(categoryId);
            this.network3d.getDataBox().startBatch();
            for (var id in dataMap) {
                this._currentRootData = dataMap[id]; //有可能rootData没有对应3DNode
                this._loadSceneData(dataMap[id], sceneType, level, is2d);
                this._currentRootNode = this.dataNodeMap[id];
                // 放到_loadSceneData前面 否则创建node的change中判断rootData不对 -- add By Kevin 2017-05-16
                // this._currentRootData = dataMap[id]; //有可能rootData没有对应3DNode
            }
        } else {
            this._currentRootData = rootData; // 当场景showChild时，那_currentRootNode就不会创建
            this.network3d.getDataBox().startBatch();
            this._loadSceneData(rootData, sceneType, level, is2d);
            //如果是2d，并且是lazyable时，通过搜索树直接跳过去的话，那3D的对象很有可能没有加载出来
            //因此改成如果是2D的话，rootNode就是twaver 2D的node
            if (is2d) {
                this._currentRootNode = this.dataNode2DMap[rootData.getId()];
            } else {
                this._currentRootNode = this.dataNodeMap[rootData.getId()];
            }
            // 放到_loadSceneData前面 否则创建node的change中判断rootData不对 -- add By Kevin 2017-05-16
            // this._currentRootData = rootData; // 当场景showChild时，那_currentRootNode就不会创建 
        }
        if (callback) {
            callback();
        }
        if (this._currentScene.getTwod() && this.viewManager2d) {
            this.viewManager2d.showTable(this._currentScene);
            this.viewManager2d.showTree(this._currentScene);
            this.network2d.zoomOverview();
        }
//      var oldScene = this._currentScene;
        //颠倒一下，当设置好位置等信息后在调用afterLoadScene,
        // 否则在监听sceneChange时需要重新计算位置，调整镜头等loadFinishe中的东西，、
        // 如果不一致的话，非的设置timeout才能确保更改后的东西不被afterLoadScene中的操作覆盖
        this.network3d.getDataBox().endBatch();
        this._onLoadFinish(scene, rootData,oldScene,oldRootData,clientMap);
        this.afterLoadScene(scene, rootData,oldScene,oldRootData,clientMap);
    },

    afterCreateEarthScene : function(earthScene){

    },

    createDefaultEarthScene: function(scene) {
        if (!it.DefaultEarthScene) {
           console.log('  need include DefaultEarthScene!!!');
           return null;
        }
        var earthScene = new it.DefaultEarthScene(this, scene);
        earthScene.createDCBillboard = function(data) {
            return null
        };
        this.afterCreateEarthScene(earthScene);
        this._sceneManagerChangeDispatcher.fire({
               kind:'createDefaultEarthScene',
               data:earthScene
           });
        return earthScene;
    },

    // 可是如果scene中的根是lazyLoad呢(比如floor是lazyLoad，那么双击进入floor场景时)
    _loadSceneData : function(data,sceneType,level,is2d){
        var getChildTime = 0;
        var dm = this.dataManager;
        if (sceneType === "ShowChildren" && level === 1) {
        } else if(sceneType === "ShowDescendant" && level === 100){
          
        }else if(sceneType === "ShowSelfAndDescendant" && level === 100){ // 2017-10-11这种情况也应该加载根（不管根是不是lazy的）
           this.loadDataModel(data);
        }else {
            if (is2d) {  // 目前不支持同时显示2D和3D,并且2D不支持lazyload
                this.loadDataModel2D(data);
            } else {
                if (!dm.isLazyable(data)) {
                    this.loadDataModel(data);
                }
            }
        }
        if (level <= 0) {
            return;
        }
        var children = data.getChildren();//dm.getChildren(data);
        for (var i = 0; i < children.size(); i++){
            var child = children.get(i);
            if (this.isLoadChild(data,child,sceneType,level-1)) { //增加一个抽象类，方便扩展 2018-02-26 Kevin
               this._loadSceneData(child, sceneType, level - 1, is2d);
            }
        }
    },
 
    /**
     * Kevin
     * 2018-02-26 
     * 增加一个抽象类，使得在loadScene时可以控制 
     */
    isLoadChild : function(data,child,sceneType,level){
      return true;
    },

    _onLoadFinish : function(scene, rootData,oldScene,oldRootData,clientMap){
        this.setAllParentRelationShip(scene,rootData);
        this.translateAllPosition();
        this.loadLinks();
        this._clearTextures();// 释放GPU占用的内存
        this.resetCamera(scene, rootData,oldScene,oldRootData,clientMap);
        //设置该场景中的相关的参数，如3D时：灯光，network的背景色，镜头的角度等属性,包括场景的动画，目前这些东西都是共享的
        //这些动作其实可以通过添加一个sceneChangeListener来单独处理，放到了setSceneNetworkAndLight中
//        this.setSceneNetworkAndLight();
        this._loaded = true;
    },

    getSetMethod : function(key){
        var setMethod = 'set' + key.charAt(0).toUpperCase() + key.slice(1);
        return setMethod;
    },

    /**
     * 个图network3d的某个属性key设置value值
     * @param key
     * @param value
     */
    setNetworkValue : function(network3d,key,value){
        if(!key){
            return ;
        }
        var setMethod = this.getSetMethod(key);
        // var network3d = this.network3d;
        // var currentScene = this._currentScene;
        // var sceneView = this.sceneViewMap[currentScene.getId()];
        // if (sceneView && sceneView.getNetwork3D()) {
            // network3d = sceneView.getNetwork3D();
        // }
        if(network3d[setMethod] && (typeof(network3d[setMethod]) === 'function')){
            network3d[setMethod](value);
        }else{
            network3d[key] = value;
        }
    },

    /**
     * 根据scene中的defaultInteraction的参数设置默认交互的参数
     */
    setDefaultInteractionValue: function(scene) {
        if(!scene){
            return;
        }
        var defaultInteractionParameters = scene.defaultInteractionParameters;
        if (!defaultInteractionParameters) {
            return;
        }
        // var currentScene  = this._currentScene;
        var network3d = this.network3d;
        if (scene && this.sceneViewMap[scene.getId()] && this.sceneViewMap[scene.getId()].getNetwork3D()) {
            network3d = this.sceneViewMap[scene.getId()].getNetwork3D();
        }
        var df = network3d.getDefaultInteraction();
        if (defaultInteractionParameters) {
            for (var key in defaultInteractionParameters) {
                var setMethod = this.getSetMethod(key);
                var value = defaultInteractionParameters[key];
                if (df[setMethod] && (typeof(df[setMethod]) === 'function')) {
                   df[setMethod](value);
                } else {
                    df[key] = value;
                }
            }
        }
    },

    setCameraValue : function(camera,key,value){
      if(!key || !camera){
            return ;
        }
        // var camera = this.network3d.getCamera();
        // var currentScene  = this._currentScene;
        // var sceneView = this.sceneViewMap[currentScene.getId()];
        // if (sceneView && sceneView.getCamera()) {
        //    camera = sceneView.getCamera();
        // } 
        var setMethod = this.getSetMethod(key);
        if(camera[setMethod] && (typeof(camera[setMethod]) === 'function')){
          if (value instanceof Array && value.length ===3 ) {
            camera[setMethod](value[0],value[1],value[2]);
          }else{
            camera[setMethod](value);
          }
        }else if(key == 'target'){
          if (value instanceof Array && value.length ===3 ) {
            camera['lookAt'](value[0],value[1],value[2]);
          }
        }else{
            camera[key] = value;
        }
    },

    clearSceneNodeMap : function(){
        this._sceneNodeMap = {}; //用来存储当前场景的所有对象
        this._sceneNodes = [];
    },

    addToSceneNodeMap : function(data,node){
        if (!data || !node) {
            return  ;
        }
        this._sceneNodeMap[data.getId()] = node;
        this._sceneNodes.push(node);
    },

    /**
     * 设置该场景中的相关的参数，如3D时：灯光，network的背景色，镜头的角度等属性,包括场景的动画，目前这些东西都是共享的
     * @param scene
     */
    setSceneNetworkAndLight : function(scene){
        if(!scene){
            return null;
        }
        if(scene.getTwod()){ //如果是2D的话，那就设置2D的network
            return;
        }
        var networkParameters = scene.networkParameters;
        var lights = scene.lights;
        var animateParameters = scene.animateParameters;
        var network = this.network3d;
        var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView && sceneView.getNetwork3D()) {
          network = sceneView.getNetwork3D();
        } 
        this.viewManager3d.resetNetwork();//默认的设置，需要设置默认的都要通过viewManager来管理
        if(networkParameters){
            for(var pro in networkParameters){
               this.setNetworkValue(network,pro,networkParameters[pro]);
            }
        }
    },

    setSceneCamera : function(scene){
        this.viewManager3d.resetCamera();
        if(!scene){
            return null;
        }
        if(scene.getTwod()){ //如果是2D的话，那就设置2D的network
            return;
        }
        var camera = this.network3d.getCamera();
        var sceneView = this.sceneViewMap[scene.getId()];
        if (sceneView && sceneView.getCamera()) {
           camera = sceneView.getCamera();
        } 
        var cameraParameters = scene.cameraParameters;
        if(cameraParameters){
            for(var pro in cameraParameters){
               this.setCameraValue(camera,pro,cameraParameters[pro]);
            }
        }
    },

    _loadDataMap : function(dataMap){
        var dm = this.dataManager;
        for (id in dataMap) {
            var data = dataMap[id];
            if (!dm.isLazyable(data)) {
                this.loadDataModel(dataMap[id]);
            }
        }
        // 颠倒一下，当设置好位置等信息后在调用afterLoadScene,
        // 否则在监听sceneChange时需要重新计算位置，调整镜头等loadFinishe中的东西，、
        // 如果不一致的话，非的设置timeout才能确保更改后的东西不被afterLoadScene中的操作覆盖
        this._onLoadFinish();
        this.afterLoadScene();
    },
    
    /**
     * 场景切换时，重置镜头
     * 加上了一堆的参数，是为了重载扩展用
     * moveCameraCallback这个是镜头 
     * 这个方法在CameraManager中重写了
     */
    resetCamera : function(scene, rootData,oldScene,oldRootData,moveCameraCallback){
//      this.network3d.zoomEstimateOverview(30); //要不通过LookAt中的方式改进，要不直接去掉，反正进入到每个场景后都会重新计算
        if(this.resetCameraWhenSceneChange){
          if (this._currentRootNode) {
             this.viewManager3d.getDefaultEventHandler().lookAtNodeWithOutAnimate(this._currentRootNode);
          }else{
            this.network3d.zoomEstimateOverview(30);
          }
        }
        this.resetCameraWhenSceneChange = true; 
    },

    loadScene : function (){
        var dm = this.dataManager;
        var rootScene = dm.getRootScene();
        // if (!this.beforeLoadScene(rootScene)) {  // 在_loadRootScene中有执行
        //     return;
        // }
        if (rootScene) {
            this.loadPreRenderScene();
            return this._loadRootScene();
        }
        var dataMap = dm.getDataMap();
        this._loadDataMap(dataMap);
    },

    /**
     * 加载提前渲染的场景
     * 前提条件：
     *   1、必需有rootScene
     *   2、不是rootScene
     *   3、跟rootScene不是一个view(network)
     *   
     */
    loadPreRenderScene: function(callback) {
        var sceneMap = this.dataManager._sceneMap;
        var rootScene = this.dataManager.getRootScene();
        // var preLoadSceneMap = {};
        for (var id in sceneMap) {
            var scene = sceneMap[id];
            if (scene && scene != rootScene && scene.getPreRender() && !this.isSameView(scene, rootScene)) {
                // preLoadSceneMap[id] = scene;
                var level;
                var sceneType = scene.getSceneType();
                if (sceneType == "ShowSelf") {
                    level = 0;
                } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                    level = 1;
                } else if (sceneType === "ShowThird") {
                    level = 2;
                } else {
                    level = 100;
                }
                var sceneView = this.sceneViewMap[scene.getId()]
                if(sceneView && sceneView.getContainer()){
                    scene.getContainer().style.display = 'none';
                }else{
                   this.network3d.getRootView().style.display = 'none';
                   this.viewManager2d.getContainer().style.display = 'node';
                }
                var dataMap = this.dataManager.getDataMapByCategory(scene.getCategoryId());
                for(var key in dataMap){
                    var data = dataMap[key];
                    if (!data) {
                       continue;
                    }
                    if (data && data.getParentId() && !this.dataManager.getDataById(data.getParentId())) {
                       continue;
                    }
                    if (data.getChildren() && data.getChildren().size() <= 0) {
                       continue;
                    }
                    this._loadSceneData(data, sceneType, level, scene.getTwod());
                    // 设置sceneView中的镜头的默认起始位置：以免切到该场景
                    // this._onLoadFinish(scene, rootData,oldScene,oldRootData);
                    this.setFocusNode(this.getNodeByDataOrId(data)); // 有可能需要真假切换的，如dc，直接进去的话真的模型还没有load
                    this.lookAt(this.getNodeByDataOrId(data));
                }
            }
        }
        callback && callback();
    },

    isSameView : function(scene1,scene2){
        if(!scene1 || !scene2){
            return true;
        }
        if (scene1 == scene2) {
            return true;
        }
        var s1View = this.sceneViewMap[scene1.getId()],s2View = this.sceneViewMap[scene2.getId()]; 
        if (scene1.getTwod()) {
            s1View = this.network2d;
        }else if(s1View && s1View.getContainer()){ //自定义
            s1View = scene1.getContainer();
        }else{
            s1View = this.network3d;
        }

        if(scene2.getTwod()){
            s2View = this.network2d;
        }else if (s2View && s2View.getContainer()) { //自定义
            s2View = s2View.getContainer();
        }else{
            s2View = this.network3d;
        }

        if (s1View != s2View) {
            return false;
        }
        return true;
    },

    /**
     * 显示所有不可见的对象(这个“不可见”指的是，category中标记的是否可见)
     */
    showAllInvisibleData : function(){
        // this.viewManager3d.removeVisibleFilter(this.invisibleFilter); // 有可能还没有加载咧
       var categoryMap = this.dataManager._categoryMap;
       if (!categoryMap) {
          return false;
       }
       for(var id in categoryMap){
          this.setInvisibleDataByCategoryId(id,true);
       }
    },

    /**
     * 隐藏所有的不可见的对象(这个“不可见”指的是，category中标记的是否可见)
     */
    invisibleAllInvisibleData : function(){
       var categoryMap = this.dataManager._categoryMap;
       if (!categoryMap) {
          return false;
       }
       for(var id in categoryMap){
          this.setInvisibleDataByCategoryId(id,false);
       }
    },

    /**
     * 根据categoryId来显示/隐藏该category对应的对象(这个“不可见”指的是，category中标记的是否可见)
     * 注意：如果该category本来就是可见的，那就不做任何处理，这里只处理category.isVisible() == false的
     * 有可能这些data也没有加载，那此时是否需要加载它？
     */
    setInvisibleDataByCategoryId : function(categoryId,visible){
       if (!categoryId) {
         return;
       }
       var category = this.dataManager._categoryMap[categoryId];
       if (!category || category.isVisible()) {
         return;
       }
       var datas = this.dataManager.getDataMapByCategory(categoryId);
       if (!datas) {
          return;
       }
       // this.viewManager3d.addVisibleFilter(this.invisibleFilter);
       for(var id in datas){
         var data = datas[id];
         // this.invisibleFilter.setVisible(data,visible);
         if(!this.dataNodeMap[id] 
           && this.isCurrentSceneInstance(data)){ //如果是当前场景中的data，并且没有load过，这里就load一下
           this.loadOneData(data,true);//这个里面统一将data的Visible设置成了false
         }
         this.invisibleFilter.setVisible(data,visible); //要放到loadDataMode后面，
       }
       this.viewManager3d.clearVisibleMap();
       this.network3d.dirtyNetwork();
    },

    getAlarmManager:function(){
        return this._alarmManager;
    },

    addSceneManagerChangeListener : function(listener, scope, ahead) {
        this._sceneManagerChangeDispatcher.add(listener, scope, ahead);
    },
    removeSceneManagerChangeListener : function(listener, scope) {
        this._sceneManagerChangeDispatcher.remove(listener, scope);
    },

    addSeneChangeListener : function(listener, scope, ahead){
       this._sceneChangeDispather.add(listener,scope,ahead);
    },

    addSceneChangeListener : function(listener, scope, ahead){
        this._sceneChangeDispather.add(listener,scope,ahead);
    },

    removeSceneChangeListener : function(listener, scope){
       this._sceneChangeDispather.remove(listener,scope);
    },

    addSceneVirtualChangeListener : function(listener, scope, ahead){
        this._sceneVirtualChangeDispather.add(listener,scope,ahead);
    },

    removeSceneVirtualChangeListener : function(listener, scope){
       this._sceneVirtualChangeDispather.remove(listener,scope);
    },

    addSceneVisibleChangeListener : function(listener, scope, ahead){
        this._sceneVisibleChangeDispather.add(listener,scope,ahead);
    },

    removeSceneVisibleChangeListener : function(listener, scope){
       this._sceneVisibleChangeDispather.remove(listener,scope);
    },

    /**
     * 移除billboard
     * @param {mono.Billboard} board
     */
    removeBillboard : function (board) {
        board.setParent(null);
        this.getDataBox().remove(board);
    },

    /**
     * 移除所有billboard
     * @param dataId
     */
   /* removeAllBillboardByDataId:function(dataId){
        var data = this.dataManager.getDataById(dataId);
        this.removeAllBillboardByData(data);
    },
*/
    /**
     * 移除所有billboard
     * @param {it.Data} data
     */
  /*  removeAllBillboardByData : function (data) {
        var boards = data.boards;
        if(boards){
            for(var i=0;i<boards.length;i++){
                this.removeBillboard(boards[i]);
            }
        }
    },
*/
    /**
     * 创建一个空白的billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
   /* createBillboardById:function(dataId, board){
        var node = this.dataNodeMap[dataId];
        this.getDataBox().add(board);
        var data = this.dataManager.getDataById(dataId);
        if(!data.boards){
            data.boards = [];
        }
        data.boards.push(board);
        return board;
    },
    */

    /**
     * 创建一个空白billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createBillboard : function (data, board) {
        return this.createTitleBillboardById(data.getId(),board);
    },

    /**
     * 创建一个文本billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTextBillboard : function (data, text, gbColor) {
        return this.createTextBillboardById(data.getId(),text, gbColor);
    },

    /**
     * 创建一个文本billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTextBillboardById : function (dataId, text, gbColor) {
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createTextBillboardForNode(node, text, gbColor);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * 创建一个空白的billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
    createEmptyBillboardById:function(dataId, args){
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createEmptyBillboardForNode(node, args);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * 创建一个空白billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createEmptyBillboard : function (data, text, gbColor) {
        return this.createEmptyBillboardById(data.getId(),text, gbColor);
    },

    /**
     * 创建一个空白的billboard
     * @param dataId
     * @param {width: 256,height: 128,radius: 16,arrowWidth: 16,arrowHeight: 16,bgColor: '#5B85B5'} args
     */
    createTitleBillboardById:function(dataId, args){
        var node = this.dataNodeMap[dataId];
        var board = it.Util.createTitleBillboardForNode(node, args);
        this.getDataBox().add(board);
        return board;
    },

    /**
     * 创建一个空白billboard
     * @param  {it.Data} data
     * @param {String} text
     * @param {Color} gbColor
     * @returns {mono.Billboard}
     */
    createTitleBillboard : function (data, args) {
        return this.createTitleBillboardById(data.getId(),args);
    },

    /**
     * 将appObj的属性合并至orgObj中
     * @param orgObj
     * @param appObj
     */
    margeObject : function(orgObj,appObj){
        orgObj = orgObj || {};
        if(!appObj){
            return orgObj;
        }
        if(appObj instanceof Array){
            for(var i = 0 ; i <  appObj.length ;i++){
                var data = appObj[i];
                if(data.getId()){
                    orgObj[data.getId()] = data;
                }
            }
        }else if(appObj instanceof mono.List){
            for(var i = 0 ; i <  appObj.size() ;i++){
                var data = appObj.get(i);
                if(data && data.getId()){
                    orgObj[data.getId()] = data;
                }
            }
        }
        else{
            for(var dataId in appObj){
                if(dataId && appObj[dataId]){
                    orgObj[dataId] = appObj[dataId];
                }
            }
        }
        return orgObj;
    },

    /**
     *  获取当前场景的data，包括lazyload的data
     */
    getSceneDatas : function(rootData){
        rootData = rootData||this.getNodeData(this._currentRootNode);
        var rooDataAndScene = this.getSceneAndRootByData(rootData)||{};
        var scene = rooDataAndScene.scene || this._currentScene;
        var dm = this.dataManager;
        if (!scene) {
            return dm.getDataMap();
        }
        var categoryId = scene.getCategoryId();
        var sceneType = scene.getSceneType() || '';
        var datas = {};
        if (rootData) {
            datas[rootData.getId()] = rootData;
            if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                var children = rootData.getChildren();
                this.margeObject(datas, children);
            } else { // 获取这个data的子孙(不仅仅是孩子)
                var descendants = dm.getDescendants(rootData);
                this.margeObject(datas, descendants);
            }
        } else {
            var dataMap = dm.getDataMapByCategory(categoryId); // 还得考虑rootData，每个楼层都共用一个Scene呢
            if (!dataMap || sceneType == "ShowSelf") {
                return dataMap;
            }
            for (var dataId in dataMap) {
                var data = dataMap[dataId];
                if (data) {
                    datas[dataId] = data;
                    if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") {
                        var children = data.getChildren();//dm.getChildren(data);
                        this.margeObject(datas, children);
                    } else { // 获取这个data的子孙(不仅仅是孩子)
                        var descendants = dm.getDescendants(data);
                        this.margeObject(datas, descendants);
                    }
                }
            }
        }
        return datas;
    },

    getSceneDataTypes: function(rootData) {
        var dataTypes = {};
        var currentSceneDatas = this.getSceneDatas(rootData);
        if (currentSceneDatas) {
            for (var dataId in currentSceneDatas) {
                var data = currentSceneDatas[dataId];
                if (data) {
                    var dataType = this.dataManager.getDataTypeForData(data);
                    dataTypes[dataType.getId()] = dataType;
                }
            }
        }
        return dataTypes;
    },

    getDatasByAncestorId : function(){

    },

    /**
     * 获取当前场景的根节点，注意，改节点有可能是2D的也有可能是3D的
     * @returns {*|it.SceneManager._currentRootNode}
     */
    getCurrentRootNode : function(){
        return this._currentRootNode;
    },


    getLinkData : function(linkNode){
        if(!linkNode){
            return null;
        }
        var link = linkNode.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(link && (link instanceof $Link)){
            return link;
        }
        return null;
    },

     
    /**
     * 根据dataId删除场景中的node 
     * add by Kevin 
     * 2016-10-09
     */
    removeDataNodeByDataOrId : function(dataOrId){
       if (!dataOrId) {
         return;
       }
       var dataId = dataOrId;
       if (dataOrId instanceof it.Data){
         dataId = dataOrId.getId();
       }
       var box = this.network3d.getDataBox();
       var dataNode = this.getNodeByDataOrId(dataOrId);
       if (dataNode) {
         dataNode.setParent(null);
         delete this.dataNodeMap[dataId];
         box.removeByDescendant(dataNode);
         this._sceneManagerChangeDispatcher.fire({
               kind:'remove',
               data:dataNode
         });

       }
    },

    /**
     * 根据data看是否需要创建该data对应的3D对象
     * 使用场合:当动态的添加一个资产时(推送机制)
     * add by Kevin 
     * 2016-10-11
     * 需要先判断该data是不是当前场景中的对象
     */
    createNodeByDataOrId : function(dataOrId){
       if (!dataOrId 
           || !this.isCurrentSceneInstance(dataOrId)) {
          return;
       }
       var data = dataOrId;
       if (!(dataOrId instanceof it.Data)){
          data = this.dataManager.getDataById(dataOrId);
       }
       if (data) {
         this.loadDataModel(data);
         this.setParentRelationShip(data); // 需要算位置，add by Kevin 2016-11-17
         this.translatePosition(data);
       }
    },

    /**
     * 判断ancestorId是不是data的祖先
     * @param dataOrId
     * @param ancestorId
     */
    isAncestor : function(dataOrId,ancestorId,scope){
        var self = scope || this;
        if(!dataOrId || !ancestorId){
            return false;
        }
        var data = null;
        if(dataOrId instanceof $Data){
            data = dataOrId;
        }else{
            data = this.dataManager.getDataById(dataOrId);
        }
        if(!data){
            return false;
        }
        var ancestor = null;
        if (ancestorId instanceof $Data) {
           ancestor = ancestorId;
           ancestorId = ancestor.getId();
        }else{
           ancestor = this.dataManager.getDataById(ancestorId);
        }
        if(!ancestor){
            return false;
        }
        if(ancestor.getParentId() && ancestor.getParentId() === data.getId()){ //使之提前跳出
            return false;
        }
        if(data.getParentId()){
            if(data.getParentId() === ancestorId){
                return true;
            }else{
                return self.isAncestor(data.getParentId(),ancestorId,self);
            }
        }
        return false;
    },

    /**
     * 判断是不是在同一个Scene下，严格意义上来讲，往上找parent时，还要判断scene的sceneType
     */

     lastSceneFilter : function(data){
        return true;
     },

    /**
     * 获取data的"Scene实例"(Scene实例指的是rootData+Scene)
     * @param data
     * @param sceneMap
     * @param scope
     * @returns {*}
     */
    getLastSceneInstance : function(data,sceneMap,scope){
        var self = scope || this;
        sceneMap = sceneMap || self.dataManager._categorySceneMap;
        if(!data || !sceneMap){
            return null;
        }
        if (typeof(data) === 'string') { //支持dataid
           data = self.dataManager.getDataById(data);
        }
        if (!data) {
           return null;
        }
        var category = self.dataManager.getCategoryForData(data);
        if(category && sceneMap[category.getId()] && self.lastSceneFilter(data)){
            return {rootData:data , scene:sceneMap[category.getId()]};
        }else if(data && data.getParentId && data.getParentId()){
            var parent = self.dataManager.getDataById(data.getParentId());
            return self.getLastSceneInstance(parent,sceneMap,self);
        }
        return null;
    },

    /**
     * 根据Data获取Scene实例
     * @param data
     * @returns {*}
     */
    getSceneAndRootByData : function(data){
        if(!data){
            return null;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return null;
        }
        return this.getLastSceneInstance(data,sceneMap);
    },

    /**
     * 判断该data或id是不是在当前场景下
     * 注意：有可能data存在于多个场景中，那都应该返回true
     * @param dataOrId
     * @isNearestScene 当前的场景是不是离它最近的场景，默认是否
     * @returns {boolean}
     */
    isCurrentSceneInstance : function(dataOrId,isNearestScene){
        if(!dataOrId){
            return false;
        }
        var data = dataOrId;
        if(!(data instanceof $Data)){
            data = this.dataManager.getDataById(data);
        }
        if(!data){
            return false;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return true;
        }
        var currentScene = this._currentScene;
        if(!currentScene){
            // return true;
            return false ; // 返回ture，对于preRender来说可能会认为所有的子孙结点都在当前场景中
        }
        var currentRootData = this._currentRootData||this.getNodeData(this._currentRootNode); //add By Kevin 2017-05-16调换了一下
        if (!currentRootData) { // currentRootData都没有，有可能是没有创建好，直接返回false
            return false;
        }
        if(data == currentRootData){
            return true;
        }
        if (isNearestScene) {
            var lastSceneAndRootData = this.getLastSceneInstance(data);
            if(lastSceneAndRootData 
                && lastSceneAndRootData.rootData == currentRootData 
                && lastSceneAndRootData.scene == currentScene){
                return true;
            }else{
                return false;
            }
        }
        if(currentRootData && !this.isAncestor(data,currentRootData.getId())){
            return false;
        }
        var sceneType = currentScene.getSceneType();
        if (sceneType === "ShowSelf") {
            if (currentRootData.getId() == data.getId()) {
                return true;
            }else{
                return false;
            } //备注：20170329 可是存在一个问题，在earth场景时，判断dc是不是该场景时总是返回true，其实不管返回true或false都有道理，但是有时我需要判断是否进入下一层时就应该返回false，所以上面的isNearestScene得传
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") { 
            if (currentRootData && (currentRootData.getId() == data.getId() 
                || currentRootData.getId() == data.getParentId())) {
                return true;
            }else{
                return false;
            }
        } else if(sceneType === "ShowThird"){
            if (currentRootData.getId() == data.getId() 
                || currentRootData.getId() == data.getParentId()) {
                return true;
            }
            var parentData = this.dataManager.getDataById(data.getParentId());
            if (parentData 
                && currentRootData.getId() == parentData.getParentId()) {
                return true;
            }
            return false;
        } else {
            return true;
        }
    },
    
    /**
     * 判断data是否在(scene,rootData)中
     * 
     */
    isSceneInstance : function(scene,rootData,data){
        if(!scene || !rootData || !data){
           return false;
        }
        if(rootData != data && !this.isAncestor(data,rootData.getId())){
            return false;
        }
        var rdCategory = this.dataManager.getCategoryForData(rootData);
        var dCategoty = this.dataManager.getCategoryForData(data);
        if (rdCategory 
          && rdCategory.getId().toLowerCase() == 'datacenter' 
          && dCategoty 
          && dCategoty.getId() == 'floor'){
            return true;
        }
        var sceneType = scene.getSceneType();
        if (!sceneType) {
           return false;
        }
        if (sceneType === "ShowSelf") {
            if (rootData.getId() == data.getId()) {
                return true;
            }else{
                return false;
            } //备注：20170329 可是存在一个问题，在earth场景时，判断dc是不是该场景时总是返回true，其实不管返回true或false都有道理，但是有时我需要判断是否进入下一层时就应该返回false，所以上面的isNearestScene得传
        } else if (sceneType === "ShowSelfAndChildren" || sceneType === "ShowChildren") { 
            if (rootData.getId() == data.getId() 
                || rootData.getId() == data.getParentId()) {
                return true;
            }else{
                return false;
            }
        } else if(sceneType === "ShowThird"){
            if (rootData.getId() == data.getId() 
                || rootData.getId() == data.getParentId()) {
                return true;
            }
            var parentData = this.dataManager.getDataById(data.getParentId());
            if (parentData 
                && rootData.getId() == parentData.getParentId()) {
                return true;
            }
            return false;
        } 
        return true;
    },

    /**
     * 判断该data是不是Scene的根节点
     * @param data
     */
    isSceneRootData : function(data){
        if(!data){
            return false;
        }
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){
            return false;
        }
        var category = this.dataManager.getCategoryForData(data);
        if(category && sceneMap[category.getId()]){
            return true;
        }
    },

   /*
    isTheSameSceneInstance : function(data1,data2){
        var sceneMap = this.dataManager._categorySceneMap;
        if(!sceneMap){ //如果scene都没有的话，那所有的对象都在同一个scene中
            return true;
        }
    },
    */

    getAlarmManagerClass:function(){
        return it.AlarmManager;
    },

    registerCustomSceneView: function(sceneId, customSceneView) {
        if (!sceneId || !customSceneView) {
            return;
        }
        if (!this.sceneViewMap) {
            this.sceneViewMap = {};
        }
        this.sceneViewMap[sceneId] = customSceneView;
    },

    deregisterCustomSceneView : function(sceneId){
       if (sceneId && this.sceneViewMap && this.sceneViewMap[sceneId]) {
         delete this.sceneViewMap[sceneId];
       }
    },

    adjustCustomSceneViewBounds : function(w,h,left,top){
        for(var sceneId in this.sceneViewMap){
            var sceneView = this.sceneViewMap[sceneId];
            if (sceneView) {
                sceneView.adjustBounds(w,h,left,top);
            }
        }
    },

    getCurrentSceneView : function(){
       if (this._currentScene) {
         return this.sceneViewMap[this._currentScene.getId()];
       }
       return null;
    },

    /**
     * 根据node获取该node所在的场景
     * 但是：1、存在同一个node在多个场景中的问题，这时就看该node是不是在当前场景中，如果是在当前场景中则返回当前场景视图，否则返回离它最近的那个场景视图
     *      2、node确保都创建
     */
    getSceneViewByNode : function(node){
        if (!node) {
            return null;
        }
        var scene = null;
        var data = this.getNodeData(node);
        if (this.isCurrentSceneInstance(data)) {
            scene = this._currentScene;
        }else {
            var sceneAndRootData = this.getSceneAndRootByData(data);
            if (sceneAndRootData && sceneAndRootData.scene) {
                scene = sceneAndRootData.scene;
            }
        }
        if (scene && this.sceneViewMap[scene.getId()]) {
            return this.sceneViewMap[scene.getId()];
        }else{
            return this.viewManager3d;
        }
    },

    getFocusNode : function(){
        return this._focusNode;
    },

    setFocusNode : function(node){
        this._focusNode = node;
        var sceneView = this.getSceneViewByNode(node);
        if (sceneView && sceneView.setFocusNode) {
            sceneView.setFocusNode(node);
        }
    },

    /**
     * 获取当前场景的镜头
     * 根据当前的场景视图来获取的
     */
    getCurrentCamera : function(){
       var scene = this._currentScene ;
       var sceneView = null;
       if (scene) {
           sceneView = this.sceneViewMap[scene.getId()];
       }
       if (sceneView) {
           if ('upload' == sceneView.getCamera()) { //如果返回unload，表示该场景没有镜头，返回null的话就表示跟内置的共用一个镜头
             return null;
           }else{
             return sceneView.getCamera();
           }
       }else{
           return this.network3d.getCamera();
       }
    },

    /**
     * lookAt
     * 外面的调用都从这里开始，内部根据node所在的view来做具体的分发
     * 目前内部没有做
     */
    lookAt : function(node, callback1) {
        var sceneView = this.getSceneViewByNode(node);
        if (sceneView) {
           this.viewManager3d.defaultEventHandler.lookAt(node,callback1);// 目前sceneView中没有做特别的处理，所以这里共用
        }else{
           this.viewManager3d.defaultEventHandler.lookAt(node,callback1);
        }
    }
    
});
// 用于管理运行时候的，动态更改材质的功能。

var $MaterialFilter =  function  (argument) {
	
}; 
it.MaterialFilter = $MaterialFilter;
mono.extend($MaterialFilter,Object,{
	filterMaterial : function(originalMaterial,filterdMaterial,node){
        return originalMaterial;
	},
});

var $VisibleFilter = function(arguments){

};

mono.extend($VisibleFilter,Object,{
    isVisible: function(node,data,network){
        return true;
    }
});

it.VisibleFilter = $VisibleFilter;

/**
* 灯光管理器
*/
var $LightManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.sceneLights = {};
	this.init();
};

mono.extend($LightManager,Object,{

	init:  function(){
		var self = this;
		this.sceneManager.addSceneChangeListener(function(eve){
			var scene = eve.data;
            self.setUpLights(scene);
		});
	},

	getDefaultLights: function() {
		var lights = {};
		var ambientLight = new mono.AmbientLight(0xFFFFFF);
		lights['a'] = ambientLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 10000, 10000);
		lights['p1'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(-10000, 10000, -10000);
		lights['p2'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 10000, -10000);
		lights['p3'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(-10000, 10000, 10000);
		lights['p4'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, 10000);
		lights['p5'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, -10000);
		lights['p6'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(10000, 0, 0);
		lights['p7'] = pointLight;
		var pointLight = new mono.PointLight(0xFFFFFF, 0.05);
		pointLight.setPosition(0, 0, -10000);
		lights['p8'] = pointLight;
		return lights;
	},

	setUpLights : function(sceneOrId){
		var lights = {};
		var id = sceneOrId;
		this.clearLights();
		if (sceneOrId instanceof it.Scene) {
			id = sceneOrId.getId();
		}
		if (!id || !this.sceneLights[id]) { //如果没有给场景设置灯光的话，那就使用默认的灯光
			lights = this.getDefaultLights();
		}else{
			lights = this.sceneLights[id];
		}
		var dataBox = this.sceneManager.network3d.getDataBox();
		for (var pro in lights) {
			var light = lights[pro];
			dataBox.add(light);
		}
	},

	clearLights : function(){
		var dataBox = this.sceneManager.network3d.getDataBox();
		var lights = [];
		for (var i = 0; i < dataBox.size(); i++) {
			var light = dataBox.getLights().get(i);
			if (light) {
				lights.push(light);
			};
		};
		for(var i = 0 ; i < lights.length ; i++){
			var light = lights[i];
			dataBox.remove(light);
		}
	},

	addSceneLight : function(light){ 
		if (!light) {
			return;
		}
		var sceneId = light.getSceneId();
		var lightId = light.getId();
		var lightObj = null;
		if (light.getType().toLowerCase().indexOf('am')>=0) {
			lightObj = new mono.AmbientLight(light.getColor());
		}else{
			lightObj = new mono.PointLight(light.getColor(),light.getIntensity()||1,light.getDistance()||0);
		    lightObj.setPosition(light.getPosition());
		}
		var allLights = this.sceneLights[sceneId];
		if (!allLights) {
           this.sceneLights[sceneId] = {lightId:lightObj}; 
		}else{
			allLights[lightId] = lightObj;
		}
	},

    /**
     * 移除场景中的某个light
    */
	removeSceneLight : function(light){
        if (!light) {
			return;
		}
		var sceneId = light.geSceneId();
		var lightId = light.getId();
		var lights = this.sceneLights[sceneId];
		if (lights){
			delete lights[lightId];
			// disparch...
		} 
	},

	addLightsFromJson : function(json){
		var jsonObjects = json;
       if(typeof json === "string"){
          jsonObjects = JSON.parse(json);
       }     
       var i = 0,len = jsonObjects.length;

       for(i = 0;i < len;i ++){
          var jsonObject = jsonObjects[i];
          var light = new $Light();
          light.fromJson(jsonObject);
          this.addSceneLight(light);
       }
	}


});


it.LightManager = $LightManager;
/**
 * 告警级别
 * @param value {number} 级别数值
 * @param name {string} 级别名称(缩写)
 * @param nickName {string} 级别别名
 * @param color {string} 颜色
 * @param displayName {string} 显示名称
 * @constructor
 */
it.AlarmSeverity = function (value, name, nickName, color, displayName) {
    it.Base.call(this);
    this.value = value;
    this.name = name;
    this.nickName = nickName;
    this.color = color;
    this.displayName = displayName;
};
mono.extend(it.AlarmSeverity, it.Base, {
    IT_Alarm_Severity: true,
});
(function () {
    var s = it.AlarmSeverity;
    s.severities = new mono.List();
    s._vm = {};
    s._nm = {};
    s._cp = function (s1, s2) {
        if (s1 && s2) {
            var v = s1.value - s2.value;
            if (v > 0) return 1;
            if (v < 0) return -1;
            return 0;
        }
        if (s1 && !s2) return 1;
        if (!s1 && s2) return -1;
        return 0;
    };
    s.forEach = function (callbackFunction, scope) {
        s.severities.forEach(callbackFunction, scope)
    };
    s.getSortFunction = function () {
        return s._cp;
    };
    s.setSortFunction = function (sortFunction) {
        s._cp = sortFunction;
        s.severities.sort(sortFunction);
    }
    s.add = function (value, name, nickName, color, displayName) {
        var severity = new s(value, name, nickName, color, displayName);
        s._vm[value] = severity;
        s._nm[name] = severity;
        s.severities.add(severity);
        s.severities.sort(s._cp);
        return severity;
    };
    s.remove = function (name) {
        var severity = s._nm[name];
        if (severity) {
            delete s._nm[name];
            delete s._vm[severity.value];
            s.severities.remove(severity);
        }
        return severity;
    };
    s.CRITICAL = s.add(500, "Critical", "C", '#FF0000');
    s.MAJOR = s.add(400, "Major", "M", '#FFA000');
    s.MINOR = s.add(300, "Minor", "m", '#FFFF00');
    s.WARNING = s.add(200, "Warning", "W", '#00FFFF');
    s.INDETERMINATE = s.add(100, "Indeterminate", "N", '#C800FF');
    s.CLEARED = s.add(0, "Cleared", "R", '#00FF00');
    s.isClearedAlarmSeverity = function (severity) {
        return severity ? severity.value === 0 : false;
    };
    s.getByName = function (name) {
        return s._nm[name];
    };
    s.getByValue = function (value) {
        return s._vm[value];
    };
    s.clear = function () {
        s.severities.clear();
        s._vm = {};
        s._nm = {};
    };
    s.compare = function (severity1, severity2) {
        return s._cp(severity1, severity2);
    }
})();
/**
 * 管理业务告警,不同于mono.Alarm,it.Alarm是针对与it.Data的
 * @param id {string} 告警id,全局唯一
 * @param dataId {string} 发生告警对象的id
 * @param {it.AlarmSeverity} severity 告警级别
 * @param alarmType {it.AlarmType} 告警类型
 * @param description {string} 告警描述
 * @constructor
 */
it.Alarm = function (id, dataId, alarmSeverity, description, dateTime) {
    it.Base.call(this);
    this._id = id;
    this._dataId = dataId;
    this._alarmSeverity = alarmSeverity || it.AlarmSeverity.CRITICAL;
    this._dateTime = dateTime;
    this._description = description;
    if (!this._alarmSeverity.IT_Alarm_Severity) {
        throw 'alarmSeverity is not it.AlarmSeverity'
    }
};

mono.extend(it.Alarm, it.Base, {
    ___accessor: ['alarmSeverity', 'alarmType', 'description', 'dateTime'],

    IT_Alarm: true,

    getId: function () {
        return this._id;
    },

    getDataId: function () {
        return this._dataId;
    },

    fromJson: function (json) {
        json = json || "";
        if (typeof json === 'string') {
            json = JSON.parse(json);
        }
        this._id = json.id;
        this._dataId = json.dataId;
        this._alarmSeverity = it.AlarmSeverity.getByName(json.level);
        this._dateTime = json.time;
        this._description = json.description;
    },

});
/**
 * 告警状态
 * 告警状态分为两部分:自身的告警,上浮的告警
 * selfHighestAlarmSeverity - 自身告警的最高级别
 * selfAlarmCount - 自身告警的数量
 * propagateHighestAlarmSeverity - 上浮告警的最高级别
 * propagateAlarmCount - 上浮告警的数量
 * highestAlarmSeverity - 告警最高级别, 比较自身告警的最高级别和上浮告警的最高级别
 * alarmCount - 告警数量, 自身的告警数量加上上浮的告警数量
 * @param data {it.Data} 数据的data
 * @constructor
 */
it.AlarmState = function (data) {
    it.Base.call(this);
    this._data = data;
    this._selfHighestAlarmSeverity = null;
    this._selfAlarmCount = 0;
    this._propagateHighestAlarmSeverity = null;
    this._propagateAlarmCount = 0;
    this._highestAlarmSeverity = null;
    this._alarmCount = 0;
};
mono.extend(it.AlarmState, it.Base, {

    ___accessor: ['selfHighestAlarmSeverity', 'selfAlarmCount', 'propagateHighestAlarmSeverity', 'propagateAlarmCount', 'highestAlarmSeverity', 'alarmCount'],
    IT_Alarm_Status: true,
    clear: function () {
        this._selfHighestAlarmSeverity = null;
        this._selfAlarmCount = 0;
        this._propagateHighestAlarmSeverity = null;
        this._propagateAlarmCount = 0;
        this._highestAlarmSeverity = null;
        this._alarmCount = 0;
    }
});

/**
 * 告警的容器，所有的告警会要增加到容器里面管理
 * 告警的基本思路:只做涉及到SDK本身的功能,业务上的需求留给用户扩展,例如:新增告警数量,已经确认的告警数量等跟SDK无关,留给用户自己实现
 * * 告警状态的显示:
 *  1,只有自身告警: 整体染色 + 显示billboard
 *  2,只有上浮告警: 边框变色 + 显示billboard
 *  3,自身和上浮告警: 整体染色(自身告警) + 边框软色(上浮告警) + 显示billboard(按照最高级别告警来显示)
 * 告警渲染: scene -> category -> dataType -> data
 * 参数it.DataManager, 在it.DataManager 里面会自动创建一个it.AlarmManager.
 * @extend Base
 * @param {it.DataManager} dataManager
 * @param {it.SceneManager} sceneManager
 * @constructor
 */
it.AlarmManager = function (dataManager, sceneManager) {
    it.Base.call(this);
    this._dataManager = dataManager;
    this._sceneManager = sceneManager;

    /**
     *
     * @type {mono.List} 所有告警列表
     * @private
     */
    this._alarmList = new mono.List();

    /**
     *
     * @type {{}} 所有告警集合key是告警id, vlaue是告警对象
     * @private
     */
    this._alarmMap = {};

    /**
     *
     * @type {{}} key是data的id, value是集合(mono.List),该data的所有告警
     * @private
     */
    this._dataAlarms = {};

    /**
     * 需要重新计算告警状态的数据集合
     * @type {Array}
     * @private
     */
    this._dirtyDataAlarmState = [];

    /**
     * 告警渲染的 billboard 列表
     * @type {{}}
     * @private
     */
    this._alarmBillboardMap = {};

    /**
     * 告警渲染的 node 列表
     * @type {{}}
     * @private
     */
    this._alarmNodeMap = {};

    /**
     * 告警渲染的烟雾列表
     * @type {{}}
     * @private
     */
    this._alarmSmokeMap = {};

    /**
     * 告警增删动作监听
     * @type {mono.EventDispatcher}
     * @private
     */
    this._alarmManagerChangeDispatcher = new mono.EventDispatcher();

    /**
     * 告警更新动作监听
     * @type {mono.EventDispatcher}
     * @private
     */
    this._alarmPropertyChangeDispatcher = new mono.EventDispatcher();

    this.renderType = it.AlarmManager.RENDER_TYPE_DEFAULT;

    this._sceneManager.addSceneManagerChangeListener(this.handleSceneManagerChange, this, true);
    this._dataManager.addDataManagerChangeListener(this.handleDataManagerChange, this, true);
    this.addAlarmPropertyChangeListener(this.handleAlarmPropertyChange, this, true);
    this.addAlarmManagerChangeListener(this.handleAlarmManagerChange, this, true);

    this.intervalId = '';  //烟雾动画定时器
};

it.AlarmManager.RENDER_TYPE_DEFAULT = 0; //默认渲染告警方式, 自身染色, 上浮显示 billboard
it.AlarmManager.RENDER_TYPE_PAINT = 1; //全部染色告警方式, 自身和上浮都染色, 上浮不显示 billboard
it.AlarmManager.RENDER_TYPE_PAINT_BILLBOARD = 2; //全部染色告警方式, 自身和上浮都染色, 上浮显示 billboard

/**
 *
 */
mono.extend(it.AlarmManager, it.Base, {
    __accessor: ['removeAlarmWhenDataIsRemoved'],

    _name: 'AlarmBox',

    /**
     * 去的所有告警
     * @param matchFunction 过滤函数, 返回true,添加到结果
     * @param scope 过滤函数作用域
     * @returns {mono.List} 返回告警集合
     */
    getAlarms: function (matchFunction, scope) {

        return this._alarmList.toList(matchFunction, scope);
    },

    /**
     * 计算dirty列表中的data的上浮告警
     * @private
     */
    _calculateDataPropagateAlarmState: function () {

        while (this._dirtyDataAlarmState.length > 0) {
            var data = this._dirtyDataAlarmState.pop();
            this.calculateDataPropagateAlarmState(data);
        }

    },

    _setDataAlarmStateDirty: function (data) {
        data['_alarmRenderDirty'] = true;
    },
    _clearDataAlarmStateDirty: function (data) {
        delete data['_alarmRenderDirty'];
    },
    _isDataAlarmStateDirty: function (data) {
        return data['_alarmRenderDirty'];
    },

    /**
     * 将data的父亲加入到dirty列表中,需要重新计算上浮告警
     * @param data
     * @private
     */
    _dirtyParentDataAlarmState: function (data, isSkipRender) {

        var parent = this._dataManager.getParent(data);
        if (parent) {
            var self = this;
            var alarmState = parent.getAlarmState();
            var alarmCount = alarmState.getSelfAlarmCount();
            // 2017-10-27 可是如果parent自己有告警呢，parent被skip了导致parent自己的告警有不渲染了
            if (alarmCount <= 0) {
                parent.isSkipRender = isSkipRender;
            }else{
                parent.isSkipRender = null;
            }
            clearTimeout(parent._dirtyParentTimerId);
            parent._dirtyParentTimerId = setTimeout(function() {
                self._dirtyDataAlarmState.push(parent);
                if (self._dirtyDataAlarmState) {
                    self._calculateDataPropagateAlarmState();
                }
            }, 10);
        } else if (this._dirtyDataAlarmState) {
            this._calculateDataPropagateAlarmState();
        }
    },

    /**
     * 计算一个data的自身告警状态,如果状态发生变化,会同步会触发计算parentData的上浮告警状态
     * @param data {it.Data} data
     */
    calculateDataAlarmState: function (data) {

        var alarmStateValue = this.getDataAlarmState(data);//自身告警的数量和最高级别
        var alarmState = data.getAlarmState();
        var alarmCount = alarmState.getSelfAlarmCount();
        var highestAlarmSeverity = alarmState.getSelfHighestAlarmSeverity();
        //如果自身告警数量和总的告警数量相等并且最高级别也相等, 说明没有告警变化
        if (alarmCount == alarmStateValue.alarmCount
            && it.AlarmSeverity.compare(alarmStateValue.highestAlarmSeverity, highestAlarmSeverity) == 0) {
            return;
        }
        alarmState.setSelfHighestAlarmSeverity(alarmStateValue.highestAlarmSeverity);
        alarmState.setSelfAlarmCount(alarmStateValue.alarmCount);
        //2017-10-27 可是如果parent自己有告警，parent就不skip了，有可能child的告警先来，parent的告警后来，由于先来时就将skiprender设置成TRUE
        if (alarmStateValue.alarmCount > 0) {
            data.isSkipRender = null;
        }
        this._calculateDataAlarmState(data);
        
        
        //自己或者孩子阻止了告警 
        var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
        this._dirtyParentDataAlarmState(data, isSkipRender);

    },

    /**
     * 计算一个data的上浮告警状态,如果告警状态发生变化, 会同步会触发计算parentData的上浮告警状态
     * @param data
     */
    calculateDataPropagateAlarmState: function (data) {


        var children = this._dataManager.getChildren(data);
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        if (children) {
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var alarmState = child.getAlarmState();
                result.alarmCount += alarmState.getAlarmCount();
                result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getHighestAlarmSeverity())
            }
        }
        var alarmState = data.getAlarmState();
        var alarmCount = alarmState.getPropagateAlarmCount();
        var highestAlarmSeverity = alarmState.getPropagateHighestAlarmSeverity();
        //if (alarmCount == result.alarmCount
        //    && it.AlarmSeverity.compare(result.highestAlarmSeverity, highestAlarmSeverity) == 0) {
        //    return;
        //}
        alarmState.setPropagateAlarmCount(result.alarmCount);
        alarmState.setPropagateHighestAlarmSeverity(result.highestAlarmSeverity);
        this._calculateDataAlarmState(data);

        
        //自己或者孩子阻止了告警 
        var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
        this._dirtyParentDataAlarmState(data, isSkipRender);
    },


    /**
     * 计算节点上的总的告警
     * 告警数量等于自身告警加上上浮告警
     * 最高告警级别等于自身告警和上浮告警最高级别
     * @param alarmState
     * @private
     */
    _calculateDataAlarmState: function (data) {

        var alarmState = data.getAlarmState();
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        result.alarmCount = alarmState.getSelfAlarmCount() + alarmState.getPropagateAlarmCount();
        result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getSelfHighestAlarmSeverity())
        result.highestAlarmSeverity = this._getHighestAlarmSeverity(result.highestAlarmSeverity, alarmState.getPropagateHighestAlarmSeverity())
        alarmState.setAlarmCount(result.alarmCount);
        alarmState.setHighestAlarmSeverity(result.highestAlarmSeverity);
        this._setDataAlarmStateDirty(data);
        this.renderDataAlarm(data);
    },

    /**
     * 取得高级别的告警
     * @param severity1 {it.AlarmSeverity} severity1
     * @param severity2 {it.AlarmSeverity} severity2
     * @returns {it.AlarmSeverity} 返回severity1或者severity2
     * @private
     */
    _getHighestAlarmSeverity: function (severity1, severity2) {
        return it.AlarmSeverity.compare(severity1, severity2) > 0 ? severity1 : severity2;
    },

    renderDataAlarm: function (data) {
        //如果 isSkipRender=true, 并且不再强制渲染列表中, 跳过渲染过程
        if (data.isSkipRender && !this.isForceRenderData(data)) {
            return;
        }
        if (!this._sceneManager.isCurrentSceneInstance(data)) {
            this._setDataAlarmStateDirty(data);
            return;
        }
        var node = this._sceneManager.getNodeByDataOrId(data);
        if (!node && this._sceneManager.earthScene && this._sceneManager.earthScene.dataCenterNodeMap) {
            node = this._sceneManager.earthScene.dataCenterNodeMap[data.getId()]
        }
        if (node && this._isDataAlarmStateDirty(data)) {
            this._renderAlarm(data, node);
        } else if (!node) {
            this._setDataAlarmStateDirty(data);
        }
    },

    /**
     * 是否强制渲染 data
     * @param data
     * @returns {boolean}
     */
    isForceRenderData: function (data) {
        return false;
    },

    /**
     * 渲染告警
     * @param data {it.Data} data
     * @param node {mono.Data} node
     */
    _renderAlarm: function (data, node) {

        this._clearDataAlarmStateDirty(data);
        var scene = this._sceneManager.getCurrentScene();
        if (scene && scene.renderAlarm) {
            scene.renderAlarm(data, node);
            return;
        }
        var category = this._dataManager.getCategoryForData(data);
        if (category && category.renderAlarm) {
            category.renderAlarm(data, node);
            return;
        }
        var dataType = this._dataManager.getDataTypeForData(data);
        if (dataType && dataType.renderAlarm) {
            dataType.renderAlarm(data, node);
            return;
        }
        this.renderAlarm(data, node);
    },

    /**
     * 渲染告警
     * @param data
     * @param node
     */
    renderAlarm: function (data, node) {

        if (this.renderType == it.AlarmManager.RENDER_TYPE_PAINT) {

            //找到最高级别告警, 不区分是上浮还是自身
            var alarmState = data.getAlarmState();
            if (alarmState.getAlarmCount() > 0) {

                var alarmSeverity = alarmState.getHighestAlarmSeverity();
                this.paintDataColor(data, node, alarmSeverity);
            } else {

                this.clearDataColor(data, node);
            }
        } else if (this.renderType == it.AlarmManager.RENDER_TYPE_PAINT_BILLBOARD) {

            //找到最高级别告警, 不区分是上浮还是自身
            var alarmState = data.getAlarmState();
            if (alarmState.getAlarmCount() > 0) {

                var alarmSeverity = alarmState.getHighestAlarmSeverity();
                this.paintDataColor(data, node, alarmSeverity);
            } else {

                this.clearDataColor(data, node);
            }

            //上浮告警状态
            var parentData = this._dataManager.getParent(data);
            //如果parent为空,或者自身阻止了告警传播,并且总的告警数量大于0,那么显示或者更新告警billboard
            if (alarmState.getAlarmCount() > 0 && (!parentData || this._dataManager.isStopAlarmPropagation(data))) {

                this.showDataBillboard(data, node);
            } else if (this._alarmBillboardMap[data.getId()]) {
                this.hideDataBillboard(data, node);
            }
        } else {
            //自身告警状态
            var alarmState = data.getAlarmState();
            if (alarmState.getSelfAlarmCount() > 0) {

                this.paintDataColor(data, node);

                //增加烟雾效果 -- yxk
                this.createSmokeAlarm(data, node); 
            } else {

                this.clearDataColor(data, node);
                this.removeSmokeAlarm(data, node);
            }

            //上浮告警状态
            var parentData = this._dataManager.getParent(data);
            //如果parent为空,或者自身阻止了告警传播,并且总的告警数量大于0,那么显示或者更新告警billboard
            if (alarmState.getAlarmCount() > 0 && (!parentData || this._dataManager.isStopAlarmPropagation(data))) {

                this.showDataBillboard(data, node);
            } else if (this._alarmBillboardMap[data.getId()]) {
                this.hideDataBillboard(data, node);
            }
        }
    },

    createSmokeAlarm: function (data,node) {
        if (this._alarmSmokeMap[data.getId()]) {
            return;
        }
        var categoryId = this._dataManager.getCategoryForData(data).getId();
        if(categoryId != 'smoke')return;

        // var node = this._sceneManager.getNodeByDataOrId(data);
        var alarms = this.getAlarmsByDataOrId(data);
        if (alarms) {
            alarms = alarms._as;
            // var highest = -1, color, hasSmoke = false;
            for(var i=0; i<alarms.length;i++){
                alarm = alarms[i];
                if (alarm.alarmTypeId == 'smoke') {
                    var smokeNode = this.addSmoke(node, alarm._alarmSeverity.color);
                    smokeNode.setClient(it.SceneManager.CLIENT_IT_DATA, data);
                    smokeNode.setClient(it.SceneManager.CLIENT_IT_DATA_ID, data.getId());
                    this._alarmSmokeMap[data.getId()] = smokeNode;
                    this.startSmokeAnimation(this._alarmSmokeMap);
                    break;
                }
            }
            // alarms.forEach(function (alarm) {
            //     if (alarm.alarmTypeId == 'smoke') {
            //         hasSmoke = true;
            //         if(alarm._alarmSeverity.value>highest){
            //             highest = alarm._alarmSeverity.value;
            //             color = alarm._alarmSeverity.color;
            //         }
            //     }
            // }, this);
            // if(hasSmoke){
            //     var smokeNode = this.addSmoke(node, color);
            //     this._alarmSmokeMap[data.getId()] = smokeNode;
            //     this.startSmokeAnimation(data,smokeNode);
            // }
            
        }
    },
    //创建烟雾node
    createSmokeNode: function (color) {
        var smoke = new mono.Particle();
        var count = 200;
        for (var j = 0; j < count; j++) {
            smoke.vertices.push(new mono.Vec3());
        }
        smoke.verticesNeedUpdate = true;
        smoke.sortParticles = false;
        smoke.setStyle('m.size', 20);
        smoke.setStyle('m.color', color);
        smoke.setStyle('m.depthTest', false);
        smoke.setStyle('m.transparent', true);
        smoke.setStyle('m.opacity', 0.6);
        smoke.setClient('_alarmParticle', 'true');
        smoke.setStyle('m.texture.image', 'data:image/png;base64,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');
        return smoke;
    },

    //为烟感添加烟雾
    addSmoke: function (node, color) {
        var smoke = this.createSmokeNode(color);
        smoke.setParent(node);
        var bBox = node.getBoundingBox();
        var height = bBox.max.y - bBox.min.y;
        smoke.p(0, height * 3, 0);
        this._sceneManager.network3d.dataBox.add(smoke);
        return smoke;
    },
    updateSmoke: function (smokeNodeMap) {
        var network = this._sceneManager.network3d;
        return function () {
            for (var dataId in smokeNodeMap) {
                var smokeNode = smokeNodeMap[dataId];
                if (smokeNode.isVisible()) {
                    var count = smokeNode.vertices.length;
                    for (var i = 0; i < count; i++) {
                        var point = smokeNode.vertices[i];
                        point.y = Math.random() * 200;
                        point.x = Math.random() * point.y / 2 - point.y / 4;
                        point.z = Math.random() * point.y / 2 - point.y / 4;
                    }
                    smokeNode.verticesNeedUpdate = true;
                }
            }
            network.dirtyNetwork();
        }
    },
    startSmokeAnimation: function (smokeNodeMap) {
        this.removeSmokeAnimation();
        var arr = Object.keys(smokeNodeMap);
        if (arr.length == 0) {
            return;
        }
        var intervalId = setInterval(this.updateSmoke(smokeNodeMap), 100);
        this.intervalId = intervalId;
    },
    removeSmokeAlarm: function (data) {
        var smokeNode = this._alarmSmokeMap[data.getId()];
        if (!smokeNode) {
            return;
        }
        smokeNode.setParent(null);
        this._sceneManager.network3d.dataBox.remove(smokeNode);
        delete this._alarmSmokeMap[data.getId()];
        this.startSmokeAnimation(this._alarmSmokeMap);
    },
    removeSmokeAnimation: function () {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    },

    /**
     * 染色
     */
    paintDataColor: function (data, node, alarmSeverity) {

        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        var alarmState = data.getAlarmState();
        var alarmSeverity = alarmSeverity || alarmState.getSelfHighestAlarmSeverity();
        this._setNodeAlarmEffect(node, alarmSeverity);
        this._alarmNodeMap[node.getId()] = node;

        //同步到孩子, 例如机柜门
        var children = node.getChildren();
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                this._setNodeAlarmEffect(childTemp, alarmSeverity);
                this._alarmNodeMap[childTemp.getId()] = childTemp;
            }
        }
    },

    /**
     * 染色
     */
    clearDataColor: function (data, node) {

        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        //判断是否已经染色, 如果没有染色, 直接跳过
        if (!node.getStyle('alarm.m.ambient')) {
            return;
        }
        this._clearNodeAlarmEffect(node);
        delete this._alarmNodeMap[node.getId()];

        var children = node.getChildren();
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                this._clearNodeAlarmEffect(childTemp);
                delete this._alarmNodeMap[childTemp.getId()];
            }
        }
    },

    showDataBillboard: function (data, node) {

        var alarmState = data.getAlarmState();
        var alarmSeverity = alarmState.getHighestAlarmSeverity();
        var color = null;
        if (alarmSeverity) {
            color = alarmSeverity.color;
        }
        var alarmBillboard = null;
        if (this._alarmBillboardMap[data.getId()]) {
            alarmBillboard = this._alarmBillboardMap[data.getId()]
        } else {
            alarmBillboard = this._sceneManager.createEmptyBillboardById(data.getId());
            this.initAlarmBillboard(alarmBillboard, data);
            this._alarmBillboardMap[data.getId()] = alarmBillboard;
        }
        alarmBillboard.setStyle('m.texture.image', mono.ImageCache.AlarmBillboardImage);
        alarmBillboard.setStyle('m.color', color);
        alarmBillboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        this._setAlarmBillboardPositionAndSize(node, alarmBillboard);
    },

    hideDataBillboard: function (data, node) {

        this._sceneManager.removeBillboard(this._alarmBillboardMap[data.getId()]);
        delete this._alarmBillboardMap[data.getId()];
    },

    /**
     * 初始化 告警 billboard
     * @param billboard
     * @param data
     * @returns {*}
     */
    initAlarmBillboard: function (billboard, data) {
        billboard.setClient('_alarmBillboard', data);

        // 把机柜的告警billboard放到机柜的node上面去，方便后面取用
        // 2017.12.29 add by lyz
        var node = this._sceneManager.getNodeByDataOrId(data);
        node.setClient('_alarmBillboard', billboard);
    },

    _setAlarmBillboardPositionAndSize: function (node, alarmBillboard) {
        var position = node.getStyle('alarm.billboard.position');
        var boundingBox = node.getBoundingBox();
        var min = boundingBox.min;
        var max = boundingBox.max;
        var center = boundingBox.center();
        var size = boundingBox.size();
        if (position === 'topLeft') {
            alarmBillboard._position.set(min.x, max.y, center.z + 1);
        } else if (position === 'topRight') {
            alarmBillboard._position.set(max.x, max.y, center.z + 1);
        } else if (position === 'topBack') {
            alarmBillboard._position.set(center.x, max.y, min.z - 1);
        } else if (position === 'topFront') {
            alarmBillboard._position.set(center.x, max.y, max.z + 1);
        } else {
            alarmBillboard._position.set(center.x, max.y, center.z + 1);
        }

        var scale = node.getStyle('alarm.billboard.scale');
        if (scale instanceof mono.Vec3) {
            alarmBillboard._scale.copy(scale);
        } else {
            alarmBillboard._scale.set(size.x / 2, size.x / 2, 1);
        }

        var vertical = node.getStyle('alarm.billboard.vertical');
        alarmBillboard.setStyle('m.vertical', vertical);
    },

    _setNodeAlarmEffect: function (node, alarmSeverity) {
        //备份之前的状态
        var oldColor = node.getStyle('alarm.m.ambient') || node.getStyle('m.ambient');
        var color = alarmSeverity ? alarmSeverity.color : oldColor;
        node.setStyle('m.ambient', color);
        node.setStyle('m.color', color);
        node.setStyle('alarm.m.ambient', oldColor);
    },

    _clearNodeAlarmEffect: function (node) {
        var color = node.getStyle('alarm.m.ambient');
        node.setStyle('m.ambient', color);
        node.setStyle('m.color', color);
        node.setStyle('alarm.m.ambient', null);
    },

    /**************************  alarm begin *******************************/


    _add: function (alarm) {
        this._alarmList.add(alarm);
        this._alarmMap[alarm.getId()] = alarm;
        var alarms = this._dataAlarms[alarm.getDataId()];
        if (!alarms) {
            alarms = this._dataAlarms[alarm.getDataId()] = new mono.List();
        }
        alarms.add(alarm);
    },

    _remove: function (alarm) {
        this._alarmList.remove(alarm);
        delete this._alarmMap[alarm.getId()];
        var alarms = this._dataAlarms[alarm.getDataId()];
        if (alarms) {
            alarms.remove(alarm);
        }
        if (alarms.size() == 0) {
            delete this._dataAlarms[alarm.getDataId()];
        }
    },

    /**
     * 取得告警
     * @param alarmOrId {string|it.Alarm} 告警或告警id
     * @returns {it.Alarm}
     */
    getAlarm: function (alarmOrId) {
        if (!alarmOrId) {
            return null;
        }
        var alarm = null;
        if (alarmOrId.IT_Alarm) {
            alarm = this._alarmMap[alarmOrId.getId()];
        } else {
            alarm = this._alarmMap[alarmOrId];
        }
        return alarm;
    },


    /**
     * 增加告警
     * @param {it.Alarm} alarm 告警对象
     */
    add: function (alarm) {
        if (!alarm) {
            throw 'alarm is null or undefined'
        }
        if (!alarm.getId()) {
            throw 'alarm`s id is empty'
        }
        if (!alarm.getDataId()) {
            throw 'alarm`s dataId is empty'
        }
        if (!alarm.IT_Alarm) {
            throw "alarm`s class is not it.Alarm";
        }
        var a = this._alarmMap[alarm.getId()];
        if (a) {
            throw 'alarm`s id repeat';
        }
        //如果data为空,不做强制校验,等data增加时再处理
        var d = this._dataManager.getDataById(alarm.getDataId())
        if (!d) {
            alarm.error = 'data is not exist';
            console.warn(alarm.error)
        }
        this._add(alarm);
        this._alarmManagerChangeDispatcher.fire({
            kind: 'add',
            data: alarm
        });
        alarm.addPropertyChangeListener(this.handleAlarmDataPropertyChange, this);
    },

    /**
     * 通过json创建alarms
     * @param json
     */
    addAlarmFromJson: function (json) {

        var jsonObjects = $Util.toJsonArray(json);
        var i = 0, len = jsonObjects.length;
        for (; i < len; i++) {
            var jsonObject = jsonObjects[i];
            var alarm = new it.Alarm();
            alarm.fromJson(jsonObject);
            this.add(alarm);
        }
    },

    /**
     * 删除告警
     * @param {string|it.Alarm} alarm对象或者告警id
     * return alarm
     */
    remove: function (alarmOrId) {
        if (!alarmOrId) {
            throw 'alarmOrId is null or undefined'
        }
        var alarm = null;
        if (alarmOrId.IT_Alarm) {
            alarm = this._alarmMap[alarmOrId.getId()]
        } else {
            alarm = this._alarmMap[alarmOrId]
        }
        if (!alarm) {
            console.warn('alarm is not exist');
            return;
        }
        this._remove(alarm);
        alarm.removePropertyChangeListener(this.handleAlarmDataPropertyChange, this);
        this._alarmManagerChangeDispatcher.fire({
            kind: 'remove',
            data: alarm
        });
        return alarm;
    },

    clear: function () {
        var list = this._alarmList.toList();
        this._alarmList.clear();
        this._alarmMap = {};
        this._dataAlarms = {};
        this._dirtyDataAlarmState = [];
        this._alarmManagerChangeDispatcher.fire({
            kind: 'clear',
            datas: list
        });
        return list;
    },
    /**************************  alarm end *******************************/

    /**************************  data begin *******************************/

    /**
     * 根据数据或者id取得所有相关告警
     * @param dataOrId 数据或着id
     * @returns {*|mono.List}
     */
    getAlarmsByDataOrId: function (dataOrId) {

        if (!dataOrId) {
            return [];
        }
        var dataId = dataOrId;
        if (dataOrId.IT_Data) {
            dataId = dataOrId.getId();
        }
        return this._dataAlarms[dataId];
    },

    /**
     * 根据数据或者id移除所有相关告警
     * @param dataOrId 数据或着id
     */
    removeAlarmsByDataOrId: function (dataOrId) {

        var alarms = this.getAlarmsByDataOrId(dataOrId);
        if (alarms) {
            alarms = alarms.toList();
            alarms.forEach(this.remove, this);
        }
        return alarms;
    },

    /**
     * 根据告警或者id取得相关数据
     * @param alarmOrId {string|it.Alarm}  告警或者id
     * @returns {it.Data}
     */
    getDataByAlarmOrId: function (alarmOrId) {

        var alarm = this.getAlarm(alarmOrId);
        if (!alarm) {
            return null;
        }
        var dataId = alarm.getDataId();
        return this._dataManager.getDataById(dataId);
    },

    /**
     *  取的数据自身的的告警状态, 数量和最高级别
     * @param data
     * @returns {{highestAlarmSeverity: null, alarmCount: number}}
     */
    getDataAlarmState: function (data) {
        var result = {
            highestAlarmSeverity: null,
            alarmCount: 0,
        };
        var alarms = this.getAlarmsByDataOrId(data);
        if (alarms) {
            result.alarmCount = alarms.size();
            alarms.forEach(function (alarm) {
                if (!result.highestAlarmSeverity) {
                    result.highestAlarmSeverity = alarm.getAlarmSeverity();
                } else {
                    var severity = alarm.getAlarmSeverity();
                    if (it.AlarmSeverity.compare(severity, result.highestAlarmSeverity) > 0) {
                        result.highestAlarmSeverity = severity;
                    }
                }
            })
        }
        return result;
    },

    /**************************  data end *******************************/



    /**************************  alarm change handler begin *******************************/
    /**
     * 告警的增删，同步data对象上的告警状态
     * @param e
     */
    handleAlarmManagerChange: function (e) {
        if (e.kind === 'add') {
            var alarm = e.data;
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                var self = this;
                clearTimeout(data._calculateTimerId);
                data._calculateTimerId = setTimeout(function () {
                  self.calculateDataAlarmState(data);
                },100);

            }
        } else if (e.kind === 'remove') {
            var alarm = e.data;
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                var self = this;
                // clearTimeout(data._calculateTimerId);
                // data._calculateTimerId = setTimeout(function () {
                self.calculateDataAlarmState(data);
                // })
            }
        } else if (e.kind === 'clear') {

            //清除的所有告警
            var alarms = e.datas;
            if (alarms && alarms.size() > 0) {
                //找到所有dataId
                var dataArr = this._dataManager.getDatas();
                if (dataArr && dataArr.length > 0) {
                    var len = dataArr.length;
                    //清除告警标记
                    for (var i = 0; i < len; i++) {
                        var data = dataArr[i];
                        var state = data.getAlarmState();
                        if (state.getAlarmCount()) {
                            state.clear();
                        }
                    }
                }
                for (var id in this._alarmBillboardMap) {
                    this._sceneManager.removeBillboard(this._alarmBillboardMap[id]);
                }
                this._alarmBillboardMap = {};
                for (var id in this._alarmNodeMap) {
                    this._clearNodeAlarmEffect(this._alarmNodeMap[id]);
                }
                this._alarmNodeMap = {};
                for (var id in this._alarmSmokeMap) {
                    var data = this.sceneManager.dataManager.getDataById(id);
                    this.removeSmokeAlarm(data);
                }
                this._alarmSmokeMap = {};
            }
        }
    },


    /**
     * 告警的属性变化 FIXME
     * @param e
     */
    handleAlarmDataPropertyChange: function (e) {
        this._alarmPropertyChangeDispatcher.fire(e);
    },
    /**
     * 告警的属性变化处理：级别，确认状态，清除状态
     * @param e
     */
    handleAlarmPropertyChange: function (e) {
        var alarm = e.source;
        if (e.property === "alarmSeverity") {
            var data = this._dataManager.getDataById(alarm.getDataId());
            if (data) {
                this.calculateDataAlarmState(data);
            }
        }
    },
    /**************************  alarm change handler end *******************************/

    /**************************  data change handler begin *******************************/
    /**
     * 数据的变更
     * 传入的是node
     * @param e
     */
    handleDataManagerChange: function (e) {
        if (e.kind === 'add') {
            //排除掉先加告警,后加data,告警无法加载的情况
            this.calculateDataAlarmState(e.data);
        } else if (e.kind === 'remove') {
            //清除data的告警
            var data  = e.data
            this.removeAlarmsByDataOrId(data);
            //自己或者孩子阻止了告警
            var isSkipRender = this._dataManager.isStopAlarmPropagation(data) || data.isSkipRender;
            this._dirtyParentDataAlarmState(data, isSkipRender);
        } else if (e.kind === 'clear') {
            //FIXME dataManager暂时没有`clear`方法
            //for (var dataId in dataIds) {
            //    var data = this._dataManager.getDataById(dataId);
            //    if (data) {
            //        data.getAlarmState().clear();
            //    }
            //}
            ////清除所有告警
            //this.clear();
        }
    },

    /**************************  data change handler end *******************************/

    /**************************  scene change handler begin *******************************/
    /**
     * 场景变更
     * 传入的参数是node
     * @param e
     */
    handleSceneManagerChange: function(e) {
        var self = this;
        if (e.kind === 'add') {
            var node = e.data;
            var data = this._sceneManager.getNodeData(node);
            // setTimeout(function () {
            self.renderDataAlarm(data);
            // }, 10)
        } else 
        if (e.kind === 'change') {
            var node = e.data;
            var data = this._sceneManager.getNodeData(node);
            // var data = e.rootData;
            if (data) {
                this._setDataAlarmStateDirty(data);
                this.renderDataAlarm(data);
            }
        }
    },

    /**************************  scene change handler end *******************************/



    addAlarmManagerChangeListener: function (listener, scope, ahead) {
        this._alarmManagerChangeDispatcher.add(listener, scope, ahead);
    },

    removeAlarmManagerChangeListener: function (listener, scope) {
        this._alarmManagerChangeDispatcher.remove(listener, scope);
    },
    addAlarmPropertyChangeListener: function (listener, scope, ahead) {
        this._alarmPropertyChangeDispatcher.add(listener, scope, ahead);
    },

    removeAlarmPropertyChangeListener: function (listener, scope) {
        this._alarmPropertyChangeDispatcher.remove(listener, scope);
    },


    /**
     * 实时计算高级功能数量
     * 找到所有的孩子, 遍历累加,比较耗时.
     * @param data
     * @returns {number}
     */
    getAlarmCountNow: function (data) {


        if (!data) {
            return 0;
        }
        var result = this._dataManager.getDescendants(data);
        if (!result) {
            return 0;
        }
        var count = 0;
        result.forEach(function (item) {
            count += item.getAlarmState().getSelfAlarmCount();
        })
        return count;
    }
});
/**
 * 告警上浮的控制.
 * 每一次上浮增加一个dirty标记.如果上浮到了父亲,那么父亲的父亲dirty置位,需要继续计算.
 * 判断是否有dirty节点,继续计算.
 * 告警上浮原理
 * 同步告警状态到节点上: 告警的增删改,告警状态的变化,数据的增删改,场景变化
 * 告警的增删改,告警状态变化 - 同步告警状态
 * 数据的增删改 - 删除数据时,触发删除告警动作(触发同步告警)
 * 场景变化 - 监听node变化,同步告警状态
 * @param {it.DataManager} dataManager
 * @param {it.SceneManager} sceneManager
 * @param {it.AlarmManager} alarmManager
 * @constructor
 *
 */
it.AlarmStatePropagator = function (dataManager, sceneManager, alarmManager) {
    this._dataManager = dataManager;
    this._sceneManager = sceneManager;
    this._alarmManager = alarmManager;
    this.dataBox = alarmManager.dataBox;
    this.alarmBox = alarmManager.alarmBox;
    mono.AlarmStatePropagator.call(this, this.dataBox, 'alarmState');
    this.dataBox.setAlarmStatePropagator(this);
    this.childrenAlarms = [];
};

mono.extend(it.AlarmStatePropagator, mono.AlarmStatePropagator, {

    propagateToTop: function (data) {
        //for (var i = 0; i < this.childrenAlarms.length; i++) {
        //    this.alarmBox.remove(this.childrenAlarms[i]);
        //}
        //this.childrenAlarms = [];
        var result = true;
        result = this.propagateToParent(null, data);
        while (data && data.getParent() && result !== false) {
            result = this.propagateToParent(data, data.getParent());
            data = data.getParent();
        }
    },

    propagateToParent: function (child, parent) {
        var childData = child == null ? null : it.SceneManager.getNodeData(child);
        var parentData = parent == null ? null : it.SceneManager.getNodeData(parent);
        if (!parentData) {
            return false;
        }
        return this.dataPropagateToParent(childData, parentData, child, parent);
    },


    dataPropagateToParent: function (childData, parentData, child, parent) {
        return this.dataPropagateToParentForRoom(childData, parentData, child, parent);
    },


    dataPropagateToParentForRoom: function (childData, parentData, child, parent) {
        //判断child已经阻止了上浮，禁止一切后续动作
        if (this.isStop(childData)) {
            return false;
        }

        if (!parentData.getAlarmState) { // 对于link没有AlarmState
            return false;
        }

        if (parent.getClient('modelParent')) {
            parent = parent.getClient('modelParent')
        }

        //清除旧的上浮告警，否则getHighestOverallAlarmSeverity会干扰
        parentData.getAlarmState().setPropagateSeverity(null);
        parent.getAlarmState().setPropagateSeverity(null);
        var result = parentData.getAlarmState().getHighestOverallAlarmSeverity();
        var children = parentData.getChildren();//this.dataManager.getChildren(parentData);
        var length = children.size();
        for (var i = 0; i < length; i++) {
            var childDataTemp = children.get(i);
            var severity = childDataTemp.getAlarmState().getHighestOverallAlarmSeverity();
            if (it.AlarmSeverity.compare(severity, result) > 0) {
                result = severity;
            }
        }
        //设置新的上浮告警级别
        //如果是机柜,加到孩子里面
        parentData.getAlarmState().setPropagateSeverity(result);
        if (parent.getClient('complexNode')) {
            var target = parent.getClient('complexNode')!='unload'&&parent.getClient('complexNode').getParent() ? parent.getClient('complexNode') : parent.getClient('simpleNode');
            target.getAlarmState().setPropagateSeverity(result);
        }


        this.modelChildAlarmSyn(childData, parentData, child, parent);

        //判断是否需要继续上浮
        var parentDataType = parentData == null ? null : this.dataManager.getDataTypeForData(parentData);
        if (!parentDataType) {
            return false;
        }
        if (parentDataType.isStopAlarmPropagationable()) {
            return false;
        }
        var parentCategory = this.dataManager.getCategoryForData(parentData);
        if (!parentCategory) {
            return !parentDataType.isStopAlarmPropagationable();
        }
        if (parentCategory.isStopAlarmPropagationable()) {
            return false;
        }
        return true;
    },

    isStop: function (childData) {
        if (childData) {
            var childDataType = this.dataManager.getDataTypeForData(childData);
            if (childDataType) {

                if (childDataType.isStopAlarmPropagationable()) {
                    return true;
                }
                var childCategory = this.dataManager.getCategoryForData(childData);
                if (childCategory && childCategory.isStopAlarmPropagationable()) {
                    return true;
                }
            }
        }
        return false;
    },

    modelChildAlarmSyn: function (childData, parentData, child, parent) {
        if (parent.getClient('complexNode')) {
            parent = parent.getClient('complexNode')!='unload'&&parent.getClient('complexNode').getParent() ? parent.getClient('complexNode') : parent.getClient('simpleNode');
        }
        var children = parent.getChildren();
        var length = children.size();
        var parentNativeSeverity = parent.getAlarmState().getPropagateSeverity();
        for (var i = 0; i < length; i++) {
            var childTemp = children.get(i);
            if (childTemp.getClient('modelParent')) {
                var alarmId = 'child_alarm_' + childTemp.getId();
                if (parentNativeSeverity) {
                    var alarm = this.alarmBox.getDataById(alarmId);
                    if (!alarm) {
                        alarm = new mono.Alarm(alarmId, childTemp.getId(), parentNativeSeverity);
                        this.alarmBox.add(alarm);
                    } else {
                        alarm.setAlarmSeverity(parentNativeSeverity);
                    }
                    childTemp.getAlarmState().setPropagateSeverity(parentNativeSeverity);
                } else {
                    this.alarmBox.removeById(alarmId);
                    childTemp.getAlarmState().setPropagateSeverity(null);
                }
            }
        }
    }
});


/**
 * 此类是EventHandler的一个默认的实现，其实现功能如下：
 * 1、鼠标点击某个对象时，镜头会移过去；
 * 2、点击空白处回到上一级；
 * 3、点击地板镜头移过去；
 * 4、对于虚化的对象都不可点中；
 * 5、对于透明的对象，不去处理dblclick事件；
 */

var $DefaultEventHandler = function (sceneManager){ // 这个类用户可以重载实现自己的逻辑；
	$EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    if(!sceneManager){
        console.log('sceneManager can not be null!');
    }
    this.mode = "lookat"; // lookat move,
    this.filterFunction = null;
    this.defaultPostion = null;
    this.defaultTarget = null;
    this.defaultLookAtDistance = 2000;
    this.lookAtDistanceFunction = null;
    this.isLookAtFunction = null;
    this.afterLookAtFunction = null;
    this.afterLookAtFinishedFunction = null;
    this._afterLookAtListener = []; //通过注册lister比通过重写afterLookAtFunction要更合理一点，特别是有多个实现的话
    this._afterLookAtFinishedListener = [];//镜头移动好后执行,比重写afterLookAtFinishedFunction
    this.box3d = sceneManager.network3d.getDataBox();
    this.withOutAnimate = false;
    this.lookAtWithOutMoveCamera = true; // 调用lookAt时是不是移动镜头(这里比较拗)，也就是只是处理setFocus的动作。因为有的动作双击过去不想移动镜头
    this.handleDoubleClickBackgroundFunction = null;
    this.cameraInfoStack = [];
};

mono.extend($DefaultEventHandler,$EventHandler,{
    
    setDefaultPositionAndTarget : function(position,target){
        this.defaultPostion = position;
        this.defaultTarget = target;
    },

    getDefaultVirtual : function(){
       return this.sceneManager.viewManager3d.getDefaultVirtualMaterialFilter();
    },

    setMode : function(mode){//lookat, move
        this.mode = mode;
    },

    getCamera : function(node){
        var sceneView = this.sceneManager.getSceneViewByNode(node);
        if (sceneView && sceneView.getCamera && sceneView.getCamera()) {
            return sceneView.getCamera();
        }else{
            return this.sceneManager.network3d.getCamera();
        }
    },

    /**
     * 是否是需要俯视，否则的话是正视，默认的是，如果boundingBox中某一边超过1000时就俯视
     * @param node
     * @returns {boolean}
     */
    isLookAtWithAngle : function(node){
        if (!node) {
            return false;
        }
        var bb = it.Util.getBoundingBox(node);
        // if(node && node.getBoundingBox()){
        //     var boundingBox = node.getBoundingBox();
        //     if(boundingBox.max.x - boundingBox.min.x > 500
        //         || boundingBox.max.y - boundingBox.min.y > 500
        //         || boundingBox.max.z - boundingBox.min.z > 500){
        //         return true;
        //     }
        // }
        var data = this.sceneManager.getNodeData(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'building') { // 有些建筑很小 -- 2017-07-06
            return true;
        }
        if (bb && (bb.size().x > 500 || bb.size().y > 500 || bb.size().z > 500)) {
            return true;
        }
        return false;
    },

    /**
     * 计算lookAt3D对象的最佳距离
     * 注意：得考虑scale，因为scale后，boudingbox的size并不会做相应的scale
     *  withOutScale为true时不考虑Scale，否则考虑，因此默认的情况下都会考虑scale
     * 需要考虑到fov
    */
    getElementPerfectDistance : function(node,withOutScale){
        if (!node) {
            return 100;
        }
        if(withOutScale == true){
            withOutScale = true;
        }else{
            withOutScale = false;
        }
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var h = 100;
        // var bb = node.getBoundingBox();//20160914
        var bb = it.Util.getBoundingBox(node); // update 2017-07-06 
        // var bb = node.getBoundingBoxWithChildren();
        if (bb) {
            var d_y = bb.max.y - bb.min.y;
            var d_x = bb.max.x - bb.min.x;
            var d_z = bb.max.z - bb.min.z; // 加上Z分量 add 2017-09-08 Kevin
            if(!withOutScale){
                d_y = d_y * node.getScaleY();
                d_x = d_x * node.getScaleX();
            }
            if (d_y > d_x) {
                h = d_y;
            } else {
                h = d_x;
            }
            if (d_z > h) {
                h = d_z;
            }
        }
        var l = h / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
        var offset = this.getElementPerfectDistanceOffset(node);
        l += offset;
        return l;
    },

    getElementPerfectDistanceOffset : function(node){
        return 50;
    },

    getElementPerfectFrontPositionOffsetY : function(node){
        var data = this.sceneManager.getNodeData(node);
        var category = this.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'equipment') {
            return 0;
        }
        return 20;
    },

    getElementPerfectFrontPosition : function(node){
        if (!node) return null;
        var l = this.getElementPerfectDistance(node);
        if (l < 100) {
            l = 100;
        }

        // 2017-11-02 由于node的建模的中心坐标可能并不是其真正的中心点，特别是对于roon，用node.frontWorldPositions算的总是不正确
        // var perfectPosition = node.frontWorldPosition(l); //都改成正视
        var nodeCenter = this.getNodeCenterPosition(node);
        var distance = l > 0 ? l : 1;
        var perfectPosition = nodeCenter.add(node.frontDirection().multiplyScalar(distance));
        var offsetY = this.getElementPerfectFrontPositionOffsetY(node) || 0;
        perfectPosition.y = perfectPosition.y + offsetY; 
        return perfectPosition;
    },

    /**
     * 是中心点的正前方，很多情况下，3D对象自身的中心点不是其原点
     * @param node
     * @param v 表示的是有俯视的角度，如果为空就表示正视，且正前方
     * @returns {*}
     */
    getElementPerfectFrontPositionForNodeCenterPosition : function(node,withAngle){
        if (!node) return null;
        var l = this.getElementPerfectDistance(node);
        if (l < 100) {
            l = 100;
        }
//        var perfectPosition = node.frontWorldPosition(l); //都改成正视
//        perfectPosition.y = perfectPosition.y + 20;
//        return perfectPosition;
        var pos = this.getNodeCenterPosition(node);
        var v = null;
        if(withAngle == undefined){
            withAngle = true;
        }
        if(withAngle){
            v = new mono.Vec3(0, 1, 2); //俯视30度
        }
        if(v){
            return pos.add(node.direction(v).multiplyScalar(l));
        }else{
            return pos.add(node.frontDirection().multiplyScalar(l));
        }
    },

    /**
     * 获取node的中心点，有些时候position并不是其真正的中心点，有可能对象自身的坐标并不是从中间开始的
     * 并且要注意缩放的情况，因为不管是否缩放，boundingBox的大小是不变的，所以的*Scale
     * 注意：如果像pathNode这样的对象，path完全用的是世界坐标，那这样算出来的中心点（其实是没有错的）
     * @param node
     * @returns {position}
     */
    getNodeCenterPosition : function(node){
        if(!node) return null;
        // var boundingBox = node.getBoundingBox(); // update 20160914
        var boundingBox = it.Util.getBoundingBox(node);  // update 2017-07-06 
        // var boundingBox = node.getBoundingBoxWithChildren();
        var offx = 0;
        var offy = 0;
        var offz = 0;
        if (boundingBox && boundingBox.max && boundingBox.min) {
            offx = (boundingBox.max.x + boundingBox.min.x)/2*node.getScaleX();
            offy = (boundingBox.max.y + boundingBox.min.y)/2*node.getScaleY();
            offz = (boundingBox.max.z + boundingBox.min.z)/2*node.getScaleZ();
        }
        var position = node.getWorldPosition();
        position.setX(position.x + offx);
        position.setY(position.y + offy); 
        position.setZ(position.z + offz);
        return position;
    },

    getCameraPositionForLookAt: function(node) {
        var h = this.getElementPerfectDistance(node); 
        // 2017-11-02 有可能node的坐标原点不是其中心点，特别是对应区域、房间这样的对象
        // return node.worldPosition(new mono.Vec3(0, 1, 2), h); 
        var nodeCenter = this.getNodeCenterPosition(node);
        return nodeCenter.add(node.direction(new mono.Vec3(0, 1, 2)).multiplyScalar(h));
    },

    getCameraTargetAndPositionByNode : function(node){
        return null;
    },

    /**
     * 移动镜头看某个node
     */
    moveCameraForLookAtNode: function(node, callback, offset) {
        if (!node) return;
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var tarAngPos = this.getSavedCameraInfoByNode(node)||this.getCameraTargetAndPositionByNode(node);
        var target = null;
        var f_position = null;
        if (tarAngPos && tarAngPos.target && tarAngPos.position) {
            target = tarAngPos.target;
            f_position = tarAngPos.position;
        } else {
            var w_p = this.getNodeCenterPosition(node);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            var bb = it.Util.getBoundingBox(node); // update 2017-07-06
            target = new mono.Vec3(w_p.x, w_p.y, w_p.z);
            f_position = this.getElementPerfectFrontPosition(node);
            if (this.isLookAtWithAngle(node)) {
                var h = this.getElementPerfectDistance(node); //如果旋转了则有问题
                // f_position = node.worldPosition(new mono.Vec3(0, 1, 2), h); //4000
                f_position = this.getCameraPositionForLookAt(node);
                if (bb && (bb.max.y + bb.min.y) != 0) { //像pathNode这样的管道，建模的中心点与其自身的中心点差太多时
                    f_position.y = f_position.y + (bb.max.y + bb.min.y) / 2
                }
                var datalX = 0,
                    datalZ = 0;
                if (node.getRotationY()) {
                    datalX = h * Math.sin(node.getRotationY());
                }
                f_position.x = target.x + datalX; // 对应lookAt楼层对象，可能会有些歪，这是因为楼层的主对象的中心点的问题，其实应该以地板为标准
            }
            if (offset) {
                f_position.x += offset.x;
                f_position.y += offset.y;
                f_position.z += offset.z;
            }
        }

        function callbackWrap() {
            // adjustBounds();
            if (callback) {
                callback();
            }
        };

        it.Util.playCameraAnimation(camera, f_position, target, 1500, callbackWrap);

    },

    /**
     * 直接调整好镜头的位置，没有动画(如场景加载完后马上设置位置，还有就是中间计算过程中)
     * @param node
     */
    lookAtNodeWithOutAnimate: function(node) {
        if (!node) return;
        if (!(node instanceof mono.Element)) {
            return;
        }
        var camera = this.getCamera(node); // 17-08-11 this.sceneManager.network3d.getCamera();
        var cameraTarAndPos = this.getSavedCameraInfoByNode(node) || this.getCameraTargetAndPositionByNode(node);
        if (cameraTarAndPos && cameraTarAndPos.target && cameraTarAndPos.position) {
            camera.setPosition(cameraTarAndPos.position.x, cameraTarAndPos.position.y, cameraTarAndPos.position.z);
            camera.lookAt(cameraTarAndPos.target.x, cameraTarAndPos.target.y, cameraTarAndPos.target.z);
        } else {
            var w_p = this.getNodeCenterPosition(node);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            var f_position = this.getElementPerfectFrontPosition(node);
            if (this.isLookAtWithAngle(node)) {
                var h = this.getElementPerfectDistance(node); //如果旋转了则有问题
                f_position = node.worldPosition(new mono.Vec3(0, 1, 1), h); //4000
                var datalX = 0,
                    datalZ = 0;
                if (node.getRotationY()) {
                    datalX = h * Math.sin(node.getRotationY());
                    datalZ = h * (1 - Math.cos(node.getRotationY()));
                }
                f_position.x = w_p.x + datalX; // 对应lookAt楼层对象，可能会有些歪，这是因为楼层的主对象的中心点的问题，其实应该以地板为标准
                f_position.z = f_position.z - datalZ;
            }
            camera.setPosition(f_position.x, f_position.y, f_position.z);
            camera.lookAt(w_p.x, w_p.y, w_p.z);
        }
    },

    /**
     * 移动镜头，使之看到nodes中所有的element
     * @param nodes
     * @returns {null}
     */
    lookAtElements : function(nodes,callback){
        if(!nodes || nodes.length < 1){
            return null;
        }
        if(nodes.length === 1){
            this.lookAt(nodes[0]);
            return;
        }
        this.sceneManager.viewManager3d.setCameraDistance(null,10000);
        var camera = this.getCamera(nodes[0]); // 17-08-11  this.sceneManager.network3d.getCamera();
        var minx,miny,minz,maxx,maxy,maxz;
        for(var i = 0 ; i < nodes.length ; i++){
            var node = nodes[i];
            if(!node){
                continue;
            }
            var bp = node.getBoundingBox()||{min:{x:0,y:0,z:0},max:{x:0,y:0,z:0}}; //只考虑中心点还不够准确，还需要考虑到boundingBox，这样才能真的全部包围
            var wp = node.getWorldPosition();
            if(!minx || minx > (wp.x+bp.min.x)){
                minx = wp.x+bp.min.x;
            }
            if(!miny || miny > (wp.y + bp.min.y)){
                miny = wp.y + bp.min.y;
            }
            if(!minz || minz > (wp.z + bp.min.z)){
                minz = wp.z + bp.min.z;
            }
            if(!maxx || maxx < (wp.x + bp.max.x)){
                maxx = wp.x + bp.max.x;
            }
            if(!maxy || maxy < (wp.y + bp.max.y)){
                maxy = wp.y + bp.max.y;
            }
            if(!maxz || maxz < (wp.z + bp.max.z)){
                maxz = wp.z + bp.max.z;
            }
        }
        var target = new mono.Vec3(minx+(maxx-minx)/2,miny+(maxy-miny)/2,minz+(maxz-minz)/2);
        // var maxLen = maxx - minx; // 应该是算斜边
        // if(maxLen < (maxy-miny)){
        //     maxLen = (maxy-miny);
        // }
        // if(maxLen < (maxz - minz)){
        //     maxLen = (maxz - minz);
        // }
        var maxLen = Math.sqrt((maxx - minx)*(maxx - minx) + (maxy-miny)*(maxy-miny));
        var length = maxLen / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
        var offset = 50;
        length+= offset;
        if(length < 500){
            length = 500;
        }
        var up = 50;
        if(maxy-miny < 300){ //在这个范围内，我们认为是同一层，所以俯视。为何是300(比较大哦)，因为一个机柜就有200多，而maxy是从最上方开始算
            up = length ;// up = 500; //应该差不多45度
        }
        var  f_position = new mono.Vec3(target.x, target.y+up, target.z+length);
        it.Util.playCameraAnimation(camera, f_position, target, 1500, callback);
    },

    getCameraTarAndPosForLookAtNodes: function(nodes, angle, offset) {
        if (!nodes || nodes.length < 1) {
            return null;
        }
        if (nodes.length == 1) {
            // this.moveCameraForLookAtNode(nodes[0], callback, offset);
            var w_p = this.getNodeCenterPosition(nodes[0]);
            if (!w_p) {
                w_p = new mono.Vec3(0, 0, 0);
            }
            // var bb = nodes[0].getBoundingBox();
            var bb =  it.Util.getBoundingBox(nodes[0]);// update 2017-07-06 
            var target = new mono.Vec3(w_p.x, w_p.y, w_p.z);
            var f_position = this.getElementPerfectFrontPosition(nodes[0]);
            if (this.isLookAtWithAngle(nodes[0])){
                var h = this.getElementPerfectDistance(nodes[0]); //如果旋转了则有问题
                f_position = this.getCameraPositionForLookAt(nodes[0]);
                if (bb && (bb.max.y + bb.min.y) != 0) { //像pathNode这样的管道，建模的中心点与其自身的中心点差太多时
                    f_position.y = f_position.y + (bb.max.y + bb.min.y)/2
                }
                var datalX = 0,datalZ = 0;
                if (nodes[0].getRotationY()) {
                    datalX = h*Math.sin(nodes[0].getRotationY());
                }
                f_position.x = target.x + datalX; // 对应lookAt楼层对象，可能会有些歪，这是因为楼层的主对象的中心点的问题，其实应该以地板为标准
            }
            return {
                target: w_p,
                position: f_position
            };
        }
        var camera = this.getCamera(nodes[0]); // 17-08-11 this.sceneManager.network3d.getCamera();
        var bb = this.computeNodesBoundingBox(nodes);
        if (!bb) {
            return null;
        }
        var center = bb.center();
        var sub1 = new mono.Vec3(0, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
        var sub2 = new mono.Vec3(bb.max.x - bb.min.x, 0, 0, 0);
        var sub = sub1.clone();
        if (sub.length() < sub2.length()) {
            sub = sub2.clone();
        }
        var position;
        if (angle) {
            var l = sub1.length();
            sub1.y = sub1.z * Math.tan(angle / 180 * Math.PI);
            sub1.setLength(l);
        }
        position = new mono.Vec3().addVectors(center, sub1.multiplyScalar(0.5));
        var fov = camera.fov,
            aspect = camera.aspect;
        var length = sub.length() / 2 / Math.tan(fov * Math.PI / 180);
        length = length * 2; //太小了
        position.add(sub1.normalize().multiplyScalar(length));
        return {
            target: center,
            position: position
        };
    },

    /**
     * 移动镜头，使之看到一系列的nodes
     * add by Kevin 2016-11-01
     */
    moveCameraForLookAtNodes: function(nodes, callback, angle,offset) {
        if (!nodes || nodes.length < 1) {
            if (callback) {
                callback();
            }
            return;
        }
        var camera = this.getCamera(nodes[0]); // 17-08-11 this.sceneManager.network3d.getCamera();
        var targetAndPos = this.getCameraTarAndPosForLookAtNodes(nodes,angle,offset);
        if (targetAndPos) {
            var position = targetAndPos.position;
            var center = targetAndPos.target;
            it.Util.playCameraAnimation(camera, position, center, 1500, callback);
        }
    },
    
    /**
     * 计算一系列nodes的总boundingBox
     * 注意：由于这个node是保存在map中的主对象，其实它有可能包含了多个子对象，但是其子对象并没有参与合并boundingBox的计算，
     * 一般来讲也不会有什么问题，我们lookAt时也只计算了该node，若有问题，需调整模型
     * add by Kevin 2016-11-01
     */
    computeNodesBoundingBox: function(nodes) {
        if (!nodes || nodes.length < 1) {
            return;
        }
        var vertices = [];
        for (var i = 0; i < nodes.length; i++) {
            var data = nodes[i];
            if (data instanceof TGL.Node) {
                bb = data.getBoundingBox();
                matrix = data.worldMatrix;
                var min = bb.min,
                    max = bb.max;
                pushVertics(min.clone(), matrix);
                pushVertics(max.clone(), matrix);
                pushVertics(new mono.Vec3(min.x, min.y, max.z), matrix);
                pushVertics(new mono.Vec3(min.x, max.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, min.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, max.y, min.z), matrix);
                pushVertics(new mono.Vec3(max.x, min.y, max.z), matrix);
                pushVertics(new mono.Vec3(min.x, max.y, max.z), matrix);
            }
        }

        function pushVertics(vertex, matrix) {
            vertex.applyMatrix4(matrix);
            vertices.push(vertex);
        };
        if (vertices.length <= 1) {
            return null;
        }
        var boundingBox = new mono.BoundingBox();
        boundingBox.setFromPoints(vertices);
        return boundingBox;
    },

    getCenter : function(node1,node2){
        if(!node1 && !node2){
            return null;
        }else if(!node1 && node2){
            return node2.getWorldPosition();
        }else if(!node2 && node1){
            return node1.getWorldPosition();
        }else{
            var w_n1 = node1.getWorldPosition();
            var w_n2 = node2.getWorldPosition();
            var x = (w_n2.x - w_n1.x) > 0 ?w_n1.x + (w_n2.x - w_n1.x)/2 : w_n2.x + (w_n1.x - w_n2.x)/2;
            var y = (w_n2.y - w_n1.y) > 0 ?w_n1.y + (w_n2.y - w_n1.y)/2 : w_n2.y + (w_n1.y - w_n2.y)/2;
            var z = (w_n2.z - w_n1.z) > 0 ?w_n1.z + (w_n2.z - w_n1.z)/2 : w_n2.z + (w_n1.z - w_n2.z)/2;
            return new mono.Vec3(x,y+50,z);
        }
    },

    /**
     * 备注，length*frontDirection，是使之计算包含上其方向
     */
    getPerfectDistanceForNodes : function(node1,node2){
        var direction = 'z';
        var result = {direction:'x',length:0};
        if(!node1 && !node2){
            return null;
        }else if(!node1 && node2){
            // return this.getElementPerfectDistance(node2);
            var fd = 1;
            if (node2.frontDirection().z < 0) {
                fd = -1;
            }
            result = {direction:'x',length:this.getElementPerfectDistance(node2)*fd};
        }else if(!node2 && node1){
            // return this.getElementPerfectDistance(node1);
             var fd = 1;
             if (node1.frontDirection().z < 0) {
                fd = -1;
             }
             result = {direction:'x',length:this.getElementPerfectDistance(node1)*fd};
        }else{
            var camera = this.getCamera(node1); // 17-08-11 this.sceneManager.network3d.getCamera();
            var w_n1 = node1.getWorldPosition();
            var w_n2 = node2.getWorldPosition();
//            var x = (w_n2.x - w_n1.x) > 0 ? (w_n2.x - w_n1.x) :  (w_n1.x - w_n2.x);
//            var y = (w_n2.y - w_n1.y) > 0 ? (w_n2.y - w_n1.y) :(w_n1.y - w_n2.y);
//            var z = (w_n2.z - w_n1.z) > 0 ? (w_n2.z - w_n1.z) : (w_n1.z - w_n2.z);
            var x = Math.abs(w_n2.x - w_n1.x);
            var y = Math.abs(w_n2.y - w_n1.y);
            var z = Math.abs(w_n2.z - w_n1.z);
            var h = x;
            if(y>h){
                h = y;
            }
            if(z>h){ 
                h = z;
                direction = 'x'; //如果z上的偏移量大的话，那就应该在x方向来看
            }
            var length = h / (2 * Math.tan(camera.fov * Math.PI / 180 / 2));
//            var length = h / (2 * Math.tan(camera.fov / 2));
            var offset = 50;
            length+= offset;
            if(length < 500){
                length = 500;
            }
            var fd = 1;
            if (node1.frontDirection().z < 0) {
              fd = -1;
            }
            result = {direction:direction,length:length*2*fd};
            // return length*2;
        }
        return result;
    },

    /**
     * lookAt link
     * 注意：如果是跨层的link，那就平视到正中间
     * @param linkNode
     * @param callback
     */
    moveCameraForLookAtLink : function(linkNode,callback,dur){
        if(!linkNode) return ;
        dur = dur||1500;
        var camera = this.getCamera(linkNode); // 17-08-11 this.sceneManager.network3d.getCamera();
        var link = this.sceneManager.getLinkData(linkNode);
        if(!link){
            this.moveCameraForLookAtNode(linkNode,callback);
            return;
        }
        var fromNodde = this.sceneManager.getNodeByDataOrId(link.getFromId());
        var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
        //有可能fromNode和toNode在focuseNode时真假切换的过程中给remove掉了，如正lookAt某个机柜时，
        //这个link的端正好是该机柜中的设备或端口,所以这里重新add一下 2016-12-06
        if(fromNodde && !this.box3d.getDataById(fromNodde.getId())){
            this.box3d.add(fromNodde);
        }
        if(toNode && !this.box3d.getDataById(toNode.getId())){
            this.box3d.add(toNode);
        }
        var target = this.getCenter(fromNodde,toNode);
        var dirLength = this.getPerfectDistanceForNodes(fromNodde,toNode);
        var length = null;
        var direction = null;
        if (dirLength) {
            length = dirLength.length;
            direction = dirLength.direction;
        }
        var detalY = 0;//500;
        if(fromNodde && toNode){
            var fWPos = fromNodde.getWorldPosition();
            var tWPos = toNode.getWorldPosition();
            if(Math.abs(fWPos.y - tWPos.y) > 100){ //表示跨层了，跨层的话就平视
                detalY = 0;
            }else{
                // detalY = detalY+ Math.round(Math.abs(fWPos.y - tWPos.y)/500) * 100;
                detalY = Math.abs(length) * Math.tan(Math.PI/6);
            }
        }
        var  f_position = new mono.Vec3(target.x, target.y+detalY, target.z);
        if (direction && direction == 'x' && length) {
            f_position.x = f_position.x + length;
        }else if (direction && direction == 'z' && length){
            f_position.z = f_position.z + length;
        }
        it.Util.playCameraAnimation(camera, f_position, target, dur, callback);
    },

    _isLookAt : function(node){
        if(this.isLookAtFunction != null){
            return this.isLookAtFunction(node);
        }
        var data = this.sceneManager.getNodeData(node);
        if(!data){ // 如温度云图
            return false;
        }
        return true;
    },

    isDoLookAt : function(node){
        if(node && node.getClient('notLookAt')){
            return false;
        }
        return true;
    },

    /**
     * 哪些东西要实现堆栈
     * 也可以通过重写该方法，返回false时来关闭镜头堆栈的功能
     */
    isUseCameraStackByNode : function(node){
         var nodeData = this.sceneManager.getNodeData(node);
         if (!nodeData) {
            return false;
         }
          var nCategory = this.dataManager.getCategoryForData(nodeData);
         if (nCategory 
            && (nCategory.getId().toLowerCase() == 'floor' 
                || nCategory.getId().toLowerCase() == 'room')) {
             return true;
         }
         return false;
    },
    
    /**
     * 是否将镜头的信息压入栈中
     * 注意：从lookAt机柜退回到lookAt机柜的上层时，这样的情况是不需要压栈的，根据focusNode来判断
     * 
     */
    isPushCameraInfoBeforeLookAt : function(node){
         if(!node){
            return false;
         }
         var nodeData = this.sceneManager.getNodeData(node);
         if (!nodeData) {
            return false;
         }
         var oldFocusNode = this.sceneManager.viewManager3d.getFocusNode();
         var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
         if (nodeData != oldFocusData && this.dataManager.isAncestor(nodeData.getId(),oldFocusData)) {
             return false;
         }
         return this.isUseCameraStackByNode(node);
         // var nCategory = this.dataManager.getCategoryForData(nodeData);
         // if (nCategory 
         //    && (nCategory.getId().toLowerCase() == 'floor' 
         //        || nCategory.getId().toLowerCase() == 'room')) {
         //     return true;
         // }
         // return false;
    },

    /**
     * 保存lookAt之前的压入该节点的镜头信息
     */
    pushCameraInfoByChildNode : function(childNode){ 
        //下面三行本来为注释状态的，会产生以下问题，通过id进入楼层后，马上lookAt楼层时，会产生一个奇怪的镜头位置，且只有第一次lookAt的时候才有，因此取消注释。
        //2017-11-29 by liyinzheng
        if (!childNode) {
            return ;
        }
        var cData = this.sceneManager.getNodeData(childNode);
        // if (!cData || !cData.getParentId()) {
        //     return ;
        // }
        // var parentNode = this.sceneManager.getNodeByDataOrId(cData.getParentId());
        var parentNode = this.sceneManager.viewManager3d.getFocusNode();//应该是focuseNode,因为lookAt的时候不一定是一级一级的。
        var data = this.sceneManager.getNodeData(parentNode);
        if (cData == data  // 2017-10-27 如果看到是focus自己的话，就不压栈了
            || !this.isPushCameraInfoBeforeLookAt(parentNode)) {
            return ;
        }
        var camera = this.getCamera();
        if (camera) {
            this.cameraInfoStack.push({id:data.getId(),target: camera.target,position:camera.getPosition()});
        }
    },
    
    /**
     * lookAt好了以后压出该节点的镜头信息
     * 注意：不是所有的node都需要压出，如果之前压入的对象才需要；
     *      如果快速跳转的话，得注意压出到哪里
     *  貌似压出可以不用控制的那么严，如果lookAt的是自己的话查看一下堆，如果堆里有的话则pop.
     *  对于点击背景的回退的才pop，其他的通过id跳转的则不去pop，直接清空堆栈
     *  
     */
    popCameraInfoByNode : function(node){
        var data = this.sceneManager.getNodeData(node);
        if (!data) {
            return false;
        }
        if (!this.isUseCameraStackByNode(node)) {
            return false;
        }
        return this.popToDataParentByData(data); //一直回退回退
    },

    /**
     * 出栈，一直出到data那层
     */
    popToDataParentByData : function(data,scope){
        scope = scope || this;
        if(!data || !scope.cameraInfoStack || scope.cameraInfoStack.length < 1){
            return ;
        }
        //lookAt区域时，lookAt完之后马上就出栈了，没有去判断刚刚入的正是它的parent，这样不太合理 -- 2017-10-19
        if (!scope.cameraInfoStack[0] || scope.cameraInfoStack[0].id == data.getParentId() ) { 
            return ;
        }
        var pci = scope.cameraInfoStack.pop();
        if (pci && pci.id == data.getId()) {
            return true;
        }else {
            return scope.popToDataParentByData(data,scope);
        }
    },

    /**
     * 清除堆栈中的镜头信息
     */
    clearCameraInfo : function(){
        this.cameraInfoStack = [];
    },

    getSavedCameraInfoByNode : function(node){
        var data = this.sceneManager.getNodeData(node);
        if (!node 
            || !data 
            || !this.cameraInfoStack 
            || this.cameraInfoStack.length < 1) {
            return null;
        }
        if (!this.isUseCameraStackByNode(node)) {
            return null;
        }
        for(var i = this.cameraInfoStack.length-1 ; i >=0 ; i--){
            var pci = this.cameraInfoStack[i];
            if (pci.id == data.getId()) {
                return pci;
            }
        }
        return null;
    },

    /**
     * 移动镜头前是否处理了虚幻
     * 如果没有（从大范围到局部），那就返回false，使得接下来在lookAt的callback中处理
     */
    isDealWithVirtualBeforeMoveCamera : function(focusNode,oldFocusNode){
        var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
        var data = this.sceneManager.getNodeData(focusNode); 
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().toLowerCase() == 'datacenter') { // floor合并例外，否则合并的过程中floor和building同时存在
            return false;
        }
        return this.sceneManager.isAncestor(oldFocusData,data);
    },

    /**
     * 将镜头对到node
     * 注意：有可能node虽然存在，但是不在box中，比如设备，因为一般情况下(lazyable)时，机柜中的设备是被移除了
     *
     * 对于有些对象不需要这个lookAt(调用这个是实属无奈，比如场景切换时)，如：earth(地球)，由于它的lookAt比较特殊(需要看到中国)，所以其自身处理了这个lookAt
     *
     * @param node
     * @param callback1
     */
    lookAt : function(node, callback1) { //虚化
        this.pushCameraInfoByChildNode(node);
        if (!node) {
            if (callback1) {
                callback1();
            }
            return;
        }
        if (!this.isDoLookAt(node)) {
            if (callback1) {
                callback1();
            }
            return;
        }
        var oldFocusNode = this.sceneManager.viewManager3d.getFocusNode();
        // var oldFocusData = this.sceneManager.getNodeData(oldFocusNode);
        var mainNode = this.sceneManager.getMainNode(node);
        if (!mainNode && !this.sceneManager.isLink(node)) { //有可能是2D的Node
            return;
        }
        var data = this.sceneManager.getNodeData(mainNode);
        if (!mainNode && this.sceneManager.isLink(node)) { //由于Link没有父子关系，因此lookat到link时，返回到上一级需特别处理一下(找fromId和toId)
            mainNode = node;
        }else if (!this.box3d.getDataById(mainNode.getId())) {//如果不存在就得重新load,可是如果是在building场景(该场景只加载children，但是lookAt的是自己)下呢？
            this.sceneManager.loadLazyData(data);
        }
        var isDealWithVirtual = true;
        // 有可能setFocus时不需要处理虚幻，然而这边又从局部到外部
        if (this.isDealWithVirtualBeforeMoveCamera(mainNode,oldFocusNode)) {//从局部到全局时，Focus时就不处理虚幻，在动画完成之后处理
            isDealWithVirtual = false;
        }
        this.sceneManager.viewManager3d.isDealWithVirtual = isDealWithVirtual; // 2017-10-20 为了同步，setFocusNode可能会被重写
        this.sceneManager.viewManager3d.setFocusNode(mainNode,isDealWithVirtual);
        if (this.beforeLookAtFunction) { // 放到了setFocuse之后，是因为这是为了不让某些对象虚化而增加了(而虚化是在setFocuse中处理的)
            this.beforeLookAtFunction(node,oldFocusNode);
        }
        if (!this.sceneManager.isLink(node)) {
             mainNode = this.sceneManager.getMainNode(node); // 有可能在beforeLookAtFunction中重新组织了数据
        }
        if (!mainNode || !this.box3d.getDataById(mainNode.getId())) { // 不在box中，不用lookAt
            this.afterLookAt(mainNode, node,oldFocusNode); // 如果为空也要执行这个动作，比如我们切换属性框的动作，如果直接返回了，那属性还是老的
            return;
        }
        var self = this;
        var callback = function(){ //可是这都是异步的，有可能在移动镜头的过程中，执行了其他的动作，并且该动作也改变了该callback中的值
            // if (!isDealWithVirtual) {
            // 2017-10-20 有可能setFocus被重写了，并不需要去改变虚幻，view3D中都不用的话，这里也不用。当view3D中需要的话，它会将里面的isDealWithVirtual置为true
            if (!isDealWithVirtual && self.sceneManager.viewManager3d.isDealWithVirtual) {
                self.sceneManager.viewManager3d.dealWithVirtual(mainNode);
            }
            self.popCameraInfoByNode(mainNode);
            self.openDoor(mainNode, callback1,oldFocusNode);
            self.afterLookAtFinished(mainNode, node,oldFocusNode);
        }
        if (this.lookAtWithOutMoveCamera) {
            if (this.sceneManager.isLink(node)) {
                this.moveCameraForLookAtLink(node, callback);
            } else {
                if (this.withOutAnimate) {
                    this.lookAtNodeWithOutAnimate(mainNode);
                    callback();
                    this.withOutAnimate = false;
                } else {
                    this.moveCameraForLookAtNode(mainNode, callback);
                }
            }
        } else {
            callback();
            this.lookAtWithOutMoveCamera = true;
        }
        this.afterLookAt(mainNode,node,oldFocusNode); //after lookAt,并不放到动画执行后，由于是异步的，比如在lookAt机柜的过程中，突然lookAt楼层或dc，此时bread和pm都很奇怪
    },

    /**
     * lookAt后马上执行，执行该动作时，camera还在移动的过程中
     * @param mainNode
     * @param node
     * @param callback
     */
    afterLookAt : function(mainNode,node,oldFocusNode){
//        this.openDoor(mainNode,callback);
        if(this.afterLookAtFunction){
            this.afterLookAtFunction(mainNode,node,oldFocusNode);
        }
        for(var i = 0 ; i < this._afterLookAtListener.length ; i++){
            var l = this._afterLookAtListener[i];
            l.call(l.scope||this,mainNode,node,oldFocusNode);
        }
    },

    addAfterLookAtListener : function(l,scope){
        if(l){
            l.scope = scope;
            this._afterLookAtListener.push(l);
        }
    },

    removeAfterLookAtListener : function(l){
         var index = this._afterLookAtListener.indexOf(l);
        if(index !== -1){
           this._afterLookAtListener.splice(index,1);
        }
    },

    /**
     * lookAt时，镜头移动好后执行
     * @param mainNode
     * @param node
     */
    afterLookAtFinished : function(mainNode,node){
        if(this.afterLookAtFinishedFunction){
            this.afterLookAtFinishedFunction(mainNode,node);
        }
        for(var i = 0 ; i < this._afterLookAtFinishedListener.length ; i++){
            var l = this._afterLookAtFinishedListener[i];
            l.call(l.scope||this,mainNode,node);
        }
    },

    addAfterLookFinishedAtListener : function(l,scope){
        if(l){
            l.scope = scope;
            this._afterLookAtFinishedListener.push(l);
        }
    },

    removeAfterLookAtFinishedListener : function(l){
         var index = this._afterLookAtFinishedListener.indexOf(l);
        if(index !== -1){
           this._afterLookAtFinishedListener.splice(index,1);
        }
    },

    findOidfromChildren : function (node, oid) {
        var result = [];
        if (node.getClient('type') == oid) {
            // return node; // 不能直接返回，还有孩子呢
            result.push(node);
        }
        var children = node.getChildren();
        for (var i = 0; i < children.size(); i++) {
            var child = children.get(i);
            if (child.getClient('it_data') == node.getClient('it_data')) {
                var cd = this.findOidfromChildren(child, oid, this);
                if (cd && cd.length > 0) {
                    // return cd;
                    for(var j = 0 ; j < cd.length ; j++){
                        result.push(cd[j]);
                    }
                }
            }
        }
        return result;
    },

    findAllOidDatafromChildren: function (node, oid) {
        var all = [];
        if (node.getClient('type') == oid) { //oid
            all.push(node);
            // return all;  // 不能马上返回，还有很多门没有找到 add 2017-05-12 Kevin
        }
        var children = node.getChildren();
        for (var i = 0; i < children.size(); i++) {
            var child = children.get(i);
            if (child.getClient('it_data') == node.getClient('it_data')) {
                var cd = this.findOidfromChildren(child, oid);
                if (cd && cd.length > 0) {
                    // all.push(cd);
                    for(var j = 0 ; j < cd.length ; j++){
                        all.push(cd[j]);
                    }
                }
            }
        }
        return all;
    },

    findRackDoorElementAtRack: function (mainNode) {
        if (!mainNode) {
            return;
        }
        return this.findAllOidDatafromChildren(mainNode, 'rack_door'); //door
    },

    findChannelDoorElementAtChannel: function (mainNode) { //增加赛选channel模型的door、天窗  by--loda 2017-12-12
        if (!mainNode) {
            return;
        }
        return this.findAllOidDatafromChildren(mainNode, 'channel_door'); //channel_door
    },

    openDoor : function(mainNode,callback){
        var doors = this.findRackDoorElementAtRack(mainNode);
        var count = doors.length;
        var index = 0;
        var isPlay = false;
        if (doors && doors.length > 0) {
            doors.forEach(function (door) {
                if (door && door.getClient('animation') && !door.getClient('animated')) { //!door.__animated 表示的是动画没有被执行
//                    console.log(door.getClient('animation'));
//                    var amin = 'rotation:right:-150:1000:0:Bounce.Out'; //door.getClient('animation')
                    // (element, animation, time, delay, easing, onCompleteCallback)
//                    mono.AniUtil.playAnimation(door, door.getClient('animation'), null, null, null, callback);
                    isPlay = true;
                    make.Default.playAnimation(door,door.getClient('animation'),function(){callback && callback(index++,count)});
                }
            });
        }
        if(!isPlay && callback){
            callback(0,0);
        }
    },

    closeDoor:function(mainNode,callback){
        var self = this;
        var doors = this.findRackDoorElementAtRack(mainNode);
        doors = doors.concat(this.findChannelDoorElementAtChannel(mainNode));
        var isPlay = false;
        if (doors && doors.length > 0) {
            doors.forEach(function (door) {
                if (door && door.getClient('animation') && door.getClient('animated')) { //door.__animated 表示的是动画被执行(即机柜的门是开着的)
//                    mono.AniUtil.playAnimation(door, door.getClient('animation'));
                    isPlay = true;
                    make.Default.playAnimation(door,door.getClient('animation'),callback);
                }
            });
        }
        var rackData = this.sceneManager.getNodeData(mainNode);
        var children = this.dataManager.getChildren(rackData);
        if(children && children.length>0){
            children.forEach(function(child){
                var childNode = self.sceneManager.getNodeByDataOrId(child);
                if (childNode && childNode.getClient('animation') && childNode.getClient('animated')) { //执行恢复原位动画
                    make.Default.playAnimation(childNode,childNode.getClient('animation'),callback);
                }
            })
        }
        if(!isPlay && callback){
            callback();
        }
    },

    /**
     * 表示双击到该Node上时是不是镜头跟着走
     * 默认实现是，当其尺寸中某以方向超过500时会跟着移动，像机柜设备这样的对象应该不能跟随，否则门都打不开
     * add 2016-11-22，若是dc或地板上的小物体呢？也无法移动了，需改进，不用boundingBox的size判断，用category
     * @param node
     * @returns {boolean}
     */
    isFollow : function(node){
        if (node) {
            var data = this.sceneManager.getNodeData(node);
            var category = this.dataManager.getCategoryForData(data);
            if (category) {
                var cid = category.getId().toLowerCase() ;
                if (cid === 'datacenter' || cid === 'floor' || cid === 'room') {
                     return true;
                }
            }
        };
        return false;
    },

    /**
     * 点击一下镜头就跟着移动一下
     * @param clickObj
     */
    moveToClickPoint : function(clickObj){
        if(!clickObj) return;
        var camera = this.getCamera();
        if(!camera) return;
        var newTarget=clickObj.point;
        var offset=camera.getPosition().sub(camera.getTarget());
        var f_position=new mono.Vec3().addVectors(offset, newTarget);
        it.Util.playCameraAnimation(camera,f_position,newTarget,1000);
    },

    /**
     * 移动镜头到，保持距离，target弄成node
     * 不过当offset小于moveSize时就不移动了
    */
    moveToClickNode : function(node,callback,moveSize){
        if(!node) return;
        if (!moveSize) {
            moveSize = 0;
        }
        var camera = this.getCamera();
        if(!camera) return;
        var newTarget=this.getNodeCenterPosition(node);
        var offset=camera.getPosition().sub(camera.getTarget());
        var f_position=new mono.Vec3().addVectors(offset, newTarget);
        var diffOff = new mono.Vec3().subVectors(newTarget,camera.getTarget());
        if (Math.abs(diffOff.x) > moveSize || Math.abs(diffOff.y)>moveSize || Math.abs(diffOff.z)>moveSize) {
            it.Util.playCameraAnimation(camera,f_position,newTarget,1000,callback);
        }else{
            if (callback) {
                callback();
            }
        }
    },

    getElementPerfectBackPosition : function(element){
        if(!element) return null;
        var h = this.getElementPerfectDistance(element);
        var  perfectPosition = element.worldPosition(new mono.Vec3(0,0,-1),h);
        if(perfectPosition){
            perfectPosition.y = perfectPosition.y+20;
        }
        return perfectPosition;
    },

    rotateElement : function(mainObj){
        // var mainObj = Util.getMainObject(element);
        if(!mainObj){
            return ;
        }
        if(!mainObj.isVisible() && mainObj.simpleRack){
            mainObj = mainObj.simpleRack;
        }
        var camera = this.getCamera(mainObj); // 17-08-11 this.sceneManager.network3d.getCamera();
        var perfectPosition = null;
        var w_p = mainObj.getWorldPosition();
        var rotate_flage = mainObj.getClient('rotate_flage');
        if(rotate_flage){
            perfectPosition = this.getElementPerfectFrontPosition(mainObj);
            mainObj.setClient('rotate_flage',false);
        }else{
            perfectPosition = this.getElementPerfectBackPosition(mainObj)
            mainObj.setClient('rotate_flage',true);
        }
        var target =  new mono.Vec3(w_p.x, w_p.y, w_p.z);
        it.Util.playCameraAnimation(camera,perfectPosition,target,1000);
    },

    shouldHandleDoubleClickElement : function(node,network,data,clickedObj){
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
         //移至了viewManager3D中，从根处过滤更加合理
        // var virtualManager = this.getDefaultVirtual();
        // if(virtualManager && virtualManager.isVirtual(data||node)){
        //     return false;
        // }
        var root = node.getClient('modelParent') || node;
        var dataForRoot = this.sceneManager.getNodeData(root);
        var dataForLookAtNode = this.sceneManager.getNodeData(lookAtNode);
        // if(this._isLookAt(root) && lookAtNode != root){
        if(this._isLookAt(root) && dataForRoot != dataForLookAtNode){ //check data
            return true;
        }else if(node && (node.getClient('animation') || node.getClient('animated'))){
            return true;
        }else if(this.isFollow(node)){
            return true;
        }
       return false;
	},

  	shouldPropogateDoubleClickElement : function(node,network,data,clickedObj){
         return false;
  	},

  	shouldHandleDoubleClickBackground : function(network){
//  		 if(this.lookAtNode){
           return true;
//         }
//         return false;
  	},

  	shouldPropogateDoubleClickBackground : function(network){
         return false;
  	},

    /**
     * 表示什么对象都没有点中时，此时处理一下
     * @param network
     */
  	handleDoubleClickBackground : function(network){
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
        if(lookAtNode){
            if(this.sceneManager.isLink(lookAtNode)){
//                var fromNode = lookAtNode.getFromNode();//有可能为空
//                if(fromNode){
//                    lookAtNode =  fromNode;
//                }else{
                    var link = this.sceneManager.getNodeData(lookAtNode);
                    if(link){
                        if(link.getFromId() && this.sceneManager.isCurrentSceneInstance(link.getFromId())){
                            lookAtNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                        }else if(link.getToId()) {
                            lookAtNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                        }else{
                            lookAtNode = lookAtNode.getFromNode();//有可能为空
                        }
                    }
//                }
//                lookAtNode = lookAtNode.getFromNode();
            }

            var parentNode = this.getParentFocusNode(lookAtNode);
            if(parentNode){
                this.lookAt(parentNode);
                return this.handleDoubleClickBackgroundFunction && this.handleDoubleClickBackgroundFunction(network);
            }
        }
        this.handleDoubleClickBackgroundFunction && this.handleDoubleClickBackgroundFunction(network);
  	},

    /**
     * 点击背景时，lookAt到下一个对象，这里做了个扩展，不一定是其parent.
     * 因为现在有种特殊的情况：开始看到的是真的building，点击该building看到的是building的所有的楼层，现在回到上一级时应该还是building
     * @param lookAtNode
     * @returns {*}
     */
    getParentFocusNode : function(lookAtNode){
        var data = this.sceneManager.getNodeData(lookAtNode);
        if (data && data.getParentId()) {
            var parentData = this.sceneManager.dataManager.getDataById(data.getParentId());
            if (!parentData) {
                return null;
            }
            var parentNode = this.sceneManager.dataNodeMap[data.getParentId()]; //如果确实存在parentData，但是其本身就是根场景的情况，因此这里就不要用loadLazyData了
            return parentNode
        }
    },
     
    /**
     * 双击的对象如果太远，是不是先lookAt到它的parent(这个parent是room或channel)
     */
    isLookAtParentFirst : function(node,network,data,clickedObj){
        return true;
    },

    isPlayAnimate : function(node){
        return true;
    },

    /**
     * 鼠标“双击”时的处理
     * 如果是可以lookAt的（并且当前不是lookAt到它时）那就lookAt过去,
     * 否则看看是不是可以移动镜头
     * @param node
     * @param network
     * @param clickedObj
     */
  	handleDoubleClickElement : function(node,network,data,clickedObj){
        var root = node.getClient('modelParent') || node;
        var self = this;
        var lookAtNode = this.sceneManager.viewManager3d.getFocusNode();
        if(data 
            && clickedObj.distance > 2500 
            && this.isLookAtParentFirst(node,network,data,clickedObj)){ // 如果点的老远的对象，并且之前不是通道时，那么就look到通道(或room add By Kevin 20161109)
            var parantData = this.sceneManager.dataManager.getDataById(data.getParentId());
            var parentNode = this.sceneManager.getNodeByDataOrId(data.getParentId());
            if(parantData && parentNode && parentNode != lookAtNode){
                var category = this.sceneManager.dataManager.getCategoryForData(parantData);
                if(category 
                    && (category.getId().indexOf('channel') >=0 
                        || category.getId().toLowerCase() === 'room')){
                    root = parentNode;
                }
            }
        }
        if(this._isLookAt(root) && lookAtNode != root){
            this.lookAt(root);
//            this.lookAtNode = root;
        }else if(node && (node.getClient('animation') || node.getClient('animated'))) { //door.__animated 表示的是动画被执行(即门是开着的)
            var animate = node.getClient('animate');
            if (this.isPlayAnimate(node)) {
                var callback = function(){
                    self.afterPlayAnimateFunction && self.afterPlayAnimateFunction(node,!!animate); 
                }
                make.Default.playAnimation(node,node.getClient('animation'),callback);
            }
        }else if(this.isFollow(node)){
            this.moveToClickPoint(clickedObj);
        }
  	},

    /**
     * 
     * @withStopCamera,默认是true 表示当场景切换时，是不是将镜头的动画停掉，比如：场景切换时，各种设置镜头的动作
     */
    lookAtByData : function(data,callback,withStopCamera){
        if (!data) {
            callback&&callback();
            return;
        }
        if (typeof(data) == 'string' || typeof(data) == 'number') {
            data = this.sceneManager.dataManager.getDataById(data);
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
        if (sceneAndRootData) {
            if (node 
                && sceneAndRootData.scene == this.sceneManager.getCurrentScene() 
                && sceneAndRootData.rootData == this.sceneManager._currentRootData
                ) {
                this.lookAt(node,callback);
                 return;
            }
            if(withStopCamera || withStopCamera == undefined || withStopCamera == null){
                withStopCamera = true;
            }else{
                withStopCamera = false;
            }
            if (withStopCamera) {
                this.sceneManager.cameraManager.setStopCamera(true);
            }
            var self = this;
            var afterGotoSceneCallback = function(){ 
                if (sceneAndRootData.rootData != data) {
                    node = self.sceneManager.dataNodeMap[data.getId()];
                    if (!node) {
                        self.sceneManager.loadLazyData(data, function () {
                            node = self.sceneManager.dataNodeMap[data.getId()];
                            self.lookAt(node, callback);
                        });
                        return;
                    }
                } else {
                    node = null;
                    // node = self.sceneManager.dataNodeMap[data.getId()]; // add 2017-05-08 正好切换到根场景 gotoScene只setFocuse，没有lookAt
                }
                self.lookAt(node, callback);
            };
            // this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData,afterGotoSceneCallback);
            if (sceneAndRootData.scene.getCategoryId() == 'earth') {
                //update 2017-07-07 不一定是同步的，后来加了beforeLoadSceneAnimate方法，目前dc切换到earth时会先在befor中play一下
                this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData,afterGotoSceneCallback);
            }else{
                if (sceneAndRootData.rootData != data) {
                    this.sceneManager.resetCameraWhenSceneChange = false;
                }
                this.sceneManager.gotoScene(sceneAndRootData.scene, sceneAndRootData.rootData);//这是同步的，并且callback后还有set父子关系和setFocuse
                afterGotoSceneCallback(); //这些callback都不是同步的，只是切换完就马上调用，可是动画(CameraManager中的动画)并没有执行完
            }
           
            if (withStopCamera) {
                mono.Utils.stopAllAnimates(true);
            }
        }
    }

});

it.DefaultEventHandler = $DefaultEventHandler;

/**
 * 虚化的实现类
 * 1、该类实现了两个级别的虚化管理，一个全局的，一个非全局的。
 * 如：实现类似先查询（不符合条件的虚化），然后在虚幻的基础上再进行虚化（如在查询后的基础上再看某个设备）
 *
 * 2、设置了透明不可点中，（setSelectTransparencyThreshold方法）
 *
 *
 */

var $VirtualManager = function(sceneManager){
    $MaterialFilter.call(this);
    this.sceneManager = sceneManager;
    this.opacityValue = 0.26; //0.06;
    this.focusElement = null;
    this.virtualFilter = null; // TODO 可以增加是否需要虚幻的过滤。
    this.materialMap = {};
    this.isDealWithFunction = null;

    this._global_tmap = {}; //这个是全局的，最高级，比如搜索后的结果而tmap的处理只是在这一层上,放的是it.Data对象
    this._global_linkTmap = {}; // 放全局的it.Link对象
    this._tmap = {}; // 第一级 ,放入it.Data对象的
    this._linkTmap = {}; // 第一级,放入it.Link对象的
    this._billboard_tmap = {}; //用来保存中途billboard的透明的处理
    this._link_tmap = {}; // 对于mono.Link，使用clone其materal是无效的，所以这里采用同billboard一样的方式
    this.sceneManager.network3d.setSelectTransparencyThreshold(this.opacityValue + 0.1); // 点击门槛不应该通过这种方式，应该加个用个filter
    this.dealWithLinkFunction = null;
    this.virtualFunction = null;
    this.getOpacityValueFunction = null; //用于获取data的透明的自定义方法
    this._particleMap = {};
};

mono.extend($VirtualManager,$MaterialFilter,{

    clearGlobal : function(){
        this._global_tmap = {};
        this._global_linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clearGlobal'
        });
    },

    clear: function(){
        this._tmap = {};
        this._linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clear'
        });
    },

    clearAll : function(){
        this._tmap = {};
        this._linkTmap = {};
        this._global_tmap = {};
        this._global_linkTmap = {};
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'clearAll'
        });
    },

    /**
     * 是否需要设置透明：
     * 对于数据中心来说，datacenter和building不需要
     * @param data
     * @returns {boolean}
     */
    isDealWith : function(data){
        if(this.isDealWithFunction != null){
            return this.isDealWithFunction(data);
        }
        return true;
    },

    isVirtualOther :function(data){
        var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
        if(dataType && dataType._noVirtualOther){
            return false;
        }
        if(this.virtualFunction){
            return this.virtualFunction(data);
        }
        return true;
    },

    isDealWithLink : function(link){
        if(this.dealWithLinkFunction){
            return this.dealWithLinkFunction(link);
        }
        return false;
    },

    getBId : function(data){
        if(!data) {
            return null;
        }
        if(!this.isDealWith(data)){
            return null;
        }
        if (typeof(data) =='string') {
          return data;
        }
        return data.getId();
    },

    addGlobal : function(data){
        if(data instanceof it.Link){
            this.addGlobalLink(data);
            return ;
        }
        var id = this.getBId(data);
        if(id){
            this._global_tmap[id] = true;
        }
    },

    addGlobalLink : function(link){
        var id = this.getBId(link);
        if(id){
//            this._global_linkTmap[id] = true; //不折腾link的virture了
        }
    },

    addGlobalByDescendant : function(data){
        if(!data){
            return ;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.addGlobal(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.addGlobalByDescendant(child,this);
                }
            }
        }

    },

    removeGlobal : function(data){
        var id = this.getBId(data);
        if (id) {
            if (data instanceof it.Link) {
                delete this._global_linkTmap[id];
            } else {
                delete this._global_tmap[id];
            }
        }
    },

    removeGlobalByDescendant : function(data){
        if(!data){
            return;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.removeGlobal(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.removeGlobalByDescendant(child,this);
                }
            }
        }
    },
    
    /**
     * 设置之前的一些操作
     */
    beforeAdd : function(data){

    },

    add : function(data){
        this.beforeAdd(data);
        var id = this.getBId(data);
        if(id){
            if(data instanceof it.Link){
//                this._linkTmap[id] = true; //不折腾link的virture了
            }else{
                this._tmap[id] = true;
            }
        }
    },

    addLink : function(link){
        if(!link) return;
        var id = this.getBId(link);
        if(id){
//            this._linkTmap[id] = true; //不折腾link的virture了
        }
    },

    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return node.getClient(it.SceneManager.CLIENT_IT_DATA);
    },

    addByDescendant : function(data){
        if(!data) return;
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.add(data);
        /** 不太合理，为什么不直接用data呢？有可能3D中的父子关系去掉了 —— update 2017-06-28
        var node = this.sceneManager.dataNodeMap[data.getId()];
        var children = node.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childData = this.getDataByNode(child);
                if(childData
                    && this.getBId(childData) != this.getBId(data)){
                    this.addByDescendant(child,this);
                }
            }
        }*/
        var children = data.getChildren();
        if (!children || children.size() < 1) {
            return;
        }
        for(var i = 0 ;i < children.size() ; i++){
             var childData = children.get(i);
             if(childData){
                this.addByDescendant(childData,this);
             }
        }
    },

    remove : function(data){
        var id = this.getBId(data);
        if(id){
            if(data instanceof it.Link){
                delete this._linkTmap[id];
            }else{
                if(data.getAllLinks){ // 移除与该data有关的link的透明
                    var links = data.getAllLinks();
                    if(links){
                        for(var linkId in links){
                            delete this._linkTmap[linkId];
                        }
                    }
                }
                delete this._tmap[id];
            }
        }
    },

    /**
     *
     * @param data data或Element
     */
    removeByDescendant : function(dataOrElement){
        var data = dataOrElement;
        if(!data) return ;
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(!data || !data.getId()) return;
        this.remove(data);
        var node = this.sceneManager.dataNodeMap[data.getId()];
        if(data instanceof it.Link){
            node = this.sceneManager.linkMap[data.getId()];
        }
        var self = this;
        if(!node || !node.getChildren){
//            console.log('Stop!');
        }
//        var children = node.getChildren();
//        if(children && children.size() > 0){
//            for(var i = 0 ; i < children.size(); i++){
//                var child = children.get(i);
//                var childData = self.getDataByNode(child);
//                if(childData
//                    && self.getBId(childData) != self.getBId(data)){
//                    self.removeByDescendant(child,self);
//                }
//            }
//        }
        var children = null;
        if(data.getChildren){ //有可能是it.link
            children = data.getChildren(); //用data上的children更加合理，又可以能因某种原因3D上的parent置为了空，如房间的parent置为null了
            if(children && children.size() > 0){
                for(var i = 0 ; i < children.size(); i++){
                    var child = children.get(i);
//                var childData = self.getDataByNode(child);
                    if(child
                        && self.getBId(child) != self.getBId(data)){
                        self.removeByDescendant(child,self);
                    }
                }
            }
        }

    },

    /**
     * 将所有的对象虚化掉
     * 注意：得包括it.Link
     */
    addAll:function(){
        this.addAllData();
        this.addAllLink();
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAll'
        });
    },

    addAllData : function(){
        var dataMap = this.sceneManager.dataManager.getDataMap();
        if(!dataMap) return ;
        for(var id in dataMap){
            var data = dataMap[id];
            if(data){
                this.add(data);
            }
        }
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAllData'
        });
    },

    addAllLink : function(){
        var linkMap = this.sceneManager.dataManager.getLinkMap();
        if(!linkMap) return ;
        for(var id in linkMap){
            var link = linkMap[id];
            if(link){
                this.addLink(link);
            }
        }
        this.sceneManager._sceneVirtualChangeDispather.fire({
                type:'addAllLink'
        });
    },

    isDealWithBillboard : function(node){
        return true;
    },

    isDealWithParticle : function(node){
        return true;
    },

    isVirtual : function(node){
        var data = node;
        if(node instanceof mono.Element){
            data = this.getDataByNode(node);
        }
        if(!(data instanceof it.Data) && !(data instanceof it.Link)) {
           // return true;
           return false; //没有就不管了
        }
        var dataNode = this.sceneManager.getNodeByDataOrId(data);
        if (dataNode && dataNode.getClient(it.SceneManager.CLIENT_EXT_VITUAL)) { //自己管理的这里就不管了
            return false;
        }
        var id = this.getBId(data);
        var transFlag = false;
        if(id){
            if(node instanceof mono.Link){
                if(this._global_linkTmap[id]){ // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
                    transFlag = this._global_linkTmap[id];
                }else if(this._linkTmap[id]){
                    transFlag = this._linkTmap[id];
                }
            }else{
                if(this._global_tmap[id]){ // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
                    transFlag = this._global_tmap[id];
                }else if(this._tmap[id]){
                    transFlag = this._tmap[id];
                }
            }
        }
        return transFlag;
    },

    isLink : function(node){
        if(node
            && node.getClient(it.SceneManager.CLIENT_IT_DATA)
            && node.getClient(it.SceneManager.CLIENT_IT_DATA) instanceof it.Link){
            return true;
        }
        return false;
    },

    /**
     * 是否隐藏虚化的billboard，默认的情况想告警的billboard会被隐藏的，不隐藏的话，透明的会挡住没透明的
     * @param node
     */
    isHideVirtualBillboard : function(node){
        if(node
            &&node instanceof mono.Billboard
            && node.getParent()){
            // var parent = node.getParent();
            // if(parent._alarmBillboard == node){// 这样才认为这的billboard是一个告警的billboard
            //     return true;
            // }
            if (node.getClient('_alarmBillboard')) {
                return true;
            }
        }
        return false;
    },

    isHideVirtualParticle : function(node){
        if(node
            &&node instanceof mono.Particle
            && node.getParent()){
            // var parent = node.getParent();
            // if(parent._alarmBillboard == node){
            //     return true;
            // }
            if (node.getClient('_alarmParticle')) {
                return true;
            }
        }
        return false;
    },

      setFocusElement : function(element){
//          this.focusElement = element;
//          this.sceneManager.viewManager3d.network.dirtyNetwork();
      },

    setOpacityValue : function(opacityValue){
        if(opacityValue){
            this.opacityValue = opacityValue;
        }
    },

    getOpacityValue : function(data){
        if (this.getOpacityValueFunction && this.getOpacityValueFunction(data)) {
            return this.getOpacityValueFunction(data);
        }
        return this.opacityValue;
    },

    /**
     * 由于billboard的透明的处理其实不是通过真正Filter来处理的，
     * 它还是通过原始的方法在本身设置了transparent和opacity来处理的，
     * 而当你remove这个handle时，其实是不会将已经设置的billboard做处理的
     */
    destoryBillboard : function(){
        if(!this._billboard_tmap) return;
        for(var id in this._billboard_tmap){
            var billboard = this._billboard_tmap[id];
            if(billboard.hasOwnProperty('orig_opacity')){
                var orig_opacity = billboard.orig_opacity;
                if(orig_opacity == undefined){
                    orig_opacity = 1;
                }
                billboard.setStyle('m.opacity',orig_opacity);
                if(this.isHideVirtualBillboard(billboard)){
                    billboard.setVisible(true);
                }
                delete billboard.orig_opacity;
                billboard.renderDepth = 0;
                delete this._billboard_tmap[billboard.getId()];
            }
        }
    },

    destoryParticle : function(){
        if(!this._particleMap) return;
        for(var id in this._particleMap){
            var particle = this._particleMap[id];
            if(particle.hasOwnProperty('smoke_opacity')){
                var smoke_opacity = particle.smoke_opacity;
                if(this.isHideVirtualParticle(particle)){
                    particle.setStyle('m.opacity',smoke_opacity);
                }
                delete particle.smoke_opacity;
                particle.renderDepth = 0;
                delete this._particleMap[particle.getId()];
            }
        }
    },

    getParentDataByNode : function(node,scope){
      if (!node) {
        return null;
      }
      if (!scope) {
        scope = this;
      }
      var data = scope.getDataByNode(node);
      if (data) {
        return data;
      }else{
         var parentNode = node.getParent();
         return arguments.callee(parentNode,scope);
      }
    },

    filterMaterial : function(originalMaterial,filterdMaterial,node){
        if (!(this.isLink(node)) && node instanceof mono.Line) {
            return originalMaterial;
        }
        if (node && node.getClient(it.SceneManager.CLIENT_EXT_VITUAL)) { // 如果是扩展的直接就返回不管了
          return originalMaterial;
        }
        var materialMap = this.materialMap;
        var material = filterdMaterial ? filterdMaterial : originalMaterial;
        var data = this.getDataByNode(node);
        if (!data
            && (node instanceof mono.Billboard)
            && node.getParent()) { //当billboard没有data时(如：告警的的board)，此时看它父亲的状态
            data = this.getDataByNode(node.getParent());
        }
          // 可是对于没有data的node，这里是没有处理的，是不是应该一直往上找，直到有data的父亲为止 -- add by Kevin 2016-11-04
        if (!data) {
           data = this.getParentDataByNode(node);
        }
        // var opacityValue = this.opacityValue;
        var opacityValue = this.getOpacityValue(data);
        if(opacityValue == 1){
            // return originalMaterial;
            return material; // 不应该是originalMaterial,update by Kevin 2017-07-04
        }
        var id = "";
        var transFlag = false;
        if (data && data instanceof it.Link && this.isDealWithLink()){
            id = this.getBId(data);
            if (id) {
                if (this._global_linkTmap[id]) { // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
                      transFlag = this._global_linkTmap[id];
                } else if (this._linkTmap[id]) {
                    transFlag = this._linkTmap[id];
                }
            }
            if (transFlag) {
                this._link_tmap[node.getId()] = node.isVisible();
                node.setVisible(false);
            } else {
                if(this._link_tmap[node.getId()] != null || !(this._link_tmap[node.getId()] === undefined)){
                    node.setVisible(this._link_tmap[node.getId()]);
                    delete this._link_tmap[node.getId()];
                }
            }
            return material;
        } else {
            if (data && data instanceof it.Data) {
//                  id = data.getId();
                id = this.getBId(data);
            }
              if (id) {
                  if (this._global_tmap[id]) { // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
                      transFlag = this._global_tmap[id];
                  } else if (this._tmap[id]) {
                      transFlag = this._tmap[id];
                  }
              }
          }

          if (node instanceof mono.Billboard && this.isDealWithBillboard(node)) {
              if (transFlag) { // 此时得给billboard加上透明
                  node.renderDepth = 10000;
                  if (!node.hasOwnProperty("orig_opacity")) { // 加了个判断，以防中途该值有所改变
                      node.orig_opacity = node.getStyle('m.opacity');
                  }
                  this._billboard_tmap[node.getId()] = node;
                  node.setStyle('m.opacity', opacityValue);
                  if (this.isHideVirtualBillboard(node)) {
                      node.setVisible(false); //这样可能会存在一个问题，那就是它本来就是隐藏着的
                  }
              } else { // 得去掉上面的透明
                  if (node.hasOwnProperty('orig_opacity')
                      && this._billboard_tmap[node.getId()]) { //当new多个这个的对象并且添加到filter中时，会存在冲突,所以的用个map来保存
                      var orig_opacity = node.orig_opacity;
                      if (orig_opacity == undefined) {
                          orig_opacity = 1;
                      }
                      node.setStyle('m.opacity', orig_opacity);
                      if (this.isHideVirtualBillboard(node)) {
                          node.setVisible(true);
                      }
                      delete node.orig_opacity;
                      node.renderDepth = 0;
                      delete this._billboard_tmap[node.getId()];
                  }
              }
              return material;
          }

          //处理烟雾
          if (node instanceof mono.Particle && this.isDealWithParticle(node)) {
            if (transFlag) {
                node.renderDepth = 10000;
                if (!node.hasOwnProperty("smoke_opacity")) { // 加了个判断，以防中途该值有所改变
                    node.smoke_opacity = node.getStyle('m.opacity');
                }
                this._particleMap[node.getId()] = node;
                if (this.isHideVirtualParticle(node)) {
                    node.setStyle('m.opacity', 0.001);
                }            
            } else {
                if (this._particleMap[node.getId()] && node.hasOwnProperty('smoke_opacity')) {
                    var smoke_opacity = node.smoke_opacity;
                    if (this.isHideVirtualParticle(node)) {
                        node.setStyle('m.opacity', smoke_opacity);
                    }
                    delete this._particleMap[node.getId()];
                    node.renderDepth = 0;
                    delete node.smoke_opacity;
                }
            }
            return material;
        }

          if (!transFlag) {
              return material;
          }

          var key = filterdMaterial ? filterdMaterial.getUniqueCode() : originalMaterial.getUniqueCode();
          if (materialMap[key] == null) {
              var m = filterdMaterial ? filterdMaterial.clone() : originalMaterial.clone();
              m.transparent = true;
              if( m.opacity > opacityValue){ // 有可能有多个materialFilter，这时就以最小的opacityValue -- Kevin 2017-06-29 
                 m.opacity = opacityValue;
              }
              materialMap[key] = m;
              return m;
          } else {
              return materialMap[key];
          }
    }

});

it.VirtualManager = $VirtualManager;

var $SelectableFilter = function(){

};

mono.extend($SelectableFilter,Object, {

    isSelectable : function(node,network){
        return true;
    }
});

it.SelectableFilter = $SelectableFilter;

var $SelectableManager = function(virtualManager){
    this.virtualManager = virtualManager;
};

mono.extend($SelectableManager,$SelectableFilter,{

    isSelectable : function(node,network){
       if(this.virtualManager.isVirtual(node)){
           return false;
       }
       if(node instanceof mono.Line){
       	 return false;
       }
        return true;
    }
});

it.SelectableManager = $SelectableManager;

/**
 * 镜头管理
 * 1、进入场景的镜头设置；sceneManager.resetCamera();
 * 2、进入场景后，添加的一些动画，如：在地球上点击dc，会一层一层的进入下一级；
 * 3、最终镜头的位置和target
 **/

$CameraManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.onloadFinishFunction = null;
	this.doAnimateFunction = null;
	this.finalCameraFunction = null;
    this.beforeSceneChangeCameraFunction = null;
    this._afterPlayCameraListener = []; // sceneChangerListener中耗时的listener放到这里
	this.initCamera();
	this.callback = this.afterPlayCamera;
    this._stopCamera = false;
};

mono.extend($CameraManager,Object,{

     /**
      * 初始化镜头，这里主要是把各个情境下的镜头设置串连起来
      */
     initCamera : function(){
     	var self = this;
        // 可以在resetCamera上加上一个moveCameraCallback的方法，在场景切换时可以传，等到场景切换好，并且场景的动画执行完后再执行
     	this.sceneManager.resetCamera = function(scene, rootData,oldScene,oldRootData,clientMap){
            if (!self.sceneManager.resetCameraWhenSceneChange) {
                self.sceneManager.resetCameraWhenSceneChange = true;
                return ;
            }
            if (self._stopCamera) {
                self._stopCamera = false;
                return;
            }
     		self.setCameraForOnloadFinish(scene, rootData,oldScene,oldRootData,clientMap);
     	}

        this.sceneManager.beforeLoadSceneAnimate = function(scene, rootData,oldScene,oldRootData,callback,scope){
            if (self.beforeSceneChangeCameraFunction) {
                self.beforeSceneChangeCameraFunction(scene, rootData,oldScene,oldRootData,callback,scope)
            }else{
                if (callback) {
                  callback.call(scope);
                }
            }
        }

     },

     setStopCamera : function(stopCamera){
        this._stopCamera = (stopCamera === true);
     },

     /**
      * 要想阻止从某个场景跳到某个场景的动画，也可以通过重写这个方法来
      */
     beforePlaySceneChangeAnimate : function(scene, rootData,oldScene,oldRootData,clientMap){
        return true;
     },

    /**
     * 当场景加载完后，镜头的设置
     */
	setCameraForOnloadFinish : function(scene, rootData,oldScene,oldRootData,clientMap){
        if (!this.beforePlaySceneChangeAnimate(scene, rootData,oldScene,oldRootData,clientMap)){
            return;
        }
		var scope = this;
		var callback = function(){
			scope.doAnimate(scene, rootData,oldScene,oldRootData,clientMap);
		}
		// var callback = this.doAnimate;
		if (this.onloadFinishFunction) {
			this.onloadFinishFunction(scene, rootData,oldScene,oldRootData,callback);
			return;
		}
		var sm = this.sceneManager;
		if(sm.resetCameraWhenSceneChange){
           if (sm._currentRootNode) {
              sm.viewManager3d.getDefaultEventHandler().lookAtNodeWithOutAnimate(sm._currentRootNode);
           }else{
              sm.network3d.zoomEstimateOverview(30);
           }
        }
        sm.resetCameraWhenSceneChange = true; 
        callback.call(this,scene, rootData,oldScene,oldRootData);
	},

    /***
     * 是否执行doAnimate
     * 默认是执行的
     * 在有些情况下不需要执行这样的动画，比如：从floor跳转到Datacenter中时，不执行这个反而更加流畅，否则镜头有点乱
     */
    isDoAnimate : function(scene,rootData,oldScene,oldRootData,clientMap){
        return true;
    },

    /**
     * 场景load完后，一些动画的实现或扩展，如：点击地球上的dc，一层一层进入下一级
     */
    doAnimate : function(scene, rootData,oldScene,oldRootData,clientMap){
    	var scope = this;
    	var callback = function(){
    		scope.setFinalCamera(scene, rootData,oldScene,oldRootData,clientMap);
    	}
    	if (this.isDoAnimate(scene, rootData,oldScene,oldRootData,clientMap) && this.doAnimateFunction) {
    		this.doAnimateFunction.call(this,scene, rootData,oldScene,oldRootData,callback,clientMap);
    		return;
    	}
    	callback(scene, rootData,oldScene,oldRootData,clientMap);
    },

    /***
     * 是否执行setFinalCamera
     * 默认是执行的
     * 在有些情况下不需要执行这样的动画，比如：从floor跳转到Datacenter中时，不执行这个反而更加流畅，否则镜头有点乱
     */
    isDoFinalCamera : function(scene,rootData,oldScene,oldRootData,clientMap){
        return true;
    },

    /**
     * 镜头最终的位置,有的是通过scene中的参数配置的，有的是客户自己配置的
     * 客户设置的优先级高于scene中配置的
     */
	setFinalCamera : function(scene, rootData,oldScene,oldRootData,clientMap){
		var scope = this;
		var callback = function(){
            if(scope.callback){
                scope.callback(scene, rootData,oldScene,oldRootData,clientMap);
            }  
        }
		// this.sceneManager.setSceneCamera(scene); // remove 2017-08-28,等到切换完再执行，太晚了，地球到园区时，第一次执行从地球到园区的动画没有设置scene中的fov
		if (this.finalCameraFunction) {
			this.finalCameraFunction(scene, rootData,oldScene,oldRootData,callback,clientMap);
			return;
		}
        callback();
	},

    addAfterPlayCameraListener : function(listener,scope){
        listener.scope = scope;
        this._afterPlayCameraListener.push(listener);
    },

    removeAfterPlayCameraListener : function(listener){
        var index = this._afterPlayCameraListener.indexOf(listener);
        if(index !== -1){
            this._afterPlayCameraListener.splice(index,1);
        }
    },

    afterPlayCamera : function(scene, rootData,oldScene,oldRootData,clientMap){
        if (!this._afterPlayCameraListener) {
            return ;
        }
        for(var i = 0 ; i < this._afterPlayCameraListener.length ; i++){
            var l = this._afterPlayCameraListener[i];
            l.call(l.scope||this,scene, rootData,oldScene,oldRootData,clientMap);
        }
    },

    // getFinalCameraTargetAndPosition : function(scene, rootData,oldScene,oldRootData){
       
    // }

});

it.CameraManager = $CameraManager;



// 需要监听数据的变化
var $DataFinder = function (dataManager) {
	this.dataManager = dataManager;
	this.descentdantMap = {};
    this.ancesstorIdsMap = {};
    this.init();
};

mono.extend($DataFinder,Object,{

    /**
     * 可以提前把子孙保存起来
     */ 
    init : function(){
    },

    getGetMethod : function(key){
       var getMethod = 'get' + key.charAt(0).toUpperCase() + key.slice(1);
       return getMethod;
    },

    /**
     * 便于给搜索其他的类型提供扩展
     * @returns {*}
     */
    getDatas : function(){
        return this.dataManager.getDatas();
    },

    /**
     * 便于给其他的类型扩展
     * @param id
     * @returns {*}
     */
    getDataById : function(id){
        return this.dataManager.getDataById(id);
    },

    /**
     * 返回一个数据,用相等匹配
     * 有客户，想按照自己定义的对象来搜索，而该key不是Client中，也不是data的直接属性，有可能是data.自定义obj中的某个属性
     */
     /*
    getDataByKey : function(key,value){
       if(!key && !value){
          return null;
       }
       var searchUserData = false;
       var searchCategory = false;
       var searchDataType = false;
       if(key.toUpperCase().startsWith('U:')){
         searchUserData = true;
         key = key.slice(2);
       }else if (key.toUpperCase().startsWith('C:')) { // category
          searchCategory = true;
          key = key.slice(2);
       }else if(key.toUpperCase().startsWith('D:')){ // dataType
          searchDataType = true;
          key = key.slice(2);
       }
       var getMethod = this.getGetMethod(key);
       var i = 0,datas = this.getDatas(),data;
       for(;i < datas.length;i ++){
          data =datas[i];
          if(searchUserData){
             var userData = data.getUserData(key);
             if(userData == value){
                return data;
             }
          }else if(searchCategory){
            var category = this.dataManager.getCategoryForData(data);
            if(category[getMethod] == null){
                var userData = category.getUserData(key);
                if(userData == value){
                  return data;
                }
            }
            if(category[getMethod]() == value){
               return data;
            }
          }else if(searchDataType){
            var dataType = this.dataManager.getDataTypeForData(data);
            if(dataType[getMethod] == null){
                var userData = dataType.getUserData(key);
                if(userData == value){
                  return data;
                }
            }
            if(dataType[getMethod]() == value){
               return data;
            }
          }else if(data[getMethod] == null){
             var userData = data.getUserData(key);
             if(userData == value){
                return data;
             }
          }
          if(data[getMethod]() == value){
             return data;
          }
          if(key === 'ancestor'){//如：“位置”，则是查询其所有的子孙节点
             if(this.isChild(data,value,this)){
                 return data;
             }
          }
       }
       return null;
    },
    */

    isChild : function(data,ancestorId,scope){
        if(!data || !ancestorId){
            return false;
        }
        if(data.getId() == ancestorId){
            return true;
        }else if(data.getParentId() == ancestorId){
            return true;
        }else if(!data.getParentId()){
            return false;
        }else{
            var parentData = this.dataManager.getDataById(data.getParentId());
            var scope = scope||this;
            return scope.isChild(parentData,ancestorId,scope);
        }
    },

    /**
     * 是不是不考虑这些data，如：不想查花花草草
     * @param data
     * @returns {boolean}
     */
    filter : function(data){
        return true;
    },
    
    isVisible : function(data){
        if (data) {
            var category = this.dataManager.getCategoryForData(data);
            if (category && !category.isVisible()) {
                return false;
            }
        }
        return true;
    },

    /** 
     *  json like {key : "id,name", value: "xxx",type : 'string',operation : 'equal'|'like'|'between','descentdantOf'} operation,比较的类型
     *  descentdantOf 表示是指定值的后代
     */
    find : function(conditions) {
        var datas = this.getDatas();
        if (!datas || datas.length < 1) {
            return [];
        }
        var results = [];
        if (!conditions || conditions.length < 1) {
//            return datas; // 当没有查询条件时应该返回所有,不可这么返回数据源，应该返回一个副本；
            for(var i = 0 ; i < datas.length; i++){
                if(this.isVisible(datas[i]) &&
                   this.filter(datas[i])){
                     results.push(datas[i]);
                }
            }
            return results;
        }
        var data, i = 0, len = datas.length;
        for (; i < len; i++) {
            data = datas[i];
            if(!this.isVisible(data)
                ||!this.filter(data)){
                continue;
            }
            if (this.isDataConformConditions(data, conditions)) {
                results.push(data);
            }
        }
        return results;
    },

    /**
     * conditions:[{dataType:"string",key:"id,description",operation:"like", value:"rack,1"},{dataType:'',key''..},...]
     */
    isDataConformConditions : function(data,conditions){
       var conform = true;
       for(var p in conditions){
          if(!this.isDataConformCondition(data,conditions[p])){
            conform = false;
            break;
          }
       }
       return conform;
    },

    isDataConformCondition : function(data,condition,key){
        if(condition.value == '' || condition.value == null){
            return true;
        }
        var key = key || condition.key;
        var dataType = condition.dataType || 'string'; 
        if(key.indexOf(',') > 0){
            var splitKeys = key.split(',');
            for(var i = 0;i < splitKeys.length;i ++){
                if(this.isDataConformCondition(data,condition,splitKeys[i])){
                    return true;
                }
            }
            return false;
        }
        var searchUserData = false;
        var searchCategory = false;
        var searchDataType = false;
        if(key.toUpperCase().startsWith('U:')){
            searchUserData = true;
            key = key.slice(2);
        }else if (key.toUpperCase().startsWith('C:')) { // category
          searchCategory = true;
          key = key.slice(2);
        }else if(key.toUpperCase().startsWith('D:')){ // dataType
          searchDataType = true;
          key = key.slice(2);
        }
        var getMethod = this.getGetMethod(key);
        // if(data[getMethod] == null){
        //    searchUserData = true;
        // }
        var operation = condition.operation;
        var value = condition.value;
        var dataValue = null;
        // if(searchUserData || data[getMethod] == null){
        //     dataValue = data.getUserData(key);
        // }else{
        //     var getMethod = this.getGetMethod(key);
        //     dataValue = data[getMethod]();
        // }
        if(searchUserData){
            dataValue = data.getUserData(key);
        } else if (searchCategory) {
            var category = this.dataManager.getCategoryForData(data);
            if(category[getMethod] == null){
                dataValue = category.getUserData(key);
            }else {
                dataValue = category[getMethod]();
            }
        }else if(searchDataType){
            var dataType = this.dataManager.getDataTypeForData(data);
            if(dataType[getMethod] == null){
                dataValue = dataType.getUserData(key);
            }else {
                dataValue = dataType[getMethod]();
            }
        }else{
            var getMethod = this.getGetMethod(key);
            dataValue = data[getMethod]&&data[getMethod]();
        }
        if(!dataValue && key==='ancestor'){
            if(this.isChild(data,condition.value,this)){
                return true;
            }
        }
        var compareMethod = this[operation];
        if(typeof compareMethod === 'function'){
           return this[operation](value,dataValue,key); 
        }else{
           return this.other(value,dataValue,key,operation,dataType);
        }
    },
    
    /**
     * 表示相等，可能需要扩展复杂对象的相等。
     */
    equal : function(value,dataValue,key){
        if(value && dataValue){
            return value.toLowerCase() == dataValue.toLowerCase();
        }
       return dataValue == value;
    },

    like : function(value,dataValue,key){
        dataValue = dataValue + '';
        if (dataValue.trim) {
            dataValue = dataValue.trim();
        }
        if (value.trim) {
            value = value.trim();
        }
        // if(dataValue.startsWith){
        //     if(value){
        //         return dataValue.toLowerCase().startsWith(value.toLowerCase());
        //     }
        //    return dataValue.startsWith(value); 
        // }
        value = value.toLowerCase();
        dataValue = dataValue.toLowerCase();
        if (dataValue.indexOf) {
            if (dataValue.indexOf(value) >= 0) {
                return true;
            }
        }
        return false;
    },

    /**
     * 表示在之间
     */
    between : function(value,dataValue,key){
       if(value[0] || value[1]){
          if(value[0] == null) return dataValue <= value[1];
          if(value[1] == null) return dataValue >= value[0];
          return dataValue >= value[0] && dataValue<= value[1];
       }
       return false;
    },

    /**
     * 其他的，或用符号表示的，如：>、<、<=、>=、<>等 ，
     * @param value
     * @param dataValue
     * @param key
     */
    other : function(value,dataValue,key,operation,dataType){
        if(!operation){
            return this.like(value,dataValue,key);
        }
        dataType = dataType||'string';
        // 当比较数字的时候，若其中某个值为0，这里的判断应该还是true才对。  2018-1-23 add by lyz
        if ((value || value == 0) && (dataValue || dataValue == 0)) {
        // if(value && dataValue){
            if(dataType == 'number'){
                dataValue = parseFloat(dataValue);
                value = parseFloat(value);
            }else{
                if(typeof(dataValue) === 'number'){
                   dataValue += '';
                }
            }
            var operation = operation.trim();
            if(operation == '>'){
                return dataValue > value;
            }else if(operation == '<'){
                return dataValue < value;
            }else if(operation == '<='){
                return dataValue <= value;
            }else if(operation == '>='){
                return dataValue >= value;
            }else if(operation == '='){
                if(typeof(dataValue)=='number' || typeof(value)=='number'){
                     return (dataValue === value);
                }else{
                    return dataValue.toLowerCase() == value.toLowerCase();
                }
            }
        }
        return this.like(value,dataValue,key);
    },

    descentdantOf : function(value,dataValue,key){
        if(key !== 'id'){
            throw 'Only id support descentdantOf';
        }
        var data1 = this.getDataById(value);
        var data2 = this.getDataById(dataValue);
        if(data1 == null || data2 == null){
            return false;
        }
        var ancestors = this.dataManager.getAncestors(data2) || [];
        return ancestors.indexOf(data1) !== -1;
    },

});

it.DataFinder = $DataFinder;


var $BuildingToFloorHandle = function(bfAdapter) {
	this.bfAdapter = bfAdapter;
	this.sceneManager = this.bfAdapter.sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.beforeDoubleClickFloorFunction = null;
	// this.animates = []; // 不需要缓存，导致内存泄露
};

mono.extend($BuildingToFloorHandle, Object, {

	/**
     * 在dc和building合在一起的模式下重写双击楼层的动作(doubliClick):
      边拉近镜头到点击的floor,然后它上面的floors都慢慢展开一点点，最后才切换场景
    */
	doubliClickFloorNode: function(element, network, data, clickedObj, callback) {
		if (this.beforeDoubleClickFloorFunction) {
			this.beforeDoubleClickFloorFunction(element);
		}
		if (!data) {
			return;
		}
		var parentData = this.dataManager.getDataById(data.getParentId());
		if (!parentData) {
			return;
		}
		var deHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
		var category = this.dataManager.getCategoryForData(data);
		var scene = this.dataManager.getSceneByCategory(category);
		var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
		if (this.sceneManager._currentScene == scene && sceneAndRootData && this.sceneManager._currentRootData == sceneAndRootData.rootData) {
			deHandler.moveToClickPoint(clickedObj);
			return;
		}
		if (!scene) {
			return;
		}
		if (this.doubleClickFloorNodeFlag) {
			return;
		}
		this.sceneManager.viewManager3d.enableDBLClick = false;
		var virFilter = new it.VirtualManager(this.sceneManager);
		virFilter.opacityValue = 1;
		virFilter.addByDescendant(this.sceneManager._currentRootData);
		virFilter.removeByDescendant(data);
		this.sceneManager.viewManager3d.addMaterialFilter(virFilter);
		this.doubleClickFloorNodeFlag = true; //用于标记是不是已经点击了，并且正在执行。可是当正在执行时，点击背景，此时该怎么搞？
		var floorNodes = [];
		var self = this;
		var children = parentData.getChildren();
		var lookAtFloorNode = this.sceneManager.dataNodeMap[data.getId()];
		for (var i = children.size() - 1; i >= 0; i--) {
			var child = children.get(i);
			var childCategory = this.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
				if (floorNode && floorNode.getY() > lookAtFloorNode.getY()) {
					floorNodes.push(floorNode);
				}
			}
		}
		var camera = this.sceneManager.network3d.getCamera();
		if (network) {
			camera = network.getCamera();
		}

		var focusNode1 = this.sceneManager.viewManager3d.getFocusNode();

		var palyLookAtFun = function() {
			//调用前判断一下是不是换到了其他的场景(比如执行动画前点了背景)，然而怎么判断呢？通过focusNode
			var focusNode2 = self.sceneManager.viewManager3d.getFocusNode();
			if (focusNode2 != focusNode1) {
				this.doubleClickFloorNodeFlag = false;
				self.sceneManager.viewManager3d.enableDBLClick = true;
				return;
			}
			var callback1 = function() {
				camera.fov = 60; //这个值很快会被改变，这里只是为了resetCamer做准备
				/* 
				 *  // update By Kevin 2017-06-21 
				 * toScene会dataBox，_loadOneScene则不会清空dataBox
				 * 为了连贯，采取不清空，而这边单独清空dc、building，以及其兄弟floor
				 */
				// self.sceneManager.toScene(scene, data,callback);
				// self.removeDcAndBuilding(data);
				var oldScene = self.sceneManager.getCurrentScene();
				var oldRootData = self.sceneManager._currentRootData;
				// self.sceneManager.resetCameraWhenSceneChange = false;//下面的场景切换时，不去调用，这样的话不会使用保存的镜头，-- 2017-09-07 Kevin
																		//园区进入楼层时这里为false会导致镜头不会设置为楼层保存的镜头，注释后最后会重置镜头 -- 2018-02-23 jay
				// 需要断开其他的floor中对象与其parent的父子关系 ，loadOneScene后，会将所有的node的父子关系都建立上了
				self.sceneManager._loadOneScene(scene, data, callback); 
				//_loadOneScene中会重新加上父子关系
				if (data) {
					var dataNode = self.sceneManager.dataNodeMap[data.getId()];
					dataNode && dataNode.setParent(null);
					self.sceneManager.viewManager3d.setFocusNode(dataNode);
				}
				self.doubleClickFloorNodeFlag = false;
				self.sceneManager.viewManager3d.enableDBLClick = true;
				//2017-10-26 统一一下，使得cameraManager中的callback方法永远能执行
				//2018-3-1 这里不需要执行AfterPlayCamer的回调，在动画执行完毕后会执行该回调
				// if(self.sceneManager.cameraManager.callback){ 
				// 	self.sceneManager.cameraManager.callback(scene, data,oldScene,oldRootData);
				// } 
			};
			callback1();
		};

		var dataPosition = data.getPosition();
		var oldPosition = lookAtFloorNode.getWorldPosition().clone();
		var nScale = lookAtFloorNode.getScale();

		var getAbsoluteRotationByNode = function(node) {
			if (!node) {
				return null;
			}
			var rot = node.getRotation().clone();
			var parentNode = node.getParent();
			if (parentNode) {
				var pRot = getAbsoluteRotationByNode.call(this, parentNode);
				if (pRot) {
					rot.x = rot.x + pRot.x;
					rot.y = rot.y + pRot.y;
					rot.z = rot.z + pRot.z;
				}
			}
			return rot;
		}

		var rotation = getAbsoluteRotationByNode(lookAtFloorNode);
		/**
		 * 重新设置回该floor的Scale，并且将其position设置成其真实的位置
		 * 并且Camera也慢慢的拉远
		 */
		var restorePosScaleAndRotationCallback = function() {
			var fBb = lookAtFloorNode.getBoundingBox();
			var oldDistance = camera.getDistance();
			var distance = fBb.size().z > fBb.size().x ? fBb.size().x : fBb.size().z;
			distance = distance * 2;
			var angles = mono.Utils.getVectorAngles(camera.target, camera.getPosition());
			var dataRotation = data.getRotation() || new mono.Vec3();
			var restorePosAndScaleAnimate = new mono.Animate({
				from: 0,
				to: 1,
				dur: 1000,
				onUpdate: function(value) {
					var pos = new mono.Vec3().lerpVectors(oldPosition, dataPosition, value);
					lookAtFloorNode.setPosition(pos);
					if (lookAtFloorNode.orgScale) {
						var oScale = lookAtFloorNode.orgScale.clone();
						lookAtFloorNode.setScaleX(nScale.x + (oScale.x - nScale.x) * value);
						lookAtFloorNode.setScaleY(nScale.y + (oScale.y - nScale.y) * value);
						lookAtFloorNode.setScaleZ(nScale.z + (oScale.z - nScale.z) * value);
					}
					lookAtFloorNode.setRotationX(rotation.x + (dataRotation.x * mono.Utils.DEGREES_TO_RADIANS - rotation.x) * value);
					lookAtFloorNode.setRotationY(rotation.y + (dataRotation.y * mono.Utils.DEGREES_TO_RADIANS - rotation.y) * value);
					lookAtFloorNode.setRotationZ(rotation.z + (dataRotation.z * mono.Utils.DEGREES_TO_RADIANS - rotation.z) * value);

					var d = (oldDistance + (distance - oldDistance) * value); // 这个400是moveCameraToCloseFloor(之前镜头的距离)中
					
					var cPos = new mono.Vec3(); 
					// pos.x = camera.target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// pos.z = camera.target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// pos.y = camera.target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					// add 直接用floor的position，也就是一直盯着floor update 2017-07-11
					var target = pos.clone();
					cPos.x = target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					cPos.z = target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					cPos.y = target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
					camera.setPosition(cPos);
					camera.lookAt(target);
				},
				onStop: function() {
					// playFinalCamera();
					palyLookAtFun();
				}
			});
            // self.animates.push(restorePosAndScaleAnimate); //始终不释放，导致内存泄露 ， 2017-10-12
			restorePosAndScaleAnimate.play();
		}

		/**
		 * 1、将镜头的焦点对着floor
		 * 2、断开floor与building的父子关系
		 * 不调用这步，直接restorePosAndScaleAnimate，这样在空间没有参照物有点不太协调，很突然的感觉
		 */
		var moveCameraToFocusFloorAndRemoveRelactionShipAnimate = function() {
			var callback = function() {
				self.removeDcAndBuilding(data);
				if (lookAtFloorNode.orgScale) {
					lookAtFloorNode.setScaleX(nScale.x);
					lookAtFloorNode.setScaleY(nScale.y);
					lookAtFloorNode.setScaleZ(nScale.z);
				}
				lookAtFloorNode.setRotationX(rotation.x);
				lookAtFloorNode.setRotationY(rotation.y);
				lookAtFloorNode.setRotationZ(rotation.z);
				lookAtFloorNode.setPosition(oldPosition);
				self.sceneManager.viewManager3d.removeMaterialFilter(virFilter);
				restorePosScaleAndRotationCallback();
			}
			// callback(); 
			// 这一步将镜头对着点中的floor 
			var distance = camera.getDistance();
			var cTarget = camera.target;
			var cPos = camera.getPosition();
			var angles= mono.Utils.getVectorAngles(cTarget, cPos);
			var vAngle = angles[1],hAngle = angles[0];
			var endTarget = lookAtFloorNode.getWorldPosition();
            // 某些情况下此处的mono.Animate不会执行下去，应该使用twaver.Animate则能正常使用
            // 某些情况包括：当处于楼层展开状态时，若在此时使用lookAtByData看向某个楼层，则会产生这种情况 2017-12-12 add by lyz
			var animate = new twaver.Animate({
				from: 0,
				to: 1,
				dur: 1000,
				onUpdate: function(value) {
					var t = new mono.Vec3().lerpVectors(cTarget,endTarget, value); 
					var newPos = new mono.Vec3();
					newPos.x = t.x + distance * Math.sin(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					newPos.z = t.z + distance * Math.cos(hAngle * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					newPos.y = t.y + distance * Math.sin(vAngle * mono.Utils.DEGREES_TO_RADIANS);
					camera.p(newPos);
					camera.lookAt(t);
				},
				onStop: function() {
					callback();
				}
			});
			animate.play();
		}

		/**
		 * 边展开边消失
		 */
		var doubliClickFloorNodeAnimate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 1000,
			easing: 'easeOut',
			onUpdate: function(value) {
				for (var i = floorNodes.length - 1; i >= 0; i--) {
					var floor = floorNodes[i];
					var floorData = self.sceneManager.getNodeData(floor);
					var y = parseFloat(floorData.getPosition().y / 10);
					floor.setY(y + 50 + 200 * value);
				}
				virFilter.opacityValue = (1 - value);
				virFilter.materialMap = {};
			},
			// onDone: function() { //不管是stop还是正常执行完，这个一定是被执行
			onStop: function() {
				moveCameraToFocusFloorAndRemoveRelactionShipAnimate();
			}
		});
		doubliClickFloorNodeAnimate.play();

	},

	/**
	 * 清除DataBox中的所有3D对象，除了exceptData外
	 * exceptData上的孩子也不应该删除？或者在下一个场景(应该是floor)中存在时就不应该移除
	 */
	removeDcAndBuilding: function(exceptData) {
		if (!exceptData) {
			return;
		}
		var exceptNode = this.sceneManager.getNodeByDataOrId(exceptData);
		for (var id in this.sceneManager.dataNodeMap) {
			var node = this.sceneManager.dataNodeMap[id];
			if (node && !this.sceneManager.isAncestor(id,exceptData.getId())) {//理论上判断id和exceptData是不是在同一个场景中更加合理
				node.setParent(null);
			}
		}
		for (var id in this.sceneManager.dataNodeMap) {
			var node = this.sceneManager.dataNodeMap[id];
			if (node && id != exceptData.getId() && !this.sceneManager.isAncestor(id,exceptData.getId())) {
				this.sceneManager.network3d.dataBox.removeByDescendant(node);
			}
		}
	},



});
/**
 * 从楼层退回到园区
 * 主要流程：
 * 1、创建一个虚化管理器，并且opacityValue为0(相当于隐藏)，将dc及其所有的除了当前floor之外的对象都放到虚化管理器中；
 * 2、load园区的所有对象，注意这个load不是场景切换的load，并设置focusNode为building；
 * 3、播放当前floor的动画，将它移动到最终在building上的位置，同时变换scale和rotation；3秒
 * 4、慢慢的改变1步创建的虚幻管理器的opacityValue的值，是所有的对象慢慢显示；3秒
 * 5、显示好后移除1步的虚幻管理器，并且从databox中移除floor中的所有孩子；
 * 需要注意的是：
 * 1、其他floor场景的父子关系也应该切断
 * 2、在Floor场景下，通过其他的途径进入DC时的处理(如：在floor场景下，点击搜索树或面包屑上的dc的方式进入dc)
 * 
 */
var $FloorToBuildingHandle = function(bfAdapter) {
	this.bfAdapter = bfAdapter;
	this.sceneManager = bfAdapter.sceneManager;
	this.virFilter = new it.VirtualManager(this.sceneManager);
	this.virFilter.opacityValue = 0.01;
	// virFilter.addByDescendant(this.sceneManager._currentRootData);
	// virFilter.removeByDescendant(data);
	// this.oldIsNeedSetParent = this.sceneManager.isNeedSetParent; //可以这么早就保存了，3d机房
	// this.oldTranslatePosition = this.sceneManager.translatePosition;
	this.oldResetCamera = this.sceneManager.resetCamera;
	this.defaultEventHandler = this.sceneManager.viewManager3d.defaultEventHandler;
	this.animates = [];
	this.init();
};

mono.extend($FloorToBuildingHandle, Object, {

	init: function() {
		var self = this;
        
        /*
		var oldGotoUpLevelSceneFor3D = this.sceneManager.gotoUpLevelSceneFor3D;
		this.sceneManager.gotoUpLevelSceneFor3D = function() { //当不是点的背景呢？
			var scene = self.sceneManager._currentScene;
			if (!scene) {
				return false;
			}
			var rootNode = self.sceneManager._currentRootNode;
			var rootData = self.sceneManager._currentRootData;
			if (!rootNode && !rootData) {
				return false;
			}
			var data = self.sceneManager.getNodeData(rootNode);
			if (!data) {
				data = rootData;
			}
			var parentData = self.sceneManager.getUpLevelDataByData(data);
			if (!parentData) {
				return false;
			}
			var parentScene = self.sceneManager.getSceneAndRootByData(parentData);
			if (!parentScene || !parentScene.scene) {
				return false;
			}
			if (parentScene.scene.getId().toLowerCase() == 'datacenter' && scene.getId() == 'floor') {
				self.doFloorToDatacenter(parentScene.scene, parentScene.rootData, scene, data);
			} else {
				oldGotoUpLevelSceneFor3D.call(self.sceneManager);
			}
		}
		*/
	},
     
    /**
     * 摧毁，初步计划是可以动态的扭转floor-dc的业务流程
     */
	destroy: function(){

	},

	// 增加了floor到building的gotoSceneCallback。解决问题是，在floor点击dc的导航，需要直接进去dc，而不是building。因此在gotoScene前往building后，在进行一些操作，进入dc
	// 2017-12-12 add by lyz
	doFloorToDatacenter: function(dcScene, dc, floorScene, floor, gotoSceneCallback) {
		var self = this;
		/**
		 * 在floor场景load园区后，不设置该floor的父亲，也不设置其位置和rotation，以及镜头也不动 
		 */
		this.oldIsNeedSetParent = this.sceneManager.isNeedSetParent; 
		this.sceneManager.isNeedSetParent = function(data, node) {
			if (data == floor) {
				return false;
			} else {
				return self.oldIsNeedSetParent.call(self.sceneManager, data, node);
			}
		}
		this.oldTranslatePosition = this.sceneManager.translatePosition;
		this.sceneManager.translatePosition = function(data) {
			if (data == floor) {
				return null;
			} else {
				return self.oldTranslatePosition.call(self.sceneManager, data);
			}
		}
        //这样直接重写，得有个地方还原！！！
        var oldResetCamera = this.sceneManager.resetCamera;
		this.sceneManager.resetCamera = function() {
			return null;
		}

        this.sceneManager.viewManager3d.enableDBLClick = false;
		var floorNode = this.sceneManager.getNodeByDataOrId(floor);
		/**
		 * 将load的动西全部隐藏掉，其透明度为0，除了当前的floor外
		 */
		this.sceneManager.viewManager3d.addMaterialFilter(this.virFilter);
		this.virFilter.opacityValue = 0;
		this.virFilter.materialMap = {};
		this.virFilter.addByDescendant(dc);
		this.virFilter.removeByDescendant(floor);
		var defaultHandler = this.sceneManager.viewManager3d.defaultEventHandler;

		// this.bfAdapter.bindingBuildingAndFloorVisibleManager.setVisible(floor, true);//默认在园区floor都隐藏 
		var callback = function(endCallback) {
			var buildingNode = self.sceneManager.getNodeByDataOrId(floor.getParentId());
			var bData = self.sceneManager.dataManager.getDataById(floor.getParentId());
			// var floorNodes = self.getFloorsByBuildingNode(buildingNode);
			var dcNode = self.sceneManager.getNodeByDataOrId(bData.getParentId());
			if (dcNode) {
				// self.sceneManager.viewManager3d.setFocusNode(dcNode); // 有可能是直接从其他的入口进入的，退回去时，先处理一下dc
				//需要注意的是这里也会触发switchBuilding，会导致回退f时floor一下子就是scale后的状态
				self.sceneManager.viewManager3d.defaultMaterialFilter.addAll();
                self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(dcNode);
			}
			self.sceneManager.viewManager3d.setFocusNode(buildingNode);
			var floorNodes = self.getFloorsByBuildingNode(buildingNode); // 放到setFocus之后 2017-10-11，否则开启了floor的延迟加载和清空缓存会有问题
			// if (floorNodes && floorNodes.length > 1) { 
			// 	defaultHandler.moveCameraForLookAtNodes(floorNodes, null, 30);
			// } else {
			// 	defaultHandler.moveCameraForLookAtNode(buildingNode, callback1);
			// }
			self.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // 脱离BuidingAndFloorChangeAdapter，自己管理
			// self.sceneManager.viewManager3d.defaultMaterialFilter.add(bData);
			// 场景切换到dc后，该floor上的building需要虚化，但是兄弟floor不需要，还有就是需要重新设置兄弟floor的位置
			self.sceneManager.viewManager3d.defaultMaterialFilter.addByDescendant(bData); //建筑上的非floor的孩子也要虚幻
			for (var i = 0; i < floorNodes.length; i++) {
				var fNode = floorNodes[i];
				var fData = self.sceneManager.getNodeData(fNode);
				self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(fData);
				// self.bfAdapter.bindingBuildingAndFloorVisibleManager.setVisible(fData, true); //可是在sceneChange时将floor都设置成了不显示
				if (fData != floor) {
					fNode.setParent(buildingNode);
					fNode.setY(fData.getPosition().y / 10 + 50); // +50是展开后弹的开的高度
					self.sceneManager.computeRotation(fData, bData, fNode, buildingNode);
					var fScale = self.getFloorScaleInDc(fNode, buildingNode) || new mono.Vec3(1, 1, 1);
					fNode.setScale(fScale);
				}
			}
			setTimeout(function() {
				self.removeChildrenByFloorNode(floorNode);
				self.doFloorPRSAnimate(floorNode,endCallback);
			}, 500);
		}
		//这里先情况一半然后再load，最后再清空之前的另一半，这里很容易出现bug
		//2017-10-20 不能清除一半，父子关系没有断掉的话，在_loadOneScene中会给node重新设置it_data_id和it_data会把floor的孩子机柜设备都置成了floor
		// this.clearOtherFloorParentRelaction(floor); 
		this.clearOtherFloorParentRelaction(); 
		this.animates = [];
		var oldScene = self.sceneManager.getCurrentScene();
		var oldRootData = self.sceneManager._currentRootData;
		this.sceneManager._loadOneScene(dcScene, dc);
		// this.setBrotherFloorPositionY(floor);
		this.sceneManager.resetCamera = oldResetCamera; // 还原
		var endCallback = function(){
			if(self.sceneManager.cameraManager.callback){ 
				self.sceneManager.cameraManager.callback(dcScene, dc,oldScene,oldRootData);
			}
			gotoSceneCallback&&gotoSceneCallback();
		};
		callback(endCallback);
		this.sceneManager.isNeedSetParent = this.oldIsNeedSetParent;
		this.sceneManager.translatePosition = this.oldTranslatePosition;
	},

    /**
     * 回到园区时，楼层是展开且弹开的，上升了50
     */
    /*
	setBrotherFloorPositionY : function(floor){
		if (!floor) {
			return ;
		}
		var parent = this.sceneManager.dataManager.getDataById(floor.getParentId());
		var children = parent.getChildren();
		if (children && children.size() > 1) {
			for(var i = 0 ; i < children.size() ; i++){
				var child = children.get(i);
				var cCategory = this.sceneManager.dataManager.getCategoryForData(child);
				if (cCategory 
					&& cCategory.getId() == 'floor' 
					&& child != floor) {
					var childNode = this.sceneManager.getNodeByDataOrId(child);
				    childNode.setY(childNode.getY() + 50);
				}
			}
		}
	},
	*/

    /**
     * 清除其他楼层的父子关系，特别是楼层和楼层的孩子
     * 否则当从楼层切换到楼层，然后再退回到dc时，会有问题
     */
	clearOtherFloorParentRelaction: function(floor){
		var floors = this.sceneManager.dataManager._categoryDatas['floor'];
		if (!floors) {
			return ;
		}
		var self = this;
		for(var id in floors){
			var fData = this.sceneManager.dataManager.getDataById(id);
			if (fData && fData != floor 
				&& fData.getChildren() 
				&& fData.getChildren().size() > 0) {
				// fData.getChildren().forEach(function(child){
				// 	var childNode = self.sceneManager.getNodeByDataOrId(child);
				// 	if (childNode) {
				// 		childNode.setParent(null);
				// 	}
				// });
                this.clearRelactionByParentData(fData);
			}
		}
	},

	/**
	 *
	 * 改变floor的position、rotation、scale,使之变成在园区时的值
	 * 还有就是需要改变Camera，使之lookAt该floor对应的building
	 *
	 */
	doFloorPRSAnimate: function(floor,endCallback) {
		if(!floor){
			this.sceneManager.viewManager3d.enableDBLClick = false;
			return;
		}
		var self = this;
		var buildingNode = this.getBuildingNodeByFloor(floor);
		var floorNodes = this.getFloorsByBuildingNode(buildingNode);
		var endPos = this.getFloorPositionInDc(floor,buildingNode) || new mono.Vec3();
		var endRot = this.getFloorRotationInDc(floor,buildingNode) || new mono.Vec3();
		var endScale = this.getFloorScaleInDc(floor,buildingNode)  || new mono.Vec3(1,1,1);
		var camera = this.sceneManager.network3d.getCamera();
		var oldTarget = camera.target.clone();
		// 算最终的target和pos，那floorNodes也应该是终止状态，但是此时当前的floor并没有缩放，暂时用building(不合理，bb没有)
		var tarAndPos = null;
		if (floorNodes.length == 1) {
			tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookAtNodes([buildingNode],30);
		}else{
			 var endingFloors = this.getEndingFloorsByFloors(floorNodes,buildingNode,floor);
			 tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookAtNodes(endingFloors,30);
		}
		// var tarAndPos = this.defaultEventHandler.getCameraTarAndPosForLookArNodes([buildingNode],30);
		var angles = mono.Utils.getVectorAngles(tarAndPos.target, tarAndPos.position);
		
		var oldDistance = camera.getDistance();
		var newDistance = tarAndPos.position.distanceTo(tarAndPos.target);
		var fPos = floor.getWorldPosition();
		var fRot = floor.getRotation();
		var fScale = floor.getScale();
		var animate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 2000,
			onUpdate: function(value) {
				var pos = new mono.Vec3().lerpVectors(fPos, endPos, value);
				floor.setPosition(pos);
				floor.setScaleX(fScale.x + (endScale.x - fScale.x) * value);
				floor.setScaleY(fScale.y + (endScale.y - fScale.y) * value);
				floor.setScaleZ(fScale.z + (endScale.z - fScale.z) * value);
				floor.setRotationX(fRot.x + (endRot.x - fRot.x) * value);
				floor.setRotationY(fRot.y + (endRot.y - fRot.y) * value);
				floor.setRotationZ(fRot.z + (endRot.z - fRot.z) * value);
                
                var target = new mono.Vec3().lerpVectors(oldTarget, tarAndPos.target, value);
				var d = (oldDistance + (newDistance - oldDistance) * value); // 这个400是moveCameraToCloseFloor(之前镜头的距离)中
				var cameraPos = new mono.Vec3();
				cameraPos.x = target.x + d * Math.sin(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				cameraPos.z = target.z + d * Math.cos(angles[0] * mono.Utils.DEGREES_TO_RADIANS) * Math.cos(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				cameraPos.y = target.y + d * Math.sin(angles[1] * mono.Utils.DEGREES_TO_RADIANS);
				camera.setPosition(cameraPos);
				camera.lookAt(target);
			},
			onStop: function() {
				self.setFloorRelationShipAndPosition(floor,buildingNode);
				self.doFadeOutAnimate(floor,floorNodes,endCallback);
				self.animates = [];// 运行完了释放 2017-10-12
			}
		});
        this.animates.push(animate);
		animate.play();
	},

	/**
	 * 隐藏的东西慢慢的显示出来
	 */
	doFadeOutAnimate: function(floorNode,floorNodes,endCallback) {
		var self = this;
		var oldSortNodes = this.sceneManager.network3d.sortNodes;
		this.sceneManager.network3d.sortNodes = false;
		var animate = new mono.Animate({
			from: 0,
			to: 1,
			dur: 2000,
			onUpdate: function(value) {
				self.virFilter.opacityValue = 0.16 + (1-0.16) * value ; //最下值应该是其正常情况下的透明度值
                self.virFilter.materialMap = {};
                self.sceneManager.network3d.dirtyNetwork();
			},
			onStop: function() {
				self.sceneManager.viewManager3d.removeMaterialFilter(self.virFilter);
				self.sceneManager.viewManager3d.enableDBLClick = true;
				// self.removeChildrenByFloorNode(floorNode);
				if (!floorNodes || floorNodes.length <= 1) {
					self.sceneManager.viewManager3d.setFocusNode(self.sceneManager.getCurrentRootNode());
				}
				self.animates = [];//运行完了释放 2017-10-12
				endCallback && endCallback();
				self.sceneManager.network3d.sortNodes = oldSortNodes;
			}
		});
		this.animates.push(animate);
		animate.play();
	},

	stopAllAnimate : function(){
		if (this.animates && this.animates.length > 0) {
			for(var i = 0 ; i < this.animates.length ; i++){
				var animate = this.animates[i];
				animate.stop();
			}
		}
		this.animates = [];
	},

	setFloorRelationShipAndPosition: function(floorNode, buildingNode) {
		if (!floorNode || !buildingNode) {
			return;
		}
		var fData = this.sceneManager.getNodeData(floorNode);
		var bData = this.sceneManager.getNodeData(buildingNode);
		var pos = new mono.Vec3();
		var rot = new mono.Vec3();
		if (fData.getPosition()) {
			pos.setY(fData.getPosition().y / 10 + 50); //+50是展开并弹开后的
			pos.setX(fData.getPosition().x);
			pos.setZ(fData.getPosition().z);
		}
		this.sceneManager.computeRotation(fData,bData,floorNode,buildingNode);
		floorNode.setPosition(pos);
		// floorNode.setRotation(rot);
		floorNode.setParent(buildingNode);
	},

    /**
     * 移除该楼层中所有的对象，并且断掉这些对象的父子关系
     * 是不是也需要考虑切断其他楼层的父子关系呢？
     *  如：从floor01切到floor02，然后再返回到dc
     */
	removeChildrenByFloorNode : function(floorNode){
		if (!floorNode) {
			return;
		}
		var floorData = this.sceneManager.getNodeData(floorNode);
		this.sceneManager.network3d.dataBox.removeByDescendant(floorNode);
		this.clearRelactionByParentData(floorData);
		this.sceneManager.network3d.dataBox.addByDescendant(floorNode);
		if (this.sceneManager.isClearCache) {
			this.sceneManager.clearCache();
		}
	},

	clearRelactionByParentData : function(parentData){
		if (!parentData) {
			return;
		}
		var children = parentData.getChildren();
		if (!children || children.size() < 1) {
			return ;
		}
		for(var i = 0 ; i < children.size() ; i++){
			var child = children.get(i);
			var childNode = this.sceneManager.getNodeByDataOrId(child);
			if (childNode) {
				childNode.setParent(null);
			}
			this.clearRelactionByParentData.call(this,child);
		}
	},

	getBuildingNodeByFloor : function(floor){
		if (!floor) {
			return null;
		}
		var fData = this.sceneManager.getNodeData(floor);
		var parentId = fData.getParentId();
		var pCategory = this.sceneManager.dataManager.getCategoryForData(parentId);
		if (pCategory && pCategory.getId().toLowerCase() == 'building') {
			return this.sceneManager.getNodeByDataOrId(parentId);
		}
		return null;
	},

	getFloorsByBuildingNode: function(buildingNode) {
		var bData = this.sceneManager.getNodeData(buildingNode);
		var children = bData.getChildren();
		var floors = [];
		for (var i = 0; i < children.size(); i++) {
			var child = children.get(i);
			var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
			    floors.push(floorNode);
			}
		}
		return floors;
	},

	getEndingFloorsByFloors : function(floorNodes,buildingNode,currentloor){
		if (!floorNodes) {
			return null;
		}
		var cloneFloors = [];
		for (var i = 0; i < floorNodes.length; i++) {
			var fn = floorNodes[i];
			var cfn = fn.clonePrefab();
			if (fn == currentloor) {
				var scale = this.getFloorScaleInDc(currentloor,buildingNode);
				if(scale){
					cfn.setScale(scale);
				}
				var fnPos = fn.p().clone();
				fnPos.setY(fnPos.y/10);
				cfn.setPosition(buildingNode.p().clone().add(fnPos));//该floor的位置还没有相对父亲
			}else{
				cfn.setPosition(fn.getWorldPosition());
			}
			cloneFloors.push(cfn);
		}
		return cloneFloors;
	},
    
    /**
     * 获取floor在dc场景中的位置：
     * y是缩小了10倍的
     * x,z是（0，0），可以0，0也不太对，在园区中有偏移量
     */
	getFloorPositionInDc: function(floor,buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var fData = this.sceneManager.getNodeData(floor);
		if (buildingNode) {
			var pos = buildingNode.getWorldPosition().clone();
			if (fData.getPosition() && fData.getPosition().y) {
				pos.setY(pos.y+fData.getPosition().y/10 +  50); //+50是展开并弹开后的
				pos.setX(pos.x+fData.getPosition().x);
				pos.setZ(pos.z+fData.getPosition().z);
			}
			return pos;
		}
		return null;
	},

    /**
     * 获取floor在dc场景中的旋转角度（绝对）
     */
	getFloorRotationInDc: function(floor,buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var rotation = new mono.Vec3();
		if (floor) {
			rotation = floor.getRotation().clone();
		}
		var bRot = buildingNode.getRotation().clone();
		if (bRot) {
			rotation = rotation.add(bRot);
		}
		return rotation;
	},

	getFloorScaleInDc: function(floor, buildingNode) {
		if (!floor || !buildingNode) {
			return null;
		}
		var bData = this.sceneManager.getNodeData(buildingNode);
		var bSacle = buildingNode.getScale();
		// var buildingBoundingBox = buildingNode.getBoundingBox();
		var buildingBoundingBox = it.Util.getBoundingBox(buildingNode);
		var children = bData.getChildren();
		var minScaleX = 10,
			minScaleZ = 10; // 用最大的，如果每个floor都不一样大时,所有的floor都用等比例缩放
		for (var i = 0; i < children.size(); i++) {
			var child = children.get(i);
			var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
			if (childCategory &&
				childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
				var floorNode = this.sceneManager.dataNodeMap[child.getId()];
				if (floorNode) {
					if (!floorNode.orgScale) {
						floorNode.orgScale = floorNode.getScale().clone();
					}
					if (!floorNode.orgPosY) {
						floorNode.orgPosY = floorNode.getPositionY();
					}
					var floorNodeBoundingBox = floorNode.getBoundingBox();
					if (buildingBoundingBox && floorNodeBoundingBox) {
						var bbSize = buildingBoundingBox.size();
						var fSize = floorNodeBoundingBox.size();
						var scaleX = 0.1,
							scaleZ = 0.1;
						if (bbSize && fSize) {
							if (bbSize.x != -Infinity && bbSize.x != Infinity && fSize.x != -Infinity && fSize.x != Infinity) {
								scaleX = bbSize.x / fSize.x;
							}
							if (bbSize.z != -Infinity && bbSize.z != Infinity && fSize.z != -Infinity && fSize.z != Infinity) {
								scaleZ = bbSize.z / fSize.z;
							}
						}
						if (scaleX < minScaleX) {
							minScaleX = scaleX;
						}
						if (scaleZ < minScaleZ) {
							minScaleZ = scaleZ;
						}
					}
				}
			}
		}
		// return new mono.Vec3(minScaleX * bSacle.x, 0.1, minScaleZ * bSacle.z);
		var scale = minScaleX>minScaleZ ? minScaleZ : minScaleX;
		return new mono.Vec3(scale * bSacle.x, scale>0.1?scale:0.1, scale * bSacle.z);
	}
});

/**
 * 焦点改变的基类适配
 * 类似于真假切换这样的功能都可以通过继承该类来实现
 *
 * 备注：
 *   1、类似于直接从通道或其他的机柜直接看到机柜的情况，其实这样会触发两个动作：
 *        动作1：真到假
 *        动作2：假到真
 *   2、
 */
$BaseFocuseChangeAdapeter = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.box = this.sceneManager.network3d.getDataBox();
};

mono.extend($BaseFocuseChangeAdapeter,Object,{

 //    //bug 2016-11-21 从dc-building顶上的孩子(冷水塔),dc是有真假的
 //    /*add 注意 by Kevin 2016-12-01
 //    注意：由于此类会被很多类继承，很有可能最开始执行的改变了某些属性使得后来的没法正常执行，如：
 //       最开始的complexNodeAndSimpleNodeChangeAdapter执行后，complexNode和simpleNode的父子关系已经改变过，
 //       接下来的的实例就很有可能执行不了,realToFake 和 fakeToReal了
 //     改进：将这块移到其管理类中，然后在realToFake、fakeToReal以及focusNodeChange中遍历BaseFocuseChangeAdapeter的实例，然后一一执行,这
 //          样就不会遗漏没有执行的，但是在每个BaseFocuseChangeAdapeter实例中，需要注意所得到的node和oldNode的某些属性(如:真假对象的父子关系,以及是否加到了box中)
 //          可能被之前执行的实例更改过
 //          移至其管理类(PropertyChangeAdaperManager)中
 //    */
	// focusChange: function(event) {
	// 	var self = this;
	// 	if (event && event.property == "focusNode") {
	// 		var oldNode = event.oldValue;
	// 		var node = event.newValue;
	// 		if (oldNode) {
	// 			var simpleNode = oldNode.getClient('simpleNode');
	// 			//真 —— 假 ,并且不是父子(如果是lookAt机柜 到 lookAt该机柜中的设备，此时是不需要卸载的，可是如果是孙子呢？？？，因此改成不是子孙)
	// 			if (simpleNode && simpleNode.getParent() != oldNode && !self.isChild(oldNode, node)) {
	// 				self.realToFake(oldNode, node);
	// 			}
	// 		}

	// 		if (node) {
	// 			var complexNode = node.getClient('complexNode');
	// 			if (complexNode && complexNode.getParent() != node) { // 假 —— 真 
	// 				var simpleNode = node.getClient('simpleNode');
	// 				self.fakeToReal(oldNode, node);
	// 			}
	// 		}

	// 		self.focusNodeChange(oldNode, node);
	// 	}
	// },

	// isChild : function(parentNode,childNode,scope){
	// 	scope = scope || this;
 //        if(!parentNode || !childNode){
 //            return false;
 //        }
 //        var pdata = parentNode;
 //        if (parentNode instanceof mono.Element) {
 //        	pdata = scope.sceneManager.getNodeData(parentNode);
 //        }
 //        if(!pdata) {
 //            return false;
 //        }
 //        var cdata = childNode;
 //        if (childNode instanceof mono.Element) {
 //        	cdata = scope.sceneManager.getNodeData(childNode);
 //        }
 //        if(!cdata || !(cdata instanceof $Data)){
 //            return false;
 //        }
 //        var pDataScene = scope.sceneManager.getSceneFromData(pdata);
 //        var cDataScene = scope.sceneManager.getSceneFromData(cdata);
 //        if ((!pDataScene && cDataScene) 
 //        	|| (pDataScene && !cDataScene)
 //        	|| (pDataScene != cDataScene)) {
 //        	return false;
 //        }
 //        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
 //            return true;
 //        }else{
 //        	var cdataParent = scope.sceneManager.dataManager.getDataById(cdata.getParentId());
 //        	return scope.isChild(pdata,cdataParent,scope);
 //        }
 //        // return false;
 //    },
    
    /**
     * 真的切换到（假的/真的[这个"真"是其他的真]）
     */
    realToFake :function(oldNode,node){

    },

    /**
     * (假的/真的)切换到真的
     */
    fakeToReal : function(oldNode,node){

    },

    /**
     * 只是焦点改变时
     */
    focusNodeChange :function(oldNode,node){

    },

    startInit : function(){

    },

    destroy : function(){

    }


});

it.BaseFocuseChangeAdapeter = $BaseFocuseChangeAdapeter;



/**
 * 简单对象和复杂对象切换适配
 * 如视角从机柜 到 看到其他的机柜(或通道等)
 * add 2017-07-14:需要考虑跨场景的情况，如从机柜切换到building时，
 *   有可能building所在的dc也有真假的问题，所以如果你不去对dc做真假切换只对机柜和building做真假切换的话，
 *   园区此时是出不来的，所以你需要考虑到这种情况。目前就dc比较特别
 *   目前对于一级一级lookAt下去的话，看到了孙子grant是不会切换成假的了——这块没错
 *      所以对于fakeToReal时，如果parent是假(并且在同一场景中)的话也需要切成真的，
 *  ——— 这块的处理移至AdapterManager中，因为有可能自身没有真假对象，但是父亲有的情况，这种情况就不走这里了
 */
$ComplexNodeAndSimpleNodeChangeAdapter = function(sceneManager){
	$BaseFocuseChangeAdapeter.call(this,sceneManager);
};

mono.extend($ComplexNodeAndSimpleNodeChangeAdapter,$BaseFocuseChangeAdapeter,{
	/**
     * 真的切换到假的
     * 如果old是link，并且link的某个端正好在该真对象中的，比如:oldNode(link)连接的是node中的设备或端口
     */
	realToFake: function(oldNode, node) {
		if (!oldNode) { //其实基类已经处理了，这里绝对不会为空
			return null;
		}
		var self = this;
		var complexNode = oldNode.getClient('complexNode');
		var simpleNode = oldNode.getClient('simpleNode');
		var data = this.sceneManager.getNodeData(oldNode);
		complexNode.setParent(null);
		simpleNode.setParent(oldNode);
		if (this.box.getDataById(oldNode.getId())) { //表示没有clear（即没移到其他的场景中）,注意如果从机柜一下子跳到了dc场景呢？？
			var fromNode = null,toNode = null;
			var nodeData = this.sceneManager.getNodeData(node);
			if (nodeData && nodeData instanceof it.Link) {
				fromNode = this.sceneManager.getNodeByDataOrId(nodeData.getFromId());
				toNode =  this.sceneManager.getNodeByDataOrId(nodeData.getToId());
			}
			// 这里的filter需要好好捋捋
			this.box.removeByDescendant(oldNode, false, function(child) {
				var childData = self.sceneManager.getNodeData(child);
				var childType = self.dataManager.getDataTypeForData(childData);
				if (childType && !childType.isLazyable()) {
					return false;
				}
				if (fromNode && (fromNode == child || child.getParent() == fromNode)) { //设备或端口
					return false;
				}
				if (toNode && (toNode == child || child.getParent() == toNode)) {
					return false;
				}
				if (childData && data && childData.getParentId && childData.getParentId() === data.getId()) {
					return true;
				}
				return false;
			});
			this.box.removeByDescendant(complexNode);
			this.box.addByDescendant(simpleNode, function(node) {
				return true;
			});
			this.sceneManager._sceneManagerChangeDispatcher.fire({
				kind: 'change',
				data: oldNode
			});
		}
		// 并把门关上：
		this.sceneManager.viewManager3d.getDefaultEventHandler().closeDoor(complexNode);
	},

    /**
     * 假的切换到真的
     */
	fakeToReal: function(oldNode, node) {
		if (!node) {
			return;
		}
		var simpleNode = node.getClient('simpleNode');
		var complexNode = node.getClient('complexNode');
		simpleNode.setParent(null);
		complexNode.setParent(node);
		this.box.addByDescendant(complexNode, function(node) {
			return true;
		});
		this.box.removeByDescendant(simpleNode);
		this.sceneManager._sceneManagerChangeDispatcher.fire({
			kind: 'change',
			data: node
		});
	},
	
	/**
	 * 这个函数通过rack的后代元素获取rack（包括rack自身这种情况）
	 */
	getRackByData: function(curData){
		if(!curData) return null;
		var curDataId = this.sceneManager.dataManager.getCategoryForData(curData).getId();
		if(curDataId == 'rack'){
			return curData;
		}else{
			if(curDataId == 'earth'){
				return null;
			}
			curData = this.sceneManager.dataManager.getParent(curData);
			return this.getRackByData(curData);
		}
	},
	/*
	* 返回设备node的初始状态，如card有一个弹出动画，这里将处于动画的node回复初始状态
	*/
	clearNodeState: function(node){
		if(!node) return;
		//将处于弹出状态的card收回
		if(this.sceneManager.viewManager3d.getDefaultEventHandler().isPlayAnimate(node)){
			if(node.getClient('animation') && (node.getClient('animated') === true)){
				make.Default.playAnimation(node,node.getClient('animation'),null);
			}   
		}
	},


	/*	
	*	这个方法仅仅处理了从rack子元素以及孙子元素等后代到机柜外部的情况
    *	其它的情况不能在这里拦下
	*	当rack自身为oldNode的情况也最好不要在这里拦截，因为在其它地方有处理
	*   -- add Yaphets 2017-11-23
	*/
	focusNodeChange: function (oldNode, node) {
		if (!oldNode) {
			return;
		}
		var oldData = this.sceneManager.getNodeData(oldNode),
		oldDataCategory = this.sceneManager.dataManager.getCategoryForData(oldData),
		oldCategoryId = oldDataCategory.getId(),
		data = this.sceneManager.getNodeData(node),
		oldRackData = this.getRackByData(oldData),
		newRackData = this.getRackByData(data);
		if (oldDataCategory && oldCategoryId != 'rack' && oldRackData && !newRackData) {
			var oldParentData = this.sceneManager.dataManager.getDataById(oldData.getParentId());
			if (oldParentData && data != oldParentData &&
				(!data.getParentId //有可能是link
					||
					data.getParentId() != oldParentData.getId())) { //focus的不是设备的parent，也不是其兄弟设备

				oldRackNode = this.sceneManager.getNodeByDataOrId(oldRackData);
				this.clearNodeState(oldNode);
				this.realToFake(oldRackNode);                   
			}
		}
	},

    
});
  /**
   * 将buidling和floor都放到datacenter这一Scene中。
   * 点击building虚化building，然后显示其对应的楼层并展开
   */
  var $BuidingAndFloorChangeAdapter = function(sceneManager) {
    it.BaseFocuseChangeAdapeter.call(this, sceneManager);
    this.isMoveCameraBeforeLaunchFloor = true; //点击building时，是不是先移动镜头然后再展开，false的话就不移动镜头原地展开
    this.animates = [];
    this.init();
  };

mono.extend($BuidingAndFloorChangeAdapter,it.BaseFocuseChangeAdapeter,{
	
    init: function() {
       // this.sceneManager.switchToRealNode = this.switchToRealNode;
       var self = this;
       this.f2BHandle = new $FloorToBuildingHandle(this); //楼层回到园区的业务处理
       this.b2fHandle = new $BuildingToFloorHandle(this);

       this.sceneChangeListener = function(eve) {
          self.bindingBuildingAndFloor(eve.data,eve.rootData,eve.oldData,eve.oldRootData);
       };
       this.sceneManager.addSceneChangeListener(this.sceneChangeListener,this);

       // 从floor退回到buiding时，内置动画禁止掉，可是从floor-building需要经过两步：1、floor-dc，2、dc—building
       // 需要注意的是：存在其他的跳转方式，如：点击tree的方式
       this.orgChangeAnimate = this.sceneManager.cameraManager.beforePlaySceneChangeAnimate;
       this.newChangeAnimate = function(scene, rootData,oldScene,oldRootData){
           var oldCategory = self.dataManager.getCategoryForData(oldRootData);
           var category = self.dataManager.getCategoryForData(rootData);
           if (oldCategory && category 
               && oldCategory.getId().toLowerCase() ==='floor' 
               && category.getId().toLowerCase() === 'datacenter') {
               return false;
           }
           return self.orgChangeAnimate.call(self.sceneManager.cameraManager,scene, rootData,oldScene,oldRootData);
       }

       this.bindingBuildingAndFloorVisibleManager = new it.VisibleManager(this.sceneManager);
       this.sceneManager.viewManager3d.addVisibleFilter(this.bindingBuildingAndFloorVisibleManager);

       var defaultHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
       this.oldlookAtFun = defaultHandler.lookAt;
       this.newLookAtfun = function(node, callback){
           var data = self.sceneManager.getNodeData(node);
           var category = self.sceneManager.dataManager.getCategoryForData(data);
           if (category && category.getId() == 'building') {
              var mainNode = self.sceneManager.getNodeByDataOrId(data);
              self.sceneManager.viewManager3d.setFocusNode(mainNode);
              defaultHandler.afterLookAt(mainNode,node);
              callback && callback();
              return ;
           }else{
              self.oldlookAtFun.call(defaultHandler,node,callback);
           }
       }

    this.oldGotoScene = this.sceneManager.gotoScene;
    this.newGotoScene = function(scene, data, callback) {
        var currentScene = self.sceneManager.getCurrentScene();
        var currentRootData = self.sceneManager.getNodeData(self.sceneManager.getCurrentRootNode());
        var dataNode = self.sceneManager.getNodeByDataOrId(data);
        var oldFocusNode = self.sceneManager.viewManager3d.getFocusNode();
        var oldFocusData = self.sceneManager.getNodeData(oldFocusNode);
        if (oldFocusData 
            && oldFocusData.getId() == data.getParentId() //只有当前的focuse正好是其父亲时，才走这条路，否则直接切换(从tree上点击的情况很复杂)
            // 此处修改的问题为：当处于楼层展开状态时，若在此时使用lookAtByData看向某个设备或机柜，则会调用b2f的场景切换，造成界面的混乱无法使用。
            // 在lookAtByData中，如果要看目标不为当前场景的根节点，则会设置self.sceneManager.resetCameraWhenSceneChange为false，此处借用了他的状态，
            // 使用lookAtByData看向某个设备或机柜， 即看得目标不是那个场景的根节点，此处应该用oldScene，因此这里给出false。  2017-12-12 add by lyz
            && self.sceneManager.resetCameraWhenSceneChange
            && dataNode && dataNode.doubliClick) {
           dataNode.doubliClick(dataNode, self.sceneManager.network3d, data, null, callback);
           return;
        }
        if (currentScene 
             && currentScene.getId() == 'floor' 
             && scene 
             && scene.getId().toLowerCase() == 'datacenter') {
            self.f2BHandle.doFloorToDatacenter(scene, data, currentScene, currentRootData, callback);
        } else {
            self.oldGotoScene.call(self.sceneManager, scene, data, callback);
        }
     }

       var defaultMF = this.sceneManager.viewManager3d.defaultMaterialFilter;
       this.oldGetOpacityValue = defaultMF.getOpacityValue;
       this.newGetOpacityValue = function(data){
          if (self.sceneManager.getCurrentScene() 
            && self.sceneManager.getCurrentScene().getCategoryId()
            && self.sceneManager.getCurrentScene().getCategoryId().toLowerCase() == 'datacenter') {
              return 0.01;
          }
          return self.oldGetOpacityValue.call(defaultMF,data);
       } 

    },

    startInit : function(){
        if (this.bindingBuildingAndFloorVisibleManager) {
            this.sceneManager.viewManager3d.addVisibleFilter(this.bindingBuildingAndFloorVisibleManager);
        }
        if (this.sceneChangeListener) {
          this.sceneManager.removeSceneChangeListener(this.sceneChangeListener,this); //有可能在初始化时已经加了，避免重复添加
          this.sceneManager.addSceneChangeListener(this.sceneChangeListener,this);
        }
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAt = this.newLookAtfun;
        this.sceneManager.gotoScene  = this.newGotoScene;
        this.sceneManager.cameraManager.beforePlaySceneChangeAnimate = this.newChangeAnimate;
        this.sceneManager.viewManager3d.defaultMaterialFilter.getOpacityValue = this.newGetOpacityValue;
    },

    destroy : function(){
       if (this.bindingBuildingAndFloorVisibleManager) {
            this.bindingBuildingAndFloorVisibleManager.clear();
            this.sceneManager.viewManager3d.removeVisibleFilter(this.bindingBuildingAndFloorVisibleManager);
        }
        if (this.sceneChangeListener) {
           this.sceneManager.removeSceneChangeListener(this.sceneChangeListener,this);
        }
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAt = this.oldlookAtFun;
        this.sceneManager.gotoScene = this.oldGotoScene;
        this.sceneManager.cameraManager.beforePlaySceneChangeAnimate = this.orgChangeAnimate;
        this.sceneManager.viewManager3d.defaultMaterialFilter.getOpacityValue = this.oldGetOpacityValue;
    },

    stopAllAnimate : function(){
        if (this.animates && this.animates.length > 0) {
          for(var i = 0 ; i < this.animates.length > 0 ; i++){
             var animate = this.animates[i];
            animate.stop();
          }
        }
        this.animates = [];
    },

	  /**
     * 看到真对象时(setFocus到真对象时)，注意这里有多层含义：1、假机柜切换到真机柜；
     * 2、真的机柜切换到真的地板这种“真-真”的模式
     *
     * 写这个扩展类的原因：当我点击building时(我们可以认为整个大的building是假的，里面的具体的楼层才是真的)，
     * 我想其下的floor有些动画，并且要见其自身虚幻掉(一般来说，当focus到自己时，除了自己其他的都会虚幻的)
     *
     * building —— floors
     * floors —— building
     *
     * @param node
     * @param oldNode
     */
    // switchToRealNode : function(node,oldNode){
     focusNodeChange: function(oldNode, node) {
        if(!node){
            return;
        }
        var sceneMap = this.dataManager._sceneMap;
        for (var sId in sceneMap) {
           var sceneObj = sceneMap[sId];
           if(sceneObj && sceneObj.getCategoryId() && sceneObj.getCategoryId().toLowerCase().indexOf('building')>=0){
              return ;
           }
        };
        var self = this;
        var data = this.sceneManager.getNodeData(node);
        var category = this.dataManager.getCategoryForData(data);
        var oldData =  oldNode?this.sceneManager.getNodeData(oldNode):null;
        var oldCategory = this.dataManager.getCategoryForData(oldData);
        // 2017-05-02 Kevin
        if(category && category.getId().toLowerCase().indexOf('datacenter') >=0
          && oldCategory && oldCategory.getId() == 'floor'){ //dc-floor时直接退出，gotoUpLevelSceneFor3D中的afterGotoUpLevelScene会重新调用的
           return;
        }
        // var box = this.network3d.getDataBox();
        // lookAt到building时
        // 注意：不管看到floors或是building，都是building。不管显示的是那种buidling，接下来双击背景都会到其他的对象，而不是真的building了
        // 所以还需要来判断oldNode是不building
       if (category 
            && category.getId() 
            && category.getId().toLowerCase().indexOf('building') >= 0 
            && oldCategory 
            && oldCategory.getId()
            && oldCategory.getId().toLowerCase().indexOf('building') >= 0) { // building - building
            var oldDataChildren = oldData.getChildren();
            if(oldDataChildren && oldDataChildren.size() > 0) {
                for (var i = 0; i < oldDataChildren.size(); i++) {
                    var child = oldDataChildren.get(i);
                    var childCategory = this.dataManager.getCategoryForData(child);
                    if (childCategory &&
                        childCategory.getId()
                       && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
                           var floorNode = self.sceneManager.dataNodeMap[child.getId()];
                           if (floorNode && self.box.getDataById(floorNode.getId())) {
                                self.box.removeByDescendant(floorNode);
                                 //add 2017-07-06 Kevin focus时从filter中去掉了，然后scenechange时再重新设置，这里点击地板也应该设置回去，上面的是不是remove不是很重要
                                // self.bindingBuildingAndFloorVisibleManager.setVisible(child, false); 
                                 self.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(child, false); //有可能有孩子的情况 2017-07-19
                          }
                    }
                }
            }
            this.switchToBuilding(node,oldNode,this.switchToBuildingFinished);
        }else if(category 
           && category.getId() 
           && category.getId().toLowerCase().indexOf('building') >= 0){ // dc-building or floor-building(floor不会一步到building的，除了点击搜索树)
            if (oldCategory 
            && oldCategory.getId() == 'floor') { // floor-building返回，在FloorToBuildingHandle中处理了
               return;
            }
            this.switchToBuilding(node,oldNode,this.switchToBuildingFinished);
        }
        // else if(oldNode){ //这种情况被转发到了上面的第一种情况，在clickBackground中转发的
           // 存在两种情况：1、building-dc，2、building-非DC(如具体的floor或通过其他的方式跳转到其他的场景)
           // 并且是只在1的情况下才执行以下的方法
            // var oldData =  this.getNodeData(oldNode);
            // var oldCategory = this.dataManager.getCategoryForData(oldData);
       else if(oldCategory 
                && oldCategory.getId()
                && oldCategory.getId().toLowerCase().indexOf('building') >= 0
                ){  // building-dc,or other
                var children = oldData.getChildren();
                if(children && children.size() > 0) {
                  var floorNodes = [];
                    for (var i = 0; i < children.size(); i++) {
                        var child = children.get(i);
                        var childCategory = this.dataManager.getCategoryForData(child);
                        if (childCategory &&
                            childCategory.getId()
                            && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
                              var floorNode = this.sceneManager.dataNodeMap[child.getId()];
                              floorNodes.push(floorNode);
                        }
                    }
                   var callback = function(){ // 如果是其他building的楼层的话
                        for(var j = 0 ; j < floorNodes.length; j++){
                            var floorNode = floorNodes[j];
                            var child =self.sceneManager.getNodeData(floorNode);
                            if (data != child //如果从building跳到楼层的话，本层的不需要移除
                                && floorNode
                                && self.box.getDataById(floorNode.getId())) {
                                self.box.removeByDescendant(floorNode);
                              //add 2017-07-06 Kevin focus时从filter中去掉了，然后scenechange时再重新设置，这里点击地板也应该设置回去，上面的是不是remove不是很重要
                                self.bindingBuildingAndFloorVisibleManager.setVisible(child, false); 
                            }
                        }
                    };
                    if(category && category.getId().toLowerCase().indexOf('datacenter') >= 0){ // 回到dc中才需要动画，否则就没有必要
                        this.hideFloorAnimate(floorNodes,oldNode,callback);
                        // this.sceneManager.viewManager3d.defaultMaterialFilter.clearAll(); //此时显示的园区，应该clearAll
                    }else{
                        callback();
                        this.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(oldData);
                    }
                    // this.sceneManager.viewManager3d.defaultMaterialFilter.clearAll(); //此时显示的园区，应该clearAll
                }
        }
    },

	 /**
     * 将building和floor"绑定"在一起:
     * 也就是显示building时，floors就被隐藏了(在earth下也不应该显示)，当floors显示时，building和dc都虚幻，
     * 但是这里处理的只是场景切换到dc模式下，将floors隐藏
    */
    bindingBuildingAndFloor : function(scene,rootData,oldScene,oldRootData){
      this.stopAllAnimate();
        var floors = this.dataManager._categoryDatas['floor']; //一下子拿出了所有的floor，可以floor不是延迟加载的，
        // 有可能是通过url的方式进来的，此时parentScene和data就为null
        if (scene 
          && scene.getCategoryId() 
          && scene.getCategoryId().toLowerCase() == 'datacenter') {
              if (floors) {
                for (var id in floors) {
                    var floor = floors[id];
                    //从floor到园区，这里不处理隐藏，在FloorToBuildingHandle中处理,但是其他building的floor需要处理
                    // Add 2017-07-10 如果是通过搜索树和面包屑直接跳转到dc呢？
                    if (!oldRootData  //有可能是通过url的方式进来的
                        || (floor 
                            && floor != oldRootData 
                            && floor.getParentId() != oldRootData.getParentId())) { 
                        // this.bindingBuildingAndFloorVisibleManager.setVisible(floor, false); 
                        this.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(floor,false);
                    }
                }
              }
        } else {
            this.bindingBuildingAndFloorVisibleManager.clear();
            // 将floor的scale设置回去
            if (floors) {
                for (var id in floors) {
                    var floor = floors[id];
                    var floorNode = this.sceneManager.getNodeByDataOrId(floor);
                    if (floorNode){
                        if( floorNode.orgScale) {
                            floorNode.setScale(floorNode.orgScale.clone());
                            if(floorNode == this.sceneManager._currentRootNode){
                              if (this.afterLoadFloor) {
                                  this.afterLoadFloor(floorNode);
                              }
                            }
                        }
                        if(floorNode.orgPosY){ //展开的动画要执行完，所以上面的需要stop
                            floorNode.setPositionY(floorNode.orgPosY);
                            // delete floorNode.doubliClick; // 将事件删掉
                        }
                    }
                }
            }
        }
    },

  /**
   * 先慢慢虚幻dc和building
   * 虚化完成后，楼层慢慢上升
   * 如果是floor场景(即oldNode是floor场景中的对象)跳过来的话，则是点击building到floor动画的反向
  */
  showFloorAnimate: function(floors, buildingNode, oldNode,finishedCallback,afterLookAtCallback) {
    if (!floors && floors.length < 1) {
      return;
    }
    var self = this;
    var data = this.sceneManager.getNodeData(buildingNode);
    var defaultHandler = this.sceneManager.viewManager3d.getDefaultEventHandler();
    var oldFocusData = this.sceneManager.getNodeData(oldNode);
    var oldSceneAndRoot = null;
    if (oldFocusData) {
      oldSceneAndRoot = this.sceneManager.getSceneAndRootByData(oldFocusData);
    }
    if (oldSceneAndRoot && oldSceneAndRoot.scene 
        && oldSceneAndRoot.scene.getCategoryId().toLowerCase().indexOf('floor') >= 0) { //从floor退回到园区的building中
      /*
        移到了FloorToBuildingHandle.js中
      */
    } else {
      // defaultHandler.lookAtWithOutMoveCamera = false;
    var moveUpFloorsAnimate = new mono.Animate({
        from: 0,
        to: 1,
        dur: 1000,
        // delay: 1000,
         delay: 0,
        easing: 'elasticOut',
        onUpdate: function(value) {
          // floor.setY(value);
          for (var i = floors.length - 1; i >= 0; i--) {
            var floor = floors[i];
            var data = self.sceneManager.getNodeData(floor);
            var y = parseFloat(data.getPosition().y / 10);
            floor.setY(y + 50 * value);
          }
        },
        onStop:function(){
           if (self.animates && self.animates.length > 0) {
              self.animates = []; //运行完后，清空缓存 --2017-10-10
           }
           finishedCallback && finishedCallback(buildingNode);
        }
      });

      var callback1 = function() {
        afterLookAtCallback && afterLookAtCallback();
        if (!self.sceneChangeWithOutAnimate) {
           // self.moveUpFloorsAnimate.play();
           moveUpFloorsAnimate.play();
        } else {
          for (var i = floors.length - 1; i >= 0; i--) {
            var floor = floors[i];
            var data = self.sceneManager.getNodeData(floor);
            var y = parseFloat(data.getPosition().y / 10);
            floor.setY(y + 50);
          }
        }
      };
      this.animates.push(moveUpFloorsAnimate);
      //defaultHandler.moveToClickNode(buildingNode,callback,200);
       // defaultHandler.moveCameraForLookAtNode(buildingNode,callback1);
       if (floors && floors.length > 1) { // update 2016-11-01 Kevin
           if(this.isMoveCameraBeforeLaunchFloor){
              defaultHandler.moveCameraForLookAtNodes(floors,callback1,30);
              this.sceneManager.viewManager3d.clearVisibleMap();
           }else{
              setTimeout(function(){
                  callback1();
              },100);
           }
       }else{
           defaultHandler.moveCameraForLookAtNode(buildingNode,callback1);
       }
    }
  },

    /**
      * 其实执行这个方法前，内置的虚化都已经处理好了，因此floors都被遮住了。
      *
      * 也是通过setFocusNode来触发的，所以虚化的处理需要注意
    */
    hideFloorAnimate : function(floors,buildingNode,callback){
        if (!floors && floors.length < 1) {
            if(callback){
                callback();
            }
            return;
        }
        if(this.doubliClickFloorNodeAnimate){
          this.doubliClickFloorNodeAnimate.stop();
        }
        // this.viewManager3d.getDefaultEventHandler().withOutAnimate = true;
        this.sceneManager.viewManager3d.getDefaultEventHandler().lookAtWithOutMoveCamera = false;
        var buildingData = this.sceneManager.getNodeData(buildingNode);
        if (buildingData) {
            // buildingNode.setStyle('m.transparent', true);
            // buildingNode.setStyle('m.opacity', 0.06);
            this.sceneManager.viewManager3d.defaultMaterialFilter.add(buildingData);
            this.sceneManager.network3d.dirtyNetwork();
        }
        var self = this;
        var moveDownFloorsAnimate = new mono.Animate({
            from: 0,
            to: 1,
            dur: 1000,
            // delay: 1000,
            easing: 'easeOut',
            onUpdate: function (value) {
                // floor.setY(value);
                for (var i = floors.length - 1; i >= 0; i--) {
                    var floor = floors[i];
                    var data = self.sceneManager.getNodeData(floor);
                    if (!data) {
                       return; //有可能被释放掉了 2017-10-11
                    }
                    var y = parseFloat(data.getPosition().y/10) + 50;
                    // var y = parseFloat(floor.getPositionY());
                    floor.setY(y - 50 * value);
                }
            },
            onStop : function(){ //不管是stop还是正常执行完，这个一定是被执行
              if(callback){
                    callback();
                }
                self.sceneManager.viewManager3d.defaultMaterialFilter.clearAll();
                self.sceneManager.network3d.dirtyNetwork();
                // var index = self.animates.indexOf(moveDownFloorsAnimate);
                // if(index !== -1){
                //    self.animates.splice(index,1);
                // }
                if (self.animates && self.animates.length > 0) {
                   self.animates = []; //运行完后，清空缓存 --2017-10-12
                }
            }
        });
        this.animates.push(moveDownFloorsAnimate);
        moveDownFloorsAnimate.play();
    },

    /**
     * 根据building和floor获取该floor的scale
     */
  getFloorScaleByBuildingNodeAndFloorNode: function(buildingNode, floorNode) {
    if (!buildingNode || !floorNode) {
       return null;
    }
     // var minScaleX = 10,
     //    minScaleZ = 10; // 用最大的，如果每个floor都不一样大时，最后都缩放成了一样大，不太好
    // var buildingBoundingBox = buildingNode.getBoundingBox();
    var buildingBoundingBox = it.Util.getBoundingBox(buildingNode);
    // var floorNodeBoundingBox = floorNode.getBoundingBox();
    var floorNodeBoundingBox = it.Util.getBoundingBox(floorNode);
    var scaleX = 0.1,
        scaleZ = 0.1;
    if (buildingBoundingBox && floorNodeBoundingBox) {
      var bbSize = buildingBoundingBox.size();
      var fSize = floorNodeBoundingBox.size();
      // var scaleX = 0.1,
      //     scaleZ = 0.1; // 默认的都0.1，可是当楼层本身就比较小时也太小了,都除以1000呢？
      if (bbSize && fSize) {
        if (bbSize.x && bbSize.x != -Infinity && bbSize.x != Infinity && fSize.x != -Infinity && fSize.x != Infinity) {
          scaleX = bbSize.x / fSize.x;
        }
        if (bbSize.z && bbSize.z != -Infinity && bbSize.z != Infinity && fSize.z != -Infinity && fSize.z != Infinity) {
          scaleZ = bbSize.z / fSize.z;
        }
      }
      // if (scaleX < minScaleX) {
      //   minScaleX = scaleX;
      // }
      // if (scaleZ < minScaleZ) {
      //   minScaleZ = scaleZ;
      // }
    }
    var scale = scaleX > scaleZ ? scaleZ:scaleX;
    return new mono.Vec3(scale, 1, scale);
  },

  /**
   * 当该building只有一层楼时，是不是直接进入
   */
  isIntoFloor : function(){
    return true;
  },
  
  /**
   * 双击楼层是否进入具体楼层，便于扩展，贵州浪潮的某个建筑只有展厅一层，并且双击不允许进入
   */
  shouldDoubliClickFloorNode : function(data){
    return true;
  },

  /**
   * 点击building
   * 1、lookAt Building
   * 2、虚幻building
   * 3、展开楼层（如果该building只有一层时，那就直接进入）
   * 4、当有多个building时，其他的building的floor应该隐藏
   */
  switchToBuilding: function(node, oldNode, callback) {
    if (!node) return;
    var data = this.sceneManager.getNodeData(node);
    if (!data) return;
    // var buildingBoundingBox = node.getBoundingBox();
    // var buildingBoundingBox = it.Util.getBoundingBox(node);
    var wPos = node.getWorldPosition();
    var bSacle = node.getScale();
    var children = data.getChildren();
    if (!children || children.size() < 1) {
      return;
    }
    var self = this;
    var floorNodes = [];
    var minScaleZ = 1;
    var minScaleX = 1;
    if (children && children.size() > 0) {
      for (var i = 0; i < children.size(); i++) {
        var child = children.get(i);
        var childCategory = this.sceneManager.dataManager.getCategoryForData(child);
        if (childCategory &&
          childCategory.getId() && childCategory.getId().toLowerCase().indexOf('floor') >= 0) {
          var floorNode = this.sceneManager.dataNodeMap[child.getId()];
          if (floorNode) {
            if (!floorNode.orgScale) {
              floorNode.orgScale = floorNode.getScale().clone();
            }
            if (!floorNode.orgPosY) {
              floorNode.orgPosY = floorNode.getPositionY();
            }
            var fMinScale = this.getFloorScaleByBuildingNodeAndFloorNode(node,floorNode)||new mono.Vec3(0.1,0.1,0.1);
            if(minScaleZ > fMinScale.z){
               minScaleZ = fMinScale.z;
            }
            if (minScaleX > fMinScale.x) {
               minScaleX = fMinScale.x;
            }
            floorNode.setPositionY(child.getPosition().y / 10);
            this.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(child);
            delete this.doubleClickFloorNodeFlag; //每次展开都删掉，以防中间存在没有干掉的情况
            floorNode.doubliClick = function(element, network, data, clickedObj, callback) {
                // self.doubliClickFloorNode(element, network, data, clickedObj, callback);
                if(self.shouldDoubliClickFloorNode(data)){
                    self.b2fHandle.doubliClickFloorNode(element, network, data, clickedObj, callback);
                }
            }
            floorNodes.push(floorNode);
          }
        }
      }
      if(floorNodes.length  < 1){ //当building没有floor孩子时，直接返回
         this.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // 在该模式下只虚化building，其他的都不虚化。
         return ;
      }
      // 该building只有一层时，改成不是直接场景切换，而是展开后直接进入 —— update by Kevin 2017-07-04
      for (var i = floorNodes.length - 1; i >= 0; i--) {
          floorNodes[i].setScale(minScaleX * bSacle.x, Math.min(minScaleX * bSacle.x,minScaleZ * bSacle.z), minScaleZ * bSacle.z); //这个得根据自己的boundingbox和building的boundingbox比较计算
      }

      /**
       * 隐藏建筑，显示建筑的floor
       */
      var aftrLookAtCallback = function() {

        self.sceneManager.viewManager3d.defaultMaterialFilter.addByDescendant(data); //建筑上的非floor的孩子也要虚幻
        for (var i = 0; i < floorNodes.length; i++) {
           var fData = self.sceneManager.getNodeData(floorNodes[i]);
           self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(fData);
        }
        self.sceneManager.network3d.dirtyNetwork();

        if (self.bindingBuildingAndFloorVisibleManager && floorNodes.length > 0) {
            for(var i = 0 ; i < floorNodes.length ; i++){
               var floor = self.sceneManager.getNodeData(floorNodes[i]);
               // self.bindingBuildingAndFloorVisibleManager.setVisible(floor, true);
               self.bindingBuildingAndFloorVisibleManager.setVisibleByDescendant(floor, true); // update 2017-07-19 有可能会有孩子的情况
            }
        }
       
        if(self.afterLookAtBuildingFunction){
           self.afterLookAtBuildingFunction(node,floorNodes);
        }

      }

      var endCallback = function(){
        callback && callback();
         if (floorNodes.length == 1 && self.isIntoFloor() && self.shouldDoubliClickFloorNode(fData)) { //如果只有一层，那就直接进入
            var fData = self.sceneManager.getNodeData(floorNodes[0]);
            self.b2fHandle.doubliClickFloorNode(floorNodes[0], self.sceneManager.network3d, fData, null, null);
        }
      }

      this.sceneManager.viewManager3d.defaultMaterialFilter.clear(); // 在该模式下只虚化building，其他的都不虚化。
      this.showFloorAnimate(floorNodes, node, oldNode,endCallback, aftrLookAtCallback);
    }
  }

});

it.BuidingAndFloorChangeAdapter = $BuidingAndFloorChangeAdapter;





/**
 * 适配管理器，虽然可以都放在sceneManger中
 * 独立出来，模块化，同时也使得sceneManager中不那么臃肿
 *
 */
$PropertyChangeAdaperManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.changeAdapterList = new mono.List();
	this.defaultFocuseAdaper = new $ComplexNodeAndSimpleNodeChangeAdapter(sceneManager);//默认的一个真假切换的处理
	this.buildAndFloorAdaper = new $BuidingAndFloorChangeAdapter(sceneManager);
	this.init();
};

mono.extend($PropertyChangeAdaperManager,Object,{

	init: function() {
		var self = this;
		this.sceneManager.viewManager3d.addPropertyChangeListener(function(event) {
			// if(event.property == "focusNode"){
			// }
			var currentScene = self.sceneManager.getCurrentScene();
			if (event 
				&& event.property == "focusNode" 
				&& (!currentScene || currentScene.getId() != 'earth')) { // earth 上的 billboard就不触发loadChildren了
				var node = event.newValue;
				if (node) {
					self.sceneManager.loadLazyChildren(node); // 如:从机柜 lookAt 地板 ,貌似直接lookAt也会执行
					// viewManage中的“focusNode”中会统一处理的，这里再这么整就没法统一管理了，不知当初为何在这里这么用，--2017-09-27 
					// if (self.sceneManager.viewManager3d.defaultMaterialFilter) {
					// 	self.sceneManager.viewManager3d.defaultMaterialFilter.removeByDescendant(self.sceneManager.getNodeData(node));
					// }
					self.setRelationWithChildren(node); // 2018-01-19 Kevin 设置父子关系，有可能父子关系断掉了
				}
			}

			// for (var i = 0; i < self.changeAdapterList.size(); i++) {
			// 	var changeAdaper = self.changeAdapterList.get(i);
			// 	if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
			// 		changeAdaper.focusChange(event);
			// 	}
			// }
			self.focusChange(event);
		});
		this.register(this.defaultFocuseAdaper);
		this.register(this.buildAndFloorAdaper);
	},

	// -- add By Kevin 2016-12-01 为了解决将focusChange放至BaseFocuseChangeAdapeter中的问题:
	// /*add 注意 by Kevin 2016-12-01
    // 注意：由于此类会被很多类继承，很有可能最开始执行的改变了某些属性使得后来的没法正常执行，如：
    //    最开始的complexNodeAndSimpleNodeChangeAdapter执行后，complexNode和simpleNode的父子关系已经改变过，
    //    接下来的的实例就很有可能执行不了,realToFake 和 fakeToReal了
    //  改进：将这块移到其管理类中，然后在realToFake、fakeToReal以及focusNodeChange中遍历BaseFocuseChangeAdapeter的实例，然后一一执行,这
    //       样就不会遗漏没有执行的，但是在每个BaseFocuseChangeAdapeter实例中，需要注意所得到的node和oldNode的某些属性(如:真假对象的父子关系,以及是否加到了box中)
    //       可能被之前执行的实例更改过
    // */
	focusChange: function(event) {
		var self = this;
		if (event && event.property == "focusNode") {
			var oldNode = event.oldValue;
			var node = event.newValue;
			if (oldNode) {
				var simpleNode = oldNode.getClient('simpleNode');
				var complexNode = oldNode.getClient('complexNode');
				//真 —— 假 ,并且不是父子(如果是lookAt机柜 到 lookAt该机柜中的设备，此时是不需要卸载的，可是如果是孙子呢？？？，因此改成不是子孙)
				// if (simpleNode && simpleNode.getParent() != oldNode && !self.isChild(oldNode, node)) {
			// add by Kevin 2011221，有可能中途出错导致真假都显示了，所以不应该判断simpleNode的parent不存在，而判断complex的父亲存在
				if (simpleNode 
					&& ((complexNode 
						 && complexNode != 'unload' 
						 && complexNode.getParent() == oldNode)
						|| simpleNode.getParent() != oldNode) 
					&& !self.isChild(oldNode, node)) { 
					for (var i = 0; i < self.changeAdapterList.size(); i++) {
						var changeAdaper = self.changeAdapterList.get(i);
						if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
							changeAdaper.realToFake(oldNode, node);
						}
					}
					// self.realToFake(oldNode, node);
				}
			}

			if (node) {
				self.fakeToRealForParent(node); //先切换父亲的真假
				var complexNode = node.getClient('complexNode');
				var simpleNode = node.getClient('simpleNode');
				var data = self.sceneManager.getNodeData(node);
				if (complexNode == 'unload') { //可能开始复杂模型没有创建
					self.sceneManager.loadComplexNode(data,function(comNode){
						self._doFakeToReal(comNode,simpleNode,oldNode,node);
					});
				}else{
					/*
			    	if (complexNode && 
				        (complexNode.getParent() != node
				          || (simpleNode && simpleNode.getParent() == node))) { // 假 —— 真 
				    	var simpleNode = node.getClient('simpleNode');
			    		for (var i = 0; i < self.changeAdapterList.size(); i++) {
			    			var changeAdaper = self.changeAdapterList.get(i);
				    		if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
				     			changeAdaper.fakeToReal(oldNode, node);
			    			}
		    			}
		    		}*/
		    		self._doFakeToReal(complexNode,simpleNode,oldNode,node);
				}
			}

			for (var i = 0; i < self.changeAdapterList.size(); i++) {
				var changeAdaper = self.changeAdapterList.get(i);
				if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
					changeAdaper.focusNodeChange(oldNode, node);
				}
			}
			// self.focusNodeChange(oldNode, node);
		}
	},
    
    /**
     * 注意有可能父亲也要切换
     * 并且node自身没有真假，但是父亲有
     */
	_doFakeToReal: function(complexNode,simpleNode,oldNode,node) {
		if (complexNode &&
			 (complexNode.getParent() != node 
			  || (simpleNode && simpleNode.getParent() == node))) { // 假 —— 真 
			var simpleNode = node.getClient('simpleNode');
			for (var i = 0; i < this.changeAdapterList.size(); i++) {
				var changeAdaper = this.changeAdapterList.get(i);
				if (changeAdaper && (changeAdaper instanceof it.BaseFocuseChangeAdapeter)) {
					changeAdaper.fakeToReal(oldNode, node);
				}
			}
		}
	},

	/**
     * 切换其parent的真假，有可能从其他的入口进入的
     * add 2017-07-14
     */
	fakeToRealForParent : function(node){
		var nodeData = this.sceneManager.getNodeData(node);
		var self = this;
		if (nodeData && nodeData.getParentId && nodeData.getParentId()) { //有可能是连线
			var parent = this.sceneManager.dataManager.getDataById(nodeData.getParentId());
			if (parent && this.sceneManager.isCurrentSceneInstance(parent)) {
				var parentNode = this.sceneManager.getNodeByDataOrId(parent);
				if (!parentNode) {
					return;
				}
				this.fakeToRealForParent.call(this,parentNode);//一直找到根
				var complexNode = parentNode.getClient('complexNode');
				var simpleNode = parentNode.getClient('simpleNode');
				if (complexNode == 'unload') { //可能开始复杂模型没有创建
					self.sceneManager.loadComplexNode(parent,function(comNode){
						self._doFakeToReal(comNode,simpleNode,null,parentNode);
					});
				}else if(complexNode && complexNode.getParent() != parentNode){ //表示没有切过
		    		self._doFakeToReal(complexNode,simpleNode,null,parentNode);
				}	
			}
		}
	},

	isChild : function(parentNode,childNode,scope){
		scope = scope || this;
        if(!parentNode || !childNode){
            return false;
        }
        var pdata = parentNode;
        if (parentNode instanceof mono.Element) {
        	pdata = scope.sceneManager.getNodeData(parentNode);
        }
        if(!pdata) {
            return false;
        }
        var cdata = childNode;
        if (childNode instanceof mono.Element) {
        	cdata = scope.sceneManager.getNodeData(childNode);
        }
        if(!cdata || !(cdata instanceof $Data)){
            return false;
        }
        var pDataScene = scope.sceneManager.getSceneFromData(pdata);
        var cDataScene = scope.sceneManager.getSceneFromData(cdata);
        if ((!pDataScene && cDataScene) 
        	|| (pDataScene && !cDataScene)
        	|| (pDataScene != cDataScene)) {
        	return false;
        }
        if(cdata.getParentId() && cdata.getParentId() === pdata.getId()){
            return true;
        }else{
        	var cdataParent = scope.sceneManager.dataManager.getDataById(cdata.getParentId());
        	return scope.isChild(pdata,cdataParent,scope);
        }
        // return false;
    },

    /**
     * 2018-01-19 Kevin 
     * 设置该node的孩子和它之间的父子关系
     * 由于loadLazyChildren时，当node已经加载过的话，就不再去加载它的孩子了。若是父子关系断掉了，不重新loadScene是整不对的
     * 在IT架构中就很有可能会出现这样的情况，清除了父子关系，直接loadLazyData设备后再lookAt它的父类(包括祖先)的对象就有存在不对的情况
     */
    setRelationWithChildren : function(node){
    	var data = this.sceneManager.getNodeData(node);
    	if (data) {
    		var children = data.getChildren();
    		if (children && children.size() > 0) {
    			for(var i = 0 ;i < children.size(); i++){
    				var child = children.get(i);
    				this.sceneManager.setParentRelationShip(child);
    			}
    		}
    	} 
    },

	register : function(changeAdaper){
		if (changeAdaper) {
			if (!this.changeAdapterList.contains(changeAdaper)) {
				changeAdaper.startInit();
				this.changeAdapterList.add(changeAdaper);
			}
		}
	},

	deregister : function(changeAdaper){ //移除的时候，也要将相关的listener去掉
		if (changeAdaper) {
			if (this.changeAdapterList.contains(changeAdaper)) {
				this.changeAdapterList.remove(changeAdaper);
				changeAdaper.destroy();
			}
		}
	},


});

it.PropertyChangeAdaperManager = $PropertyChangeAdaperManager;



/**
 * 空间可视化时，当fouse发生改变时，创建/移除机柜以及机柜内的透明方块
 * 备注：这些焦点对象(不管是oldFouseNode还是fouseNode)都应该是机柜，其他类型的不处理
 */
var $SpaceAdapter = function(sceneManager,spaceManager){
	it.BaseFocuseChangeAdapeter.call(this,sceneManager);
	this.spaceManager = spaceManager;
	this.box = this.sceneManager.network3d.getDataBox();
};

mono.extend($SpaceAdapter, it.BaseFocuseChangeAdapeter, {

	/**
	 * 真的切换到(真/假)(处理后来的真对象)
	 * 如果存在空间可视化的立方体时，就把它从box中移除，并且移除掉真的机柜，即只留下spaceNode(frame+彩色cube)
	 * 1、真机柜删除；
	 * 2、spaceNode留下(这个在该模式下应该是永远显示着)
	 * 3、删除机柜中的空余空间立方体(彩色cube表示)
	 * add 2017-11-18 需要注意的是如果oldNode是真通道的话
	 */
	realToFake: function(oldNode, node) {
		var self = this;
		var isSpaceNode = false,spaceNode = null;
		var children = oldNode.getChildren().toArray();
		var oldData = this.sceneManager.getNodeData(oldNode);
		for (j = 0; j < children.length; j++) {
			var child = children[j];
			if (this.spaceManager.isSpaceChildrenNode(child)) { // || this.isSpaceChildrenNode(child)
				this.box.removeByDescendant(child);
				child.setParent(null);
				isSpaceNode = true;
			}else{
				// 2017-11-10 设备，板卡什么的都得清除。虽然在ComplexNodeAndSimpleNodeChangeAdapter中有处理，但是那里面没有处理干净
				// 2017-11-18 如果是通道切换的话，就不可这样把机柜都干掉
				var childData = this.sceneManager.getNodeData(child);
				var cCategory = this.sceneManager.dataManager.getCategoryForData(childData);
				// if (!cCategory 
				// 	|| cCategory.getId().toLowerCase().indexOf('rack') < 0) {
					// remark 2017-12-14 如果是通道的话，假通道给remove了，会到资产模式下通道会不见了。因此也不能是自己
				if (oldData != childData && (!cCategory 
					|| cCategory.getId().toLowerCase().indexOf('rack') < 0)) {
					this.box.removeByDescendant(child); 
				}
			}
			if(this.spaceManager.isSpaceNode(child)){
				spaceNode = child;
			}
		}
		if (isSpaceNode) {
			var complexNode = oldNode.getClient('complexNode'); 
			var simpleNode = oldNode.getClient('simpleNode');
			this.box.removeByDescendant(complexNode); //有可能之前的adpeter已经处理了(做了真假切换)，所以真假都删掉
			this.box.removeByDescendant(simpleNode);
			if (spaceNode) { //当isSpaceNode为true时，spaceNode一定存在
				this.box.addByDescendant(spaceNode);
			}
		}
	},

	/**
	 * (假/真)机柜切到真机柜时(处理后来的真对象)：
	 * 1、移除之前的spaceNode
	 * 2、将机柜加到box中
	 * 3、创建机柜对应的彩色块，并加到box中
	 */
	fakeToReal: function(oldNode, node) {
		var self = this;
		var data = this.sceneManager.getNodeData(node);
		if (!data) {
			return;
		}
		var isSpaceNode = false;
		var children = node.getChildren().toArray();
		for (j = 0; j < children.length; j++) {
			var child = children[j];
			if (this.spaceManager.isSpaceNode(child)) { // || this.isSpaceChildrenNode(child)
				// child.setParent(null); //从box中移除它，但是父子关系依然在
				this.box.removeByDescendant(child);
				isSpaceNode = true;
			}
		}
		if (isSpaceNode) {
			var complexNode = node.getClient('complexNode'); 
			if(complexNode){
				this.box.addByDescendant(complexNode);
			}else{
				this.box.addByDescendant(node,function(child){
					if (self.spaceManager.isSpaceNode(child)) {
						return false;
					}else{
						return true;
					}
				});
			}
			var spaceChildrenNodes = this.spaceManager.create1DChildrenSpaceNodes(data);
			for (j = 0; j < spaceChildrenNodes.length; j++) { // update By Kevin 2016-11-30 这里一开始可以不创建，等到lookAt的时(现在)才创建，并放到box中
				spaceChildNode = spaceChildrenNodes[j];
				spaceChildNode.setParent(node);
				this.box.addByDescendant(spaceChildNode)
			}
		}
	},

});

it.SpaceAdapter = $SpaceAdapter;



it.PowerCapacityManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
};

mono.extend(it.PowerCapacityManager,Object,{
    computePowerPercent : function(dataOrId){
       var dm = this.dataManager;
       var data = dataOrId;
       if(!data.getId){
          data = dm.getDataById(dataOrId);
       }
       var datatype = dm.getDataTypeForData(data);
       if(!datatype){
         return;
       }
       var powerRating = datatype.getPowerRating();
       if(powerRating == null || powerRating == 0){
          return null;
       }
       
       var totalPower = 0,power;
       var childList = data.getChildren();
       childList.forEach(function(child){
           power = child.getPower() || 0;
           totalPower += power;
       });
       return totalPower / powerRating;
    },

    createPowerNode : function(dataOrId){

        var sm = this.sceneManager,dm = this.dataManager,data = dataOrId,
            box = sm.network3d.getDataBox();
        if(!sm.isCurrentSceneInstance(dataOrId)){
            return;
        }
        if(!data.getId){
            data = dm.getDataById(dataOrId);
        }
        var percent = this.computePowerPercent(dataOrId);
        if(percent == null){
            return;
        }
        var node = sm.getNodeByDataOrId(data);
        var boundingBox = node.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x,height = size.y,depth = size.z;

        var powerNode = node.getClient('powerNode'),powerNode2;
        percent = percent || 0.01;
        if(!powerNode){
            powerNode = new mono.Cube(width-0.2,height ,depth-0.2);
            powerNode2 = new mono.Cube(width,height,depth);
            powerNode2.setParent(powerNode);
            powerNode.s({
                'm.type':'phong',
            });
            powerNode2.s({
                'm.wireframe':true,
                'm.wireframeLinewidth':1,
                'm.color':'white',
            });
            powerNode.setClient('child',powerNode2);
        }
        var color = this.getPowerNodeColor(percent);
         powerNode.s({
            'm.color':color,
            'm.ambient':color,
            'm.specularStrength':30,
        });
        powerNode.setParent(node);
        powerNode.setScale(1,percent,1);
        powerNode.setY(height * percent / 2  -  height / 2 + 5);
        powerNode.setClient('powerChildNode',true);
        node.setClient('powerNode',powerNode);
        powerNode.setClient('it_data','power');
        box.addByDescendant(powerNode);
        // this.makeItDataNodeUnvisible(node);
        this.makeItDataUnvisible(data);
        return powerNode;
    },

    // makeItDataNodeUnvisible : function(node){
    //     if(node.getClient('it_data')){
    //        if(node._oldvisible === undefined){
    //           node._oldvisible = node.getStyle('m.visible',false,false);
    //           node._oldvisible = node._oldvisible === false ? false: true;
    //        }
    //        node.setStyle('m.visible',false);
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function(child){
    //         self.makeItDataNodeUnvisible(child);
    //     });
    // },

    makeItDataUnvisible : function(data){
        if (!data) {
          return;
        }
        this.visibleManager.setVisible(data,false);
        var self = this;
        data.getChildren().forEach(function(child){
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible : function(data){//node
      if (!data) {
         return;
      }
       this.visibleManager.setVisible(data,true);
      var self = this;
      data.getChildren().forEach(function(child){
          self.makeItDataVisible(child);
      });
    },

    removePowerNode : function(dataOrId){
        var sm = this.sceneManager,dm = this.dataManager,data = dataOrId,box = sm.network3d.getDataBox();
        if(!data.getId){
            data = dm.getDataById(dataOrId);
        }
        var node = sm.getNodeByDataOrId(dataOrId);
        if(!node){
            return;
        }
        var powerNode = node.getClient('powerNode');
        if(powerNode){
            powerNode.setParent(null);
            box.removeByDescendant(powerNode);
            // this.makeItDataNodeVisible(node);
        }
         this.makeItDataVisible(data);
    },

    getPowerNodeColor : function(percent){
       if(this.powerNodeColorFunction){
          var color = this.powerNodeColorFunction(percent);
         return color;
       }
       var color;
       if(percent < 0.25){
          color = 'green';
       }else if(percent >= 0.25 && percent <= 0.75){ // TODO
          color = "orange";
       }else{
          color = "red";
       }
       return color;
    },

    isPowerAvailabe : function(){

    },


});
/**
 * 计算承重
 * @param sceneManager
 * @constructor
 */
it.WeightCapacityManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
};

mono.extend(it.WeightCapacityManager, Object, {

    /**
     * 计算承重比率
     * @param dataOrId
     * @returns {*}
     */
    computeWeightPercent: function (dataOrId) {

        var dm = this.dataManager;
        var data = dataOrId;
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            return;
        }
        var weightRating = dataType.getWeightRating();
        //如果承重为空或者为0, 返回null
        if (weightRating == null || weightRating == 0) {
            return null;
        }

        //计算所有孩子的重量
        var totalWeight = this.computeChildrenWeight(data);

        return totalWeight / weightRating;
    },

    /**
     * 计算所有孩子的重量
     * @param dataOrId
     * @returns {number}
     */
    computeChildrenWeight: function (dataOrId) {

        var dm = this.dataManager;
        var self = this;
        var data = dataOrId;
        if (!data.getId) {

            data = dm.getDataById(dataOrId);
        }
        var totalWeight = 0, weight;
        var childList = data.getChildren();
        childList.forEach(function (child) {//haizi
            weight = child.getWeight() || 0;
            totalWeight += weight;
            //
            var childChildren = child.getChildren();
            if (childChildren && childChildren.size() > 0) {
                totalWeight += self.computeChildrenWeight(child);
            }
        });
        return totalWeight;
    },

    /**
     * 创建重量比率节点
     * @param dataOrId
     */
    createWeightNode: function (dataOrId) {

        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId,
            box = sm.network3d.getDataBox();
        //如果不在当前场景
        if(!sm.isCurrentSceneInstance(dataOrId)){
            return;
        }
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var node = sm.getNodeByDataOrId(data);
        var percent = this.computeWeightPercent(data);

        if (percent == null) {
            return;
        }
        data._weightPercent = percent;
        var boundingBox = node.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x, height = size.y, depth = size.z;

        var weightNode = node.getClient('weightNode'), weightNode2;
        percent = percent || 0.01; //如果是0, 就显示很小的一个值
        if (!weightNode) {
            weightNode = new mono.Cube(width - 0.2, height, depth - 0.2);
            weightNode2 = new mono.Cube(width, height, depth);
            weightNode2.setParent(weightNode);
            weightNode.s({
                'm.type': 'phong',
            });
            weightNode2.s({
                'm.wireframe': true,
                'm.wireframeLinewidth': 1,
                'm.color': 'white',
            });
            weightNode.setClient('child', weightNode2);
        }
        var color = this.getWeightNodeColor(percent);
        weightNode.s({
            'm.color': color,
            'm.ambient': color,
            'm.specularStrength': 30,
        });
        weightNode.setParent(node);
        weightNode.setScale(1, percent, 1);
        weightNode.setY(height * percent / 2 - height / 2 + 5);
        weightNode.setClient('weightChildNode', true);
        node.setClient('weightNode', weightNode);
        weightNode.setClient('it_data','weight');
        box.addByDescendant(weightNode);
        this.makeItDataUnvisible(data);
        return weightNode;
    },

    // makeItDataNodeUnvisible: function (node) {
    //     if (node.getClient('it_data')) {
    //         if (node.__oldvisible === undefined) {
    //             node.__oldvisible = node.getStyle('m.visible', false, false);
    //             node.__oldvisible = node.__oldvisible === false ? false : true;
    //         }
    //         node.setStyle('m.visible', false);
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function (child) {
    //         self.makeItDataNodeUnvisible(child);
    //     });
    // },

    // makeItDataNodeVisible: function (node) {
    //     if (node.getClient('it_data')) {
    //         if (node.__oldvisible === undefined || node.__oldvisible === true) {
    //             node.setStyle('m.visible', true);
    //         }
    //     }
    //     var self = this;
    //     node.getChildren().forEach(function (child) {
    //         self.makeItDataNodeVisible(child);
    //     });
    // },

    makeItDataUnvisible : function(data){
        if (!data) {
          return;
        }
        this.visibleManager.setVisible(data,false);
        var self = this;
        data.getChildren().forEach(function(child){
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible : function(data){//node
      if (!data) {
         return;
      }
      this.visibleManager.setVisible(data,true);
      var self = this;
      data.getChildren().forEach(function(child){
          self.makeItDataVisible(child);
      });
    },

    removeWeightNode: function (dataOrId) {
        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId, box = sm.network3d.getDataBox();
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        delete data._weightPercent;
        var node = sm.getNodeByDataOrId(dataOrId);
        if (!node) {
            return;
        }
        var weightNode = node.getClient('weightNode');
        if (weightNode) {
            weightNode.setParent(null);
            box.removeByDescendant(weightNode);
            // this.makeItDataNodeVisible(node);
        }
        this.makeItDataVisible(data);
    },

    getWeightNodeColor: function (percent) {
        if (this.weightNodeColorFunction) {
            var color = this.weightNodeColorFunction(percent);
            return color;
        }
        var color;
        if (percent < 0.25) {
            color = 'green';
        } else if (percent >= 0.25 && percent <= 0.75) { // TODO
            color = "orange";
        } else {
            color = "red";
        }
        return color;
    },

    isWeightAvailabe: function () {

    },


});
it.CameraFollow = function (camera) {
    
    this.setHost = function(hostNode){
        if(camera._hostNode){
        	  camera._hostNode.removePropertyChangeListener(follow);
    	  }
    		camera._hostNode = hostNode;
    		hostNode.addPropertyChangeListener(function(e){
    	       follow(e,hostNode);
    		});
    };

	function follow(e,node){
       var property = e.property;
       if(property.startsWith('position') || property.startsWith('rotation')){
     	   	var pos = node.p();
     	   	var distance = camera.getDistance();
     	   	var pos2 = node.worldPosition(new mono.Vec3(-2,1,0),distance);			
		      camera.lookAt(pos);
		      camera.setPosition(pos2);
       }
	};
}
it.InspectionManager = function (sceneManager) {

    it.EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.visibleManager = new it.VisibleManager(sceneManager);
    sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
    this.dataManager = this.sceneManager.dataManager;
    this.camera = this.sceneManager.network3d.getCamera();
    this.box = this.sceneManager.network3d.getDataBox();

    this.status = it.InspectionManager.STATUS_READY;
    this.host = null;//小人或其它
    this.path = [];//路径
    this.animates = [];//动画
    this.loop = false; //是否循环播放,在执行play前设置有效, 默认是false
    this.finalAngle = null;//最后的角度
    this.limitDistance = 200;//距离轨迹直线的距离,距离100范围内
    this.limitAngle = 40; //机柜的旋转角度和面向轨迹直线法线的夹角, 正负40度范围内
    this.inspectDataArray = [];//保存本次巡检所有的data
    this.inspectDataMap = {};//保存本次巡检所有的data
    this.currentInspectDataArray = [];//保存当前移动动画,需要巡检的data
    this.currentInspectingDataMap = {}; // 保存正在巡检的data
    this.inspectColor = 'orange';//巡检时,渲染的颜色
    this.moveSpeed = 10; //移动速度
    this.rotateSpeed = 400;//旋转速度
    this.showTrail = true;//显示巡检轨迹

    this.trailColor = 'green';//巡检轨迹颜色
    this.trailWidth = 20;//巡检轨迹宽度
    this.trailHeight = 3;//巡检高度

    this.hideDataMap = {};//巡检时,隐藏的data

    this.isCameraFollow = true;
    this.cameraFollow = null;

};


it.InspectionManager.STATUS_READY = 'ready';
it.InspectionManager.STATUS_PLAYING = 'playing';
it.InspectionManager.STATUS_PAUSE = 'pause';
it.InspectionManager.STATUS_STOP = 'stop';


mono.extend(it.InspectionManager, it.EventHandler, {

    /**
     * 正在巡检
     * @param data
     */
    renderDataHandle: function (data) {

    },

    /**
     * 清除巡检
     */
    resetDataHandler: function (data) {

    },


    /**
     * 创建估计对象
     */
    createTrail: function (points, trailWidth, trailHeight, trailColor) {

        var path = new mono.Path();
        path.moveTo(points[0][0], points[0][1]);
        for (var i = 1; i < points.length; i++) {
            path.lineTo(points[i][0], points[i][1]);
        }
        path = mono.PathNode.prototype.adjustPath(path, 20);
        trailWidth = trailWidth || this.trailWidth;
        trailHeight = trailHeight || this.trailHeight;
        trailColor = trailColor || this.trailColor;
        var trail = new mono.PathCube(path, trailWidth, trailHeight);
        trail.s({
            'm.type': 'phong',
            'm.specularStrength': 30,
            'm.color': trailColor,
            'm.ambient': trailColor,
            'm.texture.repeat': new mono.Vec2(150, 1),
        });
        trail.setRotationX(Math.PI);
        trail.setPositionY(trailHeight / 2 + 4);
        trail.setClient('type', 'trail');
        return trail;
    },
    /**
     * 开始巡检
     */
    play: function () {
        if (this.isPlaying()) {
            console.warn('it is already playing');
            return;
        }

        if (this.isPause()) {
            console.warn('status is pause, you should call resume function');
            return;
        }
        //ready或者stop时,重新开始
        this.startPlay();
        this.status = it.InspectionManager.STATUS_PLAYING;
    },

    /**
     * 暂停巡检
     */
    pause: function () {
        if (this.isPlaying()) {
            var animate = this.getCurrentAnimate();
            animate.pause();
            this.status = it.InspectionManager.STATUS_PAUSE
        } else {
            console.warn('when inspection status is playing, you can pause inspection')
        }
    },

    /**
     * 恢复巡检
     */
    resume: function () {
        if (this.isPause()) {
            //如果是暂停,继续播放
            var animate = this.getCurrentAnimate();
            animate.resume();
            this.status = it.InspectionManager.STATUS_PLAYING;
        } else {
            console.warn('when inspection status is pause, you can resume inspection')
        }
    },

    /**
     * 停止巡检
     * @param finish
     */
    stop: function (finish) {
        if (this.isPlaying() || this.isPause()) {
            if (!finish) {
                var animate = this.getCurrentAnimate();
                animate.stop();
            }
            this.resetHideData();
            this.resetInspectData();
            this.onFinish();
            //播放完毕,释放资源
            if (this.trail) {
                this.box.remove(this.trail);
            }
            delete this.animates;
            delete this.trail;
            delete this.host.animate;

            this.status = it.InspectionManager.STATUS_STOP;
        } else {
            console.warn('inspection is not started')
        }
    },

    /**
     * 增加一个巡检路径, 如果已经播放或者暂停,禁止添加
     * @param path {[{x,y}]} 添加的path,
     */
    setPath: function (path) {
        this.path = path;
    },

    /**
     * 设置移动的host
     * @param host
     */
    setHost: function (host) {
        this.host = host;
    },

    /**
     * 是否是就绪状态
     * @returns {boolean}
     */
    isReady: function () {
        return this.status == it.InspectionManager.STATUS_READY;
    },

    /**
     * 是否是巡检状态
     * @returns {boolean}
     */
    isPlaying: function () {
        return this.status == it.InspectionManager.STATUS_PLAYING;
    },

    /**
     * 是否暂停状态
     * @returns {boolean}
     */
    isPause: function () {
        return this.status == it.InspectionManager.STATUS_PAUSE;
    },

    /**
     * 是否是停止状态
     * @returns {boolean}
     */
    isStop: function () {
        return this.status == it.InspectionManager.STATUS_STOP;
    },

    /**
     * 巡检结束
     */
    onFinish: function () {

        console.log("inspection is completed")
    },

    /**
     * 开始巡检
     * 找到所有的巡检对象
     * 计算处巡检的轨迹,动画效果
     */
    startPlay: function () {

        var self = this;
        var sceneManager = this.sceneManager;
        var camera = this.camera;
        var box = this.box;

        this.initInspectData();

        var object = this.host;
        if (this.isCameraFollow) {
            var cameraFollow = this.cameraFollow || new it.CameraFollow(camera);
            cameraFollow.setHost(object);
        }
        var points = this.path;
        object.setPositionX(points[0][0]);
        object.setPositionZ(points[0][1]);
        //create animate chain
        var animates = this.animates = this.createPathAnimates(camera, object, points, this.loop, this.finalAngle);
        animates[animates.length - 1].onDone = function () {

            self.stop(true);
        };

        this.hideData();

        if (this.showTrail) {

            if (self.createTrail) {
                this.trail = self.createTrail(this.path);
            }
            if (this.trail) {
                this.trail.setParent(this.host.getParent());
                box.add(this.trail);
            }
        }
        //start play
        object.animate = animates[0];
        object.animate.play();
    },

    hideData: function () {
        var self = this;
        var keys = Object.keys(this.hideDataMap);
        keys.forEach(function (key) {
            var data = self.hideDataMap[key];
            self.visibleManager.setVisible(data, false);
        })
    },

    resetHideData: function () {
        var self = this;
        var keys = Object.keys(this.hideDataMap);
        keys.forEach(function (key) {
            var data = self.hideDataMap[key];
            self.visibleManager.setVisible(data, true);
        })
    },

    /**
     * 初始化需要巡检的数据
     */
    initInspectData: function () {
        this.inspectDataArray = [];
        this.inspectDataMap = {};
        this.hideDataMap = {};
        this.box.getNodes().forEach(function (node) {
            var data = this.sceneManager.getNodeData(node);
            if (data && !this.inspectDataMap[data.getId()] && this.isInspect(data)) {
                this.initDataPositionAndRotation(data);
                this.inspectDataMap[data.getId()] = data;
                this.inspectDataArray.push(data);
            }
            if (data && !this.hideDataMap[data.getId()] && this.isHideInInspection(data)) {
                this.hideDataMap[data.getId()] = data;
            }
        }, this);
    },

    /**
     * 取得当前的动画
     * @returns {*}
     */
    getCurrentAnimate: function () {
        if (this.host) {
            return this.host.animate;
        }
        return null;
    },

    /**
     * 创建动画
     * @param camera
     * @param element
     * @param points
     * @param loop
     * @param finalAngle
     * @returns {Array}
     */
    createPathAnimates: function (camera, element, points, loop, finalAngle) {

        var self = this;
        var animates = [];
        var moveSpeed = this.moveSpeed || 10;
        var rotateSpeed = this.rotateSpeed || 400;

        if (points && points.length >= 2) {

            var angle = element.getRotationY() || 0;

            for (var i = 1; i < points.length; i++) {
                var point0 = points[i - 1];
                var point1 = points[i];
                var x = point0[0];
                var z = point0[1];
                var x1 = point1[0];
                var z1 = point1[1];
                var rotate = Math.atan2(-(z1 - z), x1 - x) || 0;

                var rotateAnimate = this.createRotateAnimate(camera, element, rotateSpeed, rotate, angle);
                if (rotateAnimate) {
                    animates.push(rotateAnimate);
                    angle = rotateAnimate.toAngle;
                }

                var moveAnimate = this.createMoveAnimate(camera, element, moveSpeed, x, z, x1, z1);
                animates.push(moveAnimate);

                x = x1;
                z = z1;
            }

            if (finalAngle != undefined && angle != finalAngle) {
                var rotateAnimate = this.createRotateAnimate(camera, element, rotateSpeed, finalAngle, angle);
                if (rotateAnimate) {
                    animates.push(rotateAnimate);
                }
            }
        }
        var animate;
        for (var i = 0; i < animates.length; i++) {
            if (i > 0) {
                animates[i - 1].chain(animates[i]);
                if (loop && i == animates.length - 1) {
                    animates[i].chain(animate);
                }
            } else {
                animate = animates[i];
            }
        }
        return animates;
    },

    /**
     * 创建移动动画
     * @param camera
     * @param element
     * @param moveSpeed
     * @param x
     * @param z
     * @param x1
     * @param z1
     * @returns {TGL.Animate|mono.Animate|Ib.Animate|Ib.animate.Animate}
     */
    createMoveAnimate: function (camera, element, moveSpeed, x, z, x1, z1) {

        var self = this;
        var moveAnimate = new mono.Animate({
            from: { x: x, y: z },
            to: { x: x1, y: z1 },
            type: 'point',
            dur: Math.sqrt((x1 - x) * (x1 - x) + (z1 - z) * (z1 - z)) * moveSpeed,
            easing: 'easeNone',
            onPlay: function () {
                element.animate = this;
                self.currentInspectDataArray = self.getCurrentInspectionData(this);
                self.resetInspectData();
            },
            onUpdate: function (value) {
                element.setPositionX(value.x);
                element.setPositionZ(value.y);
                self.renderInspectData();

            },
        });
        return moveAnimate;
    },

    /**
     * 创建旋转动画
     * @param camera
     * @param element
     * @param toAngle
     * @param angle
     * @returns {*}
     */
    createRotateAnimate: function (camera, element, rotateSpeed, toAngle, angle) {

        angle = parseFloat(angle);
        toAngle = parseFloat(toAngle);
        if (angle === undefined || angle === null || isNaN(angle) ||
            toAngle === undefined || angle === null || isNaN(toAngle) ||
            toAngle == angle) {
            return null;
        }
        if (toAngle - angle > Math.PI) {
            toAngle -= Math.PI * 2;
        }
        if (toAngle - angle < -Math.PI) {
            toAngle += Math.PI * 2;
        }
        //console.log(angle, toAngle);
        var rotateAnimate = new mono.Animate({
            from: angle,
            to: toAngle,
            type: 'number',
            dur: Math.abs(toAngle - angle) * rotateSpeed,
            easing: 'easeNone',
            onPlay: function () {
                element.animate = this;
            },
            onUpdate: function (value) {
                value = value || 0;
                element.setRotationY(value);
            },

        });
        rotateAnimate.toAngle = toAngle;
        return rotateAnimate;
    },


    /**
     * 渲染正在巡检的对象
     * @param data
     */
    renderData: function (data) {

        if (data._inspected) {
            return;
        }
        data._inspected = true;
        var node = this.sceneManager.getNodeByDataOrId(data);
        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        var oldColor = node.getStyle('inspection.m.ambient') || node.getStyle('m.ambient');
        node.setStyle('m.ambient', this.inspectColor);
        node.setStyle('inspection.m.ambient', oldColor);
        this.renderDataHandle && this.renderDataHandle(data);
    },

    /**
     * 恢复巡检的对象
     * @param data
     */
    resetData: function (data) {
        if (!data._inspected) {
            return;
        }
        data._inspected = false;
        delete data._inspected;
        delete data._face2animateLine;
        delete data._distance2host;
        var node = this.sceneManager.getNodeByDataOrId(data);
        if (node.getClient('complexNode')) {
            node = node.getClient('complexNode') != 'unload' && node.getClient('complexNode').getParent() ? node.getClient('complexNode') : node.getClient('simpleNode');
        }
        node.setStyle('m.ambient', node.getStyle('inspection.m.ambient'));
        node.setStyle('inspection.m.ambient', null);
        this.resetDataHandler && this.resetDataHandler(data);
    },

    /**
     * 渲染所有的巡检对象
     */
    renderInspectData: function () {

        var result = false;
        var self = this;

        var newDataArrayTemp = [];
        //找到所有靠近host的data
        this.currentInspectDataArray.forEach(function (data) {
            if (self.isClosed(data, self.host)) {
                newDataArrayTemp.push(data);

            }
        })

        //只选择最近的data, 过滤掉相同角度的其它data,
        var newDataArray = this.filterInspectData(newDataArrayTemp);

        //保存所有新的data
        var map = {};
        newDataArray.forEach(function (data) {
            map[data.getId()] = data;
        })

        //如果没有渲染,渲染data
        newDataArray.forEach(function (data) {
            if (!self.currentInspectingDataMap[data.getId()]) {
                self.renderData(data);
                self.currentInspectingDataMap[data.getId()] = data;
                result = result || true;
            }
        })

        //如果已经不需要渲染, 清除渲染标记
        var keys = Object.keys(this.currentInspectingDataMap);
        if (keys.length > 0) {
            keys.forEach(function (key) {
                if (!map[key]) {
                    self.resetData(self.currentInspectingDataMap[key]);
                    delete self.currentInspectingDataMap[key];
                    result = result || true;
                }
            })
        }
        return result;
    },

    /**
     * 恢复所有的巡检对象
     */
    resetInspectData: function () {
        var self = this;
        var keys = Object.keys(this.currentInspectingDataMap);
        if (keys.length > 0) {
            keys.forEach(function (key) {
                self.resetData(self.currentInspectingDataMap[key]);
                delete self.currentInspectingDataMap[key]
            })
        }
    },

    /**
     * 按距离和角度过滤巡检对象
     * @param array
     * @returns {*}
     */
    filterInspectData: function (array) {

        if (array.length <= 1) {
            return array;
        }
        var result = [];

        //按距离又小到大排序
        array.sort(function (o1, o2) {
            return o1._distance2host - o2._distance2host;
        });

        for (var i = 0; i < array.length; i++) {
            var d = array[i];
            //如果是已经巡检过的,过滤
            if (d._face2animateLine === undefined) {
                continue;
            }
            if (!this.haveSameDir(d, result)) {
                result.push(d);
            }
        }

        return result;
    },

    /**
     * 是否以已经有相同角度的对象
     * @param data
     * @param array
     * @returns {boolean}
     */
    haveSameDir: function (data, array) {
        var angle = data._face2animateLine;
        for (var j = 0; j < array.length; j++) {
            var angleTmp = array[j]._face2animateLine;
            //如果有相邻的,取消
            if (Math.abs(angle - angleTmp) < 45) {
                return true;
            }
        }
        return false;
    },

    /**
     * 是否需要巡检
     * 默认机柜和列头柜巡检
     * @param data
     * @returns {boolean}
     */
    isInspect: function (data) {
        var dataType = this.dataManager.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'rack' || categoryId == 'headerRack') {
            return true;
        }
        return false;
    },

    /**
     * 是否在巡检时隐藏
     * @param data
     * @returns {boolean}
     */
    isHideInInspection: function (data) {
        var dataType = this.dataManager.getDataTypeForData(data);
        if (!dataType) {
            return false;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'channel') {
            return true;
        }
        return false;
    },

    /**
     * 取得当前动画执行轨迹, 所有面向轨迹的data, 并且离轨迹距离小与limitDistance的data
     * @param animate
     * @returns {Array}
     */
    getCurrentInspectionData: function (animate) {
        var result = [];
        var from = animate.from;
        var to = animate.to;
        var line = this.getLine(from, to);
        this.inspectDataArray.forEach(function (data) {
            if (this.isFace2Line(data, from, to, line)) {
                result.push(data);
            }
        }, this)
        return result;
    },

    /**
     * 是否面向线路
     * @param data
     * @returns {boolean}
     */
    isFace2Line: function (data, from, to, line) {

        var np = data._absolutePosition;
        var npx = np.x;
        var npy = np.z;
        var nodeAngle = data._absoluteRotation.y;
        if (line.b == 0) {

            var dx = npx - to.x;
            if (Math.abs(dx) > this.limitDistance) {
                return false;
            }

            //竖直线
            var angle;
            //右边
            if (npx > -line.c) {
                angle = 270;
            } else {
                angle = 90;
            }
            //角度不对
            if (Math.abs(nodeAngle - angle) > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        } else if (line.a == 0) {

            var dy = npy - to.y;
            if (Math.abs(dy) > this.limitDistance) {
                return false;
            }

            //水平线
            var angle;
            //上方
            if (npy > -line.c) {
                angle = 180;
            } else {
                angle = 0;
            }
            if (Math.abs(nodeAngle - angle) > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        } else {

            var d = Math.abs((line.a * npx + line.b * npy + line.c) / Math.sqrt(Math.pow(line.a, 2) + Math.pow(line.b, 2)))
            if (d > this.limitDistance) {
                return false;
            }

            //斜线
            var kk = 1 / line.k;//法线角度
            var angle = Math.atan(kk) / Math.PI * 180; //换算成角度
            var npxx = -(line.b * npy + line.c) / line.a;
            //点在线右边
            if (npxx < npx) {// 90度到 270度

                angle += 180;
            } else {  // -90 度 到 90度

                if (angle < 0) {
                    angle += 360;
                }
            }
            //机柜默认旋转了-90度,所以要加上90度
            angle += 90;
            angle = angle % 360;
            //计算处夹角, 夹角绝对值不可能大于180度
            var da = Math.abs(nodeAngle - angle);
            if (da > 180) { //如果是大于180度, 反向取值, 夹角绝对值不可能大于180度
                da = 360 - da;
            }
            if (da > this.limitAngle) {
                return false;
            }
            data._face2animateLine = angle;
        }
        return true;
    },

    /**
     * 是否巡检到当前数据
     * @param data
     * @param host
     * @returns {*}
     */
    isClosed: function (data, host) {

        var np = data._absolutePosition;
        var npx = np.x;
        var npy = np.z;

        var hp = host.getPosition();
        var hpx = hp.x;
        var hpy = hp.z;
        var d = Math.sqrt(Math.pow(hpx - npx, 2) + Math.pow(hpy - npy, 2));
        data._distance2host = d;
        return d < this.limitDistance;
    },

    /**
     * 根据两点, 计算出直线
     * @param p1
     * @param p2
     * @returns {*}
     */
    getLine: function (p1, p2) {
        if (p1.x == p2.x) {
            //竖直线
            return { a: 1, b: 0, c: -p1.x };
        } else if (p1.y == p2.y) {
            //水平线
            return { a: 0, b: 1, c: -p1.y }
        }
        var a = 0, b = 0, c = 0;
        var k = (p1.y - p2.y) / (p1.x - p2.x);
        var c = p1.y - k * p1.x;
        a = k, b = -1;
        return { a: a, b: b, c: c, k: k }
    },

    /**
     * 计算data相对于楼层的绝对坐标
     * @param data
     */
    initDataPositionAndRotation: function (data) {

        if (data._absolutePosition && data._absoluteRotation) {
            return;
        }
        var node = this.sceneManager.getNodeByDataOrId(data);
        var p = node.getPosition();
        var r = node.getRotation();
        var pp = { x: p.x, y: p.y, z: p.z };
        var rr = { x: r.x, y: r.y, z: r.z };
        var parentData = this.dataManager.getDataById(data.getParentId());
        this._initDataPositionAndRotation(parentData, pp, rr);
        rr.x = (rr.x / Math.PI * 180) % 360;
        rr.y = (rr.y / Math.PI * 180) % 360;
        rr.z = (rr.z / Math.PI * 180) % 360;
        data._absolutePosition = pp;
        data._absoluteRotation = rr;
    },

    /**
     * 取得相对于父亲的坐标
     * @param parentData
     * @param position
     */
    _initDataPositionAndRotation: function (parentData, position, rotation) {

        if (!parentData) {
            return;
        }
        var dataType = this.dataManager.getDataTypeForData(parentData);
        if (!dataType) {
            console.warn('dataType is null');
            return;
        }
        var categoryId = dataType.getCategoryId();
        if (categoryId == 'floor') {
            console.warn('parent data type is floor, calculate position complete')
            return;
        }

        //
        //x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ;

        //y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ;

        var parentNode = this.sceneManager.getNodeByDataOrId(parentData);
        if (parentNode) {
            var pp = parentNode.getPosition();
            var rr = parentNode.getRotation();

            var x = position.x;
            var z = position.z;
            var rx0 = 0;
            var rz0 = 0;
            var a = -rr.y;//还原角度
            var x0 = (x - rx0) * Math.cos(a) - (z - rz0) * Math.sin(a) + rx0;
            var z0 = (x - rx0) * Math.sin(a) + (z - rz0) * Math.cos(a) + rz0;
            position.x = x0;
            position.z = z0;//2D和3D的方向相反,3D顶视图, 逆时针旋转为正, z轴上为负, 下为正

            position.x += pp.x;
            position.y += pp.y;
            position.z += pp.z;


            rotation.x += rr.x;
            rotation.y += rr.y;
            rotation.z += rr.z;
        }

        var parentParentData = this.dataManager.getDataById(parentData.getParentId());
        if (parentParentData) {
            this._initDataPositionAndRotation(parentParentData, position, rotation);
        }
    }
});

/**
 * 端口管理
 * 1、根据模板数据创建端口
 * 2、连线连到端口
 * 3、端口告警
 */
var $PortManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	this.dataBox = this.sceneManager.network3d.getDataBox();
	//为了跟2D中端口的id统一，采用:'id+"@"+parentId'的方式,可是不太好根据parentId来查找，并且不太严格，
	//因此采用tree的结构来存储,即：{parentId001:{port01:portNode01,...},parentId001:{port01:portNode01,...}}
	this.portNodeMap = {}; // 注意正反面的问题，保存时没有考虑正反面的问题哦———— 2017-07-21
};

mono.extend($PortManager,Object,{

	removePortsByParentId : function(parentId){
		var ports = this.portNodeMap[parentId];
		if (ports) {
			for(var id in ports){
				var port = ports[id];
				if (port) {
					port.setParent(null);
					this.dataBox.remove(port);
				}
			}
			// delete this.portNodeMap[parentId];
		}
	},

	/**
     * 根据设备id，获取到所有的端口对象
     */
	getAllPortsByParentId: function(parentId){
		var ports = [];
		var dataType = this.dataManager.getDataTypeForData(parentId);
		if (!dataType || !dataType.getTemplateDatas()) {
			return null;
		}
		var templateDatas = dataType.getTemplateDatas();
		for(var i = 0 ;i < templateDatas.length; i++){
			var tdata = templateDatas[i];
			var side = tdata.getUserData('side')||0;
			port = this.loadPortByPortId(parentId,tdata.getId(),side);
			ports.push(port);
		}
		return ports;
	},
    
    /**
     * 根据设备id，加载该设备所有的端口
     */
	loadAllPortsByParentId : function(parentId){
		var ports = this.getAllPortsByParentId(parentId);
		for(var i = 0 ;i < ports.length; i++){
			var port = ports[i];
			this.dataBox.add(port);
		}
	},
    
    /**
     * 根据端口id(端口id包括了parentid和端口id，以下同理)加载端口
     */
	loadPortByPortId : function(parentId,portId,side){
		var port = this.getPortById(parentId,portId);
		if (port) {
			return port;
		}
	    port = this.createPortByPortId(parentId,portId,side);
		if (port) {
			var parentPorts = this.portNodeMap[parentId];
			if (!parentPorts) {
				parentPorts = {portId:port};
				this.portNodeMap[parentId] = parentPorts;
			}else{
				parentPorts[portId] = port;
			}
		}
		return port;
	},

    /**
     * 根据端口id找对应的端口对象
     */
	getPortById : function(parentId,portId){
		var parentPorts = this.portNodeMap[parentId];
		if (parentPorts) {
			return parentPorts[portId];
		}
		return null;
	},
    
    /**
     * 根据端口id创建3d端口
     * @parentId 表示的是设备的id
     * @portId 是端口的id
     * @side 表示的是哪一面，0是正面，1是反面
     * 并且如果是反面的话，需要旋转(左边跑到右边，正面跑到反面)
     */
	createPortByPortId : function(parentId,portId,side){
		var dataType = this.dataManager.getDataTypeForData(parentId);
		var devNode = this.sceneManager.getNodeByDataOrId(parentId);
		if (!dataType || !portId || !devNode) {
			return null;
		}
		side = side||0;
		var portData = dataType.getTemplateDataById(portId+(side?'@true':'@false'));
		if (!portData) {
			return null;
		}
		var panelData = dataType.getModel2dParameters()[0];
		var portType = this.dataManager.getDataTypeById(portData.getDataTypeId()); //can not getDataTypeForData
		if (!portType) {
			return null;
		}
		if (!panelData) {
			return null;
		}
		if (!portType.getModel()) {
			console.log('portType‘s model is null!');
			return null;
		};
		var panelParam = make.Default.getModelDefaultParametersValues(panelData.id);
		// 端口的尺寸{width: 13.06, height: 9.55}
		var portParam = make.Default.getModelDefaultParametersValues(portType.getModel2d());
		if (!portParam) {
			console.log('port Param is null');
			return null;
		}
		var port = this.sceneManager.loadModel(portType.getModel(),portType.getModelParameters(),true,portType.getId());
		// x:(data.getPosition().x - panel.size.x)/10
		// y:(data.getPosition().y - panel.size.y)/10
		var port2DPos = portData.getPosition();
		var portRot = portData.getRotation();// 角度制
		var dbb = devNode.getBoundingBox();
		if (!port || !port2DPos || !panelParam) {
			return null;
		}
		 // {width: 455, height: 44.45} ,不是10倍的关系(x: 50, y: 4.445, z: 51)，还是更加boundingBox的size来推算吧
		 var scaleX = panelParam.width/dbb.size().x; 
		 var scaleY = panelParam.height/dbb.size().y;

         /* 
		 var padding = devNode.getClient('padding');
		 if (side === 1 && padding && padding instanceof Array) {
		 	 var up = padding[0]||0,right = padding[1]||0,down = padding[2]||0,left = padding[3]||0;
		 	 scaleX = panelParam.width/(dbb.size().x - right - left);
		 	 scaleY = panelParam.height/(dbb.size().y - up - down);
		 }
		 */
		 // 可能是横着的，也可能是竖着的。可能n行n列 
		var x = (port2DPos.x + portParam.width/2 - panelParam.width/2)/scaleX; 
		var y = (panelParam.height/2 - portParam.height/2 - port2DPos.y)/scaleY; // 2d中左上角为(0,0)，并且host的location是host的左上角的位置
		if (side === 1) { // 背面的话，需跟正面比较，算出新的padding
		 	var backPanelData = dataType.getModel2d2Parameters()[0];
		 	var backPanelParam = make.Default.getModelDefaultParametersValues(backPanelData.id);
		 	var backWidth = backPanelParam.width;
		 	var backHeight = backPanelParam.height;
		 	// var up  = (panelParam.height-backHeight)/2;
		 	// var left = (panelParam.width-backWidth)/2;
		 	var up = 0; //从中心往两边跑，不需要+up和-left
		 	var left = 0;
		 	x = (port2DPos.x + portParam.width/2 + left - backPanelParam.width/2)/scaleX; 
		    y = (backPanelParam.height/2 - portParam.height/2 - port2DPos.y - up)/scaleY;
		}
		port.setX(x);
		port.setY(y);
		if (side === 1) {
			port.setZ(dbb.min.z); 
			// 如果是反面的话，创建的端口则需要旋转，并且位置也要反过来，原来在右边的应该跑到左边，左边跑到右边
			port.setRotationY(Math.PI);
			var px =  (-1)*x;  //反一下
			port.setX(px);
		}else{
			port.setZ(dbb.max.z);
		}
		if (portRot) {
			if (portRot.x) {
				port.setRotationX(portRot.x*Math.PI/180);
			}
			if (portRot.z) {
				port.setRotationZ(portRot.z*Math.PI/180);
			}
		}
		port.c({
			'parentId': parentId,
			'portId': portId,
			'side': side
		});
		port.setParent(devNode);
		return port;
	}
	
});

it.PortManager = $PortManager;
/**
 * 端口占用率管理
 * @param sceneManager
 * @constructor
 */
it.PortCapacityManager = function (sceneManager) {

    it.EventHandler.call(this);
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.visibleManager = new $VisibleManager(this.sceneManager);
    this.sceneManager.viewManager3d.addVisibleFilter(this.visibleManager);
    this.colors = ['#8A0808', '#088A08', '#088A85', '#6A0888', '#B18904'];
    this.padding = 2.5;
    this.portNodes = [];
    this.solidColor = '#eaeaea';
};

it.PortCapacityManager.CATEGORY_EQUIPMENT = 'equipment';
it.PortCapacityManager.CATEGORY_PORT = 'port';

mono.extend(it.PortCapacityManager, it.EventHandler, {

    /**
     * 计算端口利用率
     * @param dataOrId
     * @returns {*}
     */
    computePortPercent: function (dataOrId) {

        var dm = this.dataManager;
        var data = dataOrId;
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            return;
        }
        //只计算设备的端口利用率
        if (dataType.getCategoryId() != it.PortCapacityManager.CATEGORY_EQUIPMENT) {
            return;
        }

        //计算所有端口
        var ports = this.computePortInfo(data);
        //如果没有端口,默认端口利用率是100%
        if (!ports || ports.length == 0) {
            return 100;
        }

        //计算出有连线的端口数量
        var count = 0;
        for (var i = 0; i < ports.length; i++) {
            var port = ports[i];
            var links = port.getAllLinks();
            if (links && Object.keys(links).length > 0) {
                count++;
            }
        }
        return count / ports.length * 100;
    },

    /**
     * 从设备的所有孩子中查找出端口
     * @param dataOrId
     * @returns {Array}
     */
    computePortInfo: function (dataOrId) {

        var dm = this.dataManager;
        var self = this;
        var data = dataOrId;
        if (!data.getId) {

            data = dm.getDataById(dataOrId);
        }
        //取得所有的端口
        var allPorts = [];
        var children = dm.getChildren(data);
        children.forEach(function (child) {
            var childDataType = dm.getDataTypeForData(child);
            if (!childDataType || childDataType.getCategoryId() != it.PortCapacityManager.CATEGORY_PORT) {
                return;
            }
            allPorts.push(child);
        })
        return allPorts;
    },

    /**
     * 创建重量比率节点
     * @param dataOrId
     */
    createPortNode: function (dataOrId, width, height, depth, positionY, rackNode) {

        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId,
            box = sm.network3d.getDataBox();
        //如果不在当前场景
        if (!sm.isCurrentSceneInstance(dataOrId)) {
            return;
        }
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        var percent = this.computePortPercent(data);

        if (percent == null) {
            return;
        }

        percent = Math.round(Math.random() * 100);//FIXME 发后注释
        data._portPercent = percent;

        var portNode = data._portNode;
        if (!portNode) {
            portNode = new mono.Cube(width, height, depth);
            portNode.setPosition(0, positionY, 0);
            portNode.s({
                'm.type': 'phong',
                'm.specularStrength': 50,
                'm.transparent': true,
                'm.opacity': 0.6,

            });
            portNode.setClient('it_data', 'port');
            portNode.setClient('portChildNode', true);
            portNode.setClient('data', data);
            data._portNode = portNode;
        }
        var color = this.getPortNodeColor(percent);
        portNode.s({
            'm.color': color,
            'm.ambient': color,
        });
        portNode.setParent(rackNode);
        box.addByDescendant(portNode);
        return portNode;
    },

    /**
     * 创建重量比率节点
     * @param dataOrId
     */
    createSolidNode: function (width, height, depth, positionY, rackNode) {

        var sm = this.sceneManager, dm = this.dataManager, box = sm.network3d.getDataBox();

        var solidNode = solidNode = new mono.Cube(width, height, depth);
        solidNode.setPosition(0, positionY, 0);
        solidNode.s({
            'm.type': 'phong',
            'm.specularStrength': 50,
            'm.color': this.solidColor,
            'm.ambient': this.solidColor,

        });
        solidNode.setClient('it_data', 'port_solid');
        solidNode.setClient('portChildNode_solid', true);
        solidNode.setParent(rackNode);
        box.addByDescendant(solidNode);
        return solidNode;
    },

    makeItDataUnvisible: function (data) {
        if (!data) {
            return;
        }
        this.visibleManager.setVisible(data, false);
        var self = this;
        data.getChildren().forEach(function (child) {
            self.makeItDataUnvisible(child);
        });
    },

    makeItDataVisible: function (data) {//node
        if (!data) {
            return;
        }
        this.visibleManager.setVisible(data, true);
        var self = this;
        data.getChildren().forEach(function (child) {
            self.makeItDataVisible(child);
        });
    },

    removePortNode: function (dataOrId) {
        var sm = this.sceneManager, dm = this.dataManager, data = dataOrId, box = sm.network3d.getDataBox();
        if (!data.getId) {
            data = dm.getDataById(dataOrId);
        }
        delete data._portPercent;
        var portNode = data._portNode;
        if (portNode) {
            portNode.setParent(null);
            box.removeByDescendant(portNode);
        }
        this.makeItDataVisible(data);
    },

    getPortNodeColor: function (percent) {
        if (this.portNodeColorFunction) {
            var color = this.portNodeColorFunction(percent);
            return color;
        }

        var colorIndex = Math.ceil(percent / 20);
        return this.colors[colorIndex - 1];
    },

    isDataSupport: function (data) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId() == it.PortCapacityManager.CATEGORY_EQUIPMENT && dataType.getSubType() == 'network') {

            return true;
        }
        return false;
    },

    calcDataHeight: function (data) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var size = dataType.getSize();
        return parseInt(size.ySize || 0) * make.Default.UNIT_HEIGHT;
    },


    /**
     * 显示机柜里面设备的端口占用率
     * FIXME 颜色块之间,要加上一个小间隔试试
     * @param data
     */
    createPortNodeInRack: function (data) {
        var result = [];
        var sm = this.sceneManager, dm = this.dataManager, self = this;
        //如果不在当前场景
        if (!sm.isCurrentSceneInstance(data)) {
            return;
        }
        var dataType = dm.getDataTypeForData(data);
        if (!dataType) {
            console.warn('dataType is not exist');
            return;
        }
        var rackNode = sm.getNodeByDataOrId(data);
        if (!rackNode) {
            console.warn('rack node is not exist')
            return;
        }
        var childrenSize = dataType.getChildrenSize();
        var boundingBox = rackNode.getBoundingBox(),
            size = boundingBox.size(),
            width = size.x, height = size.y, depth = size.z;

        this.makeItDataUnvisible(data);
        var childrenAll = dm.getChildren(data);
        //var children = [];
        var childMap = {};
        //过滤出设备节点
        childrenAll.forEach(function (child) {
            if (self.isDataSupport(child)) {
                //children.push(child);
                childMap[child.getLocation().y] = child;
            }
        })

        var lastSolid = 0;
        //按机柜高度显示端口占用比
        for (var i = 1; i <= childrenSize.ySize; i++) {
            if (childMap[i]) {

                var child = childMap[i];
                if (lastSolid != 0) {
                    //填补之前的空白块
                    var childSize = i - lastSolid;
                    var childHeight = parseInt(childSize) * make.Default.UNIT_HEIGHT;
                    childHeight -= self.padding;

                    var positionY = childrenSize.yPadding[0];
                    positionY += (lastSolid - 1 + (childSize) / 2) * make.Default.UNIT_HEIGHT;
                    positionY += self.padding / 2;
                    positionY -= height /2;
                    console.log('solid: height = ' + childHeight + '  positionY = ' + positionY);
                    var node = self.createSolidNode(width, childHeight, depth, positionY, rackNode);
                    if (node) {
                        result.push(node);
                    }
                    lastSolid = 0;
                }
                var childDataType = dm.getDataTypeForData(child);
                var childSize = childDataType.getSize().ySize;
                var childHeight = parseInt(childSize || 0) * make.Default.UNIT_HEIGHT;
                childHeight -= self.padding;

                var loc = child.getLocation();
                var positionY = childrenSize.yPadding[0];
                positionY += (loc.y - 1 + childSize / 2) * make.Default.UNIT_HEIGHT;
                positionY += self.padding / 2;
                positionY -= height /2;
                console.log('port : height = ' + childHeight + '  positionY = ' + positionY);
                var node = self.createPortNode(child, width, childHeight, depth, positionY, rackNode);
                if (node) {
                    result.push(node);
                }
                i--;
                i += childSize;
            } else if (lastSolid == 0) {
                lastSolid = i;
                continue;
            }

        }
        if (lastSolid != 0) {
            //填补之前的空白块
            var childSize = i - lastSolid;
            var childHeight = parseInt(childSize) * make.Default.UNIT_HEIGHT;
            childHeight -= self.padding;

            var positionY = childrenSize.yPadding[0];
            positionY += (lastSolid - 1 + (childSize) / 2) * make.Default.UNIT_HEIGHT;
            positionY += self.padding / 2;
            positionY -= height /2;
            console.log('solid: height = ' + childHeight + '  positionY = ' + positionY);
            var node = self.createSolidNode(width, childHeight, depth, positionY, rackNode);
            if (node) {
                result.push(node);
            }
            lastSolid = 0;
        }
        data.portNodeArray = result;
        //按顺序排序
        //children.sort(function (o1, o2) {
        //    return o1.getLocation().y - o2.getLocation().y;
        //})
        //children.forEach(function (child) {
        //
        //    var solid = !!child.network;
        //    var childDataType = dm.getDataTypeForData(child);
        //    var childSize = childDataType.getSize();
        //    var childHeight = parseInt(childSize.ySize || 0) * make.Default.UNIT_HEIGHT;
        //    var loc = child.getLocation();
        //    var positionY = childrenSize.yPadding[0];
        //    positionY += loc.y * make.Default.UNIT_HEIGHT - height / 2;
        //    childHeight -= self.padding;
        //    positionY += self.padding / 2;
        //    var node = self.createPortNode(child, width, childHeight, depth, positionY, solid, rackNode);
        //    if (node) {
        //        result.push(node);
        //    }
        //
        //})
        return result;
    },

    hasChild: function (y, children) {

    },

    /**
     * 隐藏机柜里面设备的端口占用率
     * @param data
     */
    removePortNodeInRack: function (data) {
        var sm = this.sceneManager, dm = this.dataManager, self = this, box = sm.network3d.getDataBox();
        //如果不在当前场景
        if (!sm.isCurrentSceneInstance(data)) {
            return;
        }
        var rackNode = sm.getNodeByDataOrId(data);
        if (!rackNode) {
            return;
        }
        this.makeItDataVisible(data);
        if (data.portNodeArray) {
            data.portNodeArray.forEach(function (node) {
                box.remove(node);
            })
        }
    },
});

var $VisibleManager = function(sceneManager){
    it.VisibleFilter.call(this);
    this.sceneManager = sceneManager;
    this.isDealWithFunction = null;
    this._vmap = {};
};

mono.extend($VisibleManager,it.VisibleFilter,{

    clear: function(){
        this._vmap = {};
        // 需要注意的时，当没有加到viewManager3D中时，怎么clear都不应该fire,这里还需改进!!!
        this.sceneManager._sceneVisibleChangeDispather.fire({
                data:null,
                type:'clear'
        });
    },

    /**
     * 是否需要设置显示/隐藏：
     * @param data
     * @returns {boolean}
     */
    isDealWith : function(data){
        if(this.isDealWithFunction != null){
            return this.isDealWithFunction(data);
        }
        return true;
    },

    getBId : function(data){
        if(!data) {
            return null;
        }
        if (!(data instanceof it.Data)) {
             return null;
        }
        if(!this.isDealWith(data)){
            return null;
        }
        return data.getId();
    },

    setVisible: function(data, visible, fireDispather) {
        var id = this.getBId(data);
        if (id) {
            var oldValue = this._vmap[id];
            if (visible) {
                delete this._vmap[id];
            } else {
                this._vmap[id] = false;
            }
            if (oldValue == undefined) { //如果map中没有的话就直接退出
                return ;
            }
            if (fireDispather === null || fireDispather === undefined) {
                fireDispather = true;
            }
            if (fireDispather && (oldValue != visible)) {
                this.sceneManager._sceneVisibleChangeDispather.fire({
                    data: data,
                    value: visible,
                });
            }
        }
    },

    getDataByNode : function(node){
        if(!node){
            return null;
        }
        return this.sceneManager.getNodeData(node);
    },

    setVisibleByDescendant : function(data,visible,fireDispather){
        if(!data){
            return ;
        }
        if(data instanceof mono.Element){
            data = this.getDataByNode(data);
        }
        if(fireDispather === null || fireDispather === undefined){
            fireDispather = true;
        }
        if(!data || !data.getId()) return;
        this.setVisible(data,visible,false);
        // var node = this.sceneManager.dataNodeMap[data.getId()];
        // var children = node.getChildren();
        var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                // var childData = this.getDataByNode(child);
                // if(childData
                //     && this.getBId(childData) != this.getBId(data)){
                //     this.setVisibleByDescendant(child,visible,false,this);
                // }
                if(this.getBId(child) != this.getBId(data) 
                    || (!this.getBId(child) && !this.getBId(data))){ //当两个Bid都为null时也执行，因为filter(过滤在里面处理的)
                    this.setVisibleByDescendant(child,visible,false,this);
                }
            }
        }
        if(fireDispather){
            this.sceneManager._sceneVisibleChangeDispather.fire({
                data: data,
                type:'descendtant',
                value: visible,
            });
        }
    },

    isVisible: function(node,dataOrId,network){
        var data = null;
        if (dataOrId) {
            if (dataOrId instanceof it.Data) {
                data = dataOrId;
            }else{
                data = this.sceneManager.dataManager.getDataById(dataOrId);
            }
        }
        var id = this.getBId(data);
        if (node && node.getClient(it.SceneManager.CLIENT_EXT_VISIBLE)) { // 如果是扩展的直接就返回不管了
            return true;
        }
        if(this._vmap[id] != false){
            return true;
        }
        return false;
    }

});

it.VisibleManager = $VisibleManager;


/**
 * 用来组建DataFind的基础数据类型
 * @constructor
 */
it.SData = function(inputIndex,inputType,label,placeholder,dataType,readonly){
    it.Base.call(this);
    this._key = "";
//    this._isObject = false; // data.obj[key] 这个obj
    this._isClient = false;
    this._value = "";
    this._operation = "";
    this._clientMap = {};
    this._style = "";
    this.placeholder = placeholder;
    this.label = label;
    this.inputType = inputType;
    this.inputIndex = inputIndex; //在组建BasePanel时，用做div的id
    this._dataType = dataType||'string';
    this._readonly = false;
    if (readonly === true) {
        this._readonly = true;
    }
//    this._rowspan = null;
//    this._colspan = null;
};

mono.extend(it.SData,it.Base,{

    ___accessor :['key','isClient','value','operation','style','dataType'],

    setClient : function(key,value){
        if(key){
            this._clientMap[key] = value;
        }
    },

    getClient : function(key){
       return this._clientMap[key];
    },

    //{key:'u:userId',value:'aaa',operation:'like'}
    toString : function(){
        if(!this._key || !this._value){
            return '';
        }
        var key = this._key;
        if(this._isClient){
            key = 'u:' + key;
        }
        var obj = {key:key};
        var value = '';
        if(this._value){
            value = this._value;
        }
        obj.value = value;
        var operation = '=';
        if(this._operation){
            operation = this._operation;
        }
        obj.operation = operation;
        obj.dataType = this._dataType;
        return obj;
    }

});


/**
 * 条件查询输入panel
 * @constructor
 */

it.BasePanel = function(panelId){
    if(!panelId){
        panelId = 'base-search-panel'
    }
    this.mainPane = $('<div id="'+panelId+'" class="inputPane"> </div>');
    this._ids = [];
    this.inputMap = {}; // 用于存放更加sdata创建的input
    this.className = 'BasePanel';
    this.doClickFunction = null;
    this.doClearFunction = null;
};

mono.extend(it.BasePanel,Object,{

    createRow : function(){
        return $('<div class="row"></div>');
    },

    createCol : function(num,withClass){
        if(!num){
            num = 3;
        }
        if(withClass){
            return  $('<div class="without-padding col-md-'+num+' '+ withClass +'"></div>');
        }else{
            return  $('<div class="without-padding col-md-'+num+'"></div>');
        }
    },

    appendRow : function(row){
        if(row){
            this.mainPane.append(row);
            var height = this.mainPane.height();
            height += 27;
            // this.mainPane.height(height); //如果lable太长的话，存在跨行的情况，所有高度自适应的计算
        }
    },

    addQuick : function(cdata){
        if(!cdata) return;
        if (this.className && cdata.inputIndex) {
            cdata.inputIndex = this.className + '_' + cdata.inputIndex;
        };
        var id = cdata.inputIndex;
        var placeholder = cdata.placeholder;
        var row = this.createRow();
        var col = this.createCol(12);
        var input = $('<input type="text" class="input-min contral-width" id="'+id+'" placeholder="'+placeholder+'">');
        var style = cdata.getStyle()||"";
        if(style){
            input.attr('style',style);
        }
        var self = this;
        input.keypress(function(event){
            if(event.keyCode === 13){
                self.doClick();
            }
        });
        col.append(input);
        this.inputMap[id] = input;
        row.append(col);
        this.appendRow(row);
        this._ids.push(cdata);
    },

    validateDatePick : function(){
        $('.datetime-picker').datetimepicker({
            language:  'zh-CN',
            format: 'yyyy-mm-dd',
            autoclose: true,
            todayBtn: true,
            startView: 2,
            minView: 2
        });
    },


    createInput : function(data){
        if(!data) return;
        var id = data.inputIndex;
        var input = null;
        if(data.inputType && data.inputType.toLowerCase() == 'date'){
            input = $('<input id="'+id+'" class="input-min contral-width datetime-picker">');
//            this.validateDatePick(); //重复调用,不知datepicker自身是不是单例的,不对，需要add到body上后调用才有效
            input.datetimepicker({  //这样不就行了么，需测试，2016-09-21
                language:  'zh-CN',
                format: 'yyyy-mm-dd',
                autoclose: true,
                todayBtn: true,
                startView: 2,
                minView: 2
            });
        }else{
             input = $('<input id="'+id+'" class="input-min contral-width">');
        }
        var style = data.getStyle()||"";
        if(style){
            input.attr('style',style);
        }
        if (data._readonly) {
            input.attr('readonly', 'readonly');
        }
        // this.inputMap[id] = input;
        return input;
    },

    /**
     * 创建行，如果同时传入了两个cdata，就表示这两行合并成一行
     * @param cdata
     * @param cdata2
     */
    addRow : function(cdata,cdata2){
        if(!cdata && !cdata2) return;
        if (this.className) {
            if (cdata && cdata.inputIndex) {
                cdata.inputIndex = this.className + '_' + cdata.inputIndex;
            }
            if (cdata2 && cdata2.inputIndex) {
                cdata2.inputIndex = this.className + '_' + cdata2.inputIndex;
            }
        }
        var row = this.createRow();
        if(cdata && cdata2){//表示cdata和cdata2都不为空
            var id1 = cdata.inputIndex;
            var label1 = cdata.label;
            var labelCol1 = this.createCol(3);
            var h_label = $('<label for="'+id1+'" class="inputpane-label label-min">'+label1+'</label>');
            labelCol1.append(h_label);
            row.append(labelCol1);
            var txtCol1 = this.createCol(4);
            var input1 = this.createInput(cdata);
            this.inputMap[cdata.inputIndex] = input1;
            txtCol1.append(input1);
            row.append(txtCol1);
            input1.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            this._ids.push(cdata);
            var id2 = cdata2.inputIndex;
            var label2 = cdata2.label;
            var labelCol2 = this.createCol(1,'text-center');
            var h_label2 = $('<label for="'+id2+'" class="inputpane-label label-min">'+label2+'</label>');
            labelCol2.append(h_label2);
            row.append(labelCol2);
            var txtCol2 = this.createCol(4);
            var input2 = this.createInput(cdata2);
            this.inputMap[cdata2.inputIndex] = input2;
            txtCol2.append(input2);
            row.append(txtCol2);
            input2.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            this.appendRow(row);
            this._ids.push(cdata2);
        }else{
            if(!cdata && cdata2) {
                cdata = cdata2;
            }
            var id = cdata.inputIndex;
            var label = cdata.label;
            var labelCol = this.createCol(3);
            var txtCol = this.createCol(9);
            var h_label = $('<label for="'+id+'" class="inputpane-label label-min">'+label+'</label>');
            labelCol.append(h_label);
            row.append(labelCol);
//        var input = $('<input id="'+id+'" class="input-min contral-width">');
            var input = this.createInput(cdata);
            this.inputMap[cdata.inputIndex] = input;
            var self = this;
            input.keypress(function(event){
                if(event.keyCode === 13){
                    self.doClick();
                }
            });
            txtCol.append(input);
            row.append(txtCol);
            this.appendRow(row);
            this._ids.push(cdata);
        }
    },

    /**
     * 添加固定的查询条件，如：想查询type勇为“Rack”的，但是不想在搜索框中体现处理
     * @param cdata
     */
    addConstantCondition : function(cdata){
        if(!cdata){
            this._ids.push(cdata);
        }
    },

    addButtonRow : function(){
        var row = this.createRow();
        var col = this.createCol(12);
        var btnOk = $('<span id="btn_search_it" class="base-panel-search-btn" type="submit" title="搜 索">搜 索</span>');
        var btnClear = $('<span id="btn_cancel_search_it" class="base-panel-search-btn" type="cancel" title="清 除">清 除</span>');
        col.append(btnClear);
        col.append(btnOk);
        var self = this;
        btnOk.click(function(){
            self.doClick();
        });
        btnClear.click(function(){
            self.doClear();
        });
        row.append(col);
        this.appendRow(row);
    },

    /**
     * 通过obj创建it.SData
     */
    createSDataByObj: function(data) {
        if (!data) {
            return null;
        }
        var inputIndex = data.inputIndex;
        var inputType = data.inputType;
        var label = data.label;
        var placeholder = data.placeholder;
        var dataType = data.dataType;
        var key = data.key;
        if (!key) {
            return null;
        }
        var sdata = new it.SData(inputIndex, inputType, label, placeholder, dataType);
        sdata.setKey(key);
        sdata.setOperation(data.operation);
        if (data.source) {
            if (data.source instanceof Array) {
                sdata.setClient('options',data.source);
            }else if (this[data.source] && typeof(this[data.source]) == 'function') {
                var options = this[data.source]();
                 sdata.setClient('options',options);
            }
        }
        if (data.style) {
            sdata.setStyle(data.style);
        }
        return sdata;
    },

    getContentPane : function(){
        return this.mainPane;
    },


    getDataValue : function(sdata){
        if(sdata && sdata.inputIndex){
            var id = sdata.inputIndex;
            var inputType = sdata.inputType;
//            if(inputType && inputType.toLowerCase().indexOf('input') < 0){
//                if(inputType.toLowerCase().indexOf('select') >= 0){
//
//                }else if(inputType.toLowerCase().indexOf('checkbox') >= 0){
//
//                }
//            }else{
                var value = $('#'+id).val();
                sdata.setValue(value);
//            }
            if(sdata.toString()){
                return sdata.toString();
            }
        }
        return '';
    },

    getInputValues : function(){
        if(!this._ids) return;
        var contents = [];
        for(var i = 0 ; i < this._ids.length ; i++){
            var data = this._ids[i];
            var obj =  this.getDataValue(data);
            if(obj){
                contents.push(obj);
            }
        }
        return contents;
    },

    getInputHtmlById : function(sid){
        return this.inputMap[this.className + '_' + sid];
    },

    doClick : function(){
        var values = this.getInputValues();
        if(this.doClickFunction){
            this.doClickFunction(values);
        }
    },

    /**
     * 扩展，有可能存在特殊的情况
     */
    clearInputByData : function(id,data){

    },

    clearInput : function(){
        if(!this._ids) return;
        for(var i = 0 ; i < this._ids.length ; i++){
            var data = this._ids[i];
            if(data && data.inputIndex){
                var id = data.inputIndex;
                this.clearInputByData(id,data);
                if(!data || !data.inputType || data.inputType.toLowerCase().indexOf('input') >=0 ){
                    $('#'+id).val('');
                }else{
                    $('#'+id).val('');
                }
            }
        }
    },

    doClear : function(){
        this.clearInput();
        if(this.doClearFunction){
            this.doClearFunction();
        }
    }

});

it.ITSearchPanel = function(){
    it.BasePanel.call(this);
    this.init();
};

mono.extend(it.ITSearchPanel,it.BasePanel,{

    init:function(){
        var sdata = new it.SData('it_key_text',null,null,'请输入编号'); //inputIndex,inputType,label,placeholder
        sdata.setKey('id');
        sdata.setStyle('background: url("./css/images/insidesearch.svg") no-repeat scroll right center;background-position-x: 98%;');
        this.addQuick(sdata);

        sdata = new it.SData('txt_location','select','位置');
        sdata.setKey('location');
        sdata.setIsClient(true);
        var options = ['','上海数据中心','生产楼','一楼'];
        sdata.setClient('options',options);
        this.addRow(sdata);

        sdata = new it.SData('txt_type','select','设备类型');
        sdata.setKey('userId');
        sdata.setIsClient(false);
        var options = ['','机柜1','思科设备1','华为交换机'];
        sdata.setClient('options',options);
        this.addRow(sdata);

        sdata = new it.SData('txt_model','input','型号');
        sdata.setKey('model');
        sdata.setIsClient(true);
        this.addRow(sdata);

        sdata = new it.SData('txt_manu','input','厂家');
        sdata.setKey('userId');
        sdata.setIsClient(true);
        this.addRow(sdata);

        sdata = new it.SData('txt_Type','input','安装日期');
        sdata.setKey('userId');
        sdata.setIsClient(true);
        this.addRow(sdata);

//        sdata = new it.SData('test_id001','input','userId');
//        sdata.setKey('userId');
//        sdata.setIsClient(true);
//        sdata.setOperation('like');
//        this.addRow(sdata);
//        sdata = new it.SData('test_id002','select','制造商');
//        sdata.setKey('制造商');
//        sdata.setIsClient(true);
//        sdata.setOperation('like');
//        var options = ['','A','B','C'];
//        sdata.setClient('options',options);

        this.addRow(sdata);
        this.addButtonRow();
    },

    /***
     * 创建特别的样式，类似select下拉框
     * @param data
     * @returns {*}
     */
    createInput : function(data){
        if (data && data.inputType) {
            var inputType = data.inputType;
            var inputId = data.inputIndex;
            if (inputType.toLowerCase().indexOf('select') >= 0) {
                var select = $('<select id="' + inputId + '" class="input-min contral-width"></select>');
                var options = data.getClient('options');
                if (options && options.length > 0) {
                    for (var i = 0; i < options.length; i++) {
                        var value = options[i];
                        var option = $('<option value="' + value + '" class="input-min">'+value+'</option>');
                        select.append(option);
                    }
                }
                this.inputMap[inputId] = select;
                return select;
            }
        }
        return this.constructor.superClass.createInput(data);
    }
});

it.SpaceSearchPanel = function(){
    it.BasePanel.call(this);
    this.className = 'SpaceSearchPanel';
    this.init();
};

mono.extend(it.SpaceSearchPanel,it.BasePanel,{

    init:function(){
        var sdata = new it.SData('U_ID','input','U数');
        sdata.setKey('dyna_user_data_maxSerSpace');
        sdata.setIsClient(true);
        sdata.setOperation('>=');
        sdata.setDataType('number');
        this.addRow(sdata);
        this.addButtonRow();
    },

    getUNumber : function(){
        return $('#' + this.className + '_U_ID').val();
    }

});
/*globals jQuery, define, exports, require, window, document, postMessage */
(function (factory) {
//	"use strict";
	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(typeof exports === 'object') {
		factory(require('jquery'));
	}
	else {
		factory(jQuery);
	}
}(function ($, undefined) {
//	"use strict";
/*!
 * jsTree 3.1.1
 * http://jstree.com/
 *
 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 */
/*!
 * if using jslint please allow for the jQuery global and use following options:
 * jslint: browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
 */

	// prevent another load? maybe there is a better way?
	if($.jstree) {
		return;
	}

	/**
	 * ### jsTree core functionality
	 */

	// internal variables
	var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		ccp_inst = false,
		themes_loaded = [],
		src = $('script:last').attr('src'),
		document = window.document, // local variable is always faster to access then a global
		_node = document.createElement('LI'), _temp1, _temp2;

	_node.setAttribute('role', 'treeitem');
	_temp1 = document.createElement('I');
	_temp1.className = 'jstree-icon jstree-ocl';
	_temp1.setAttribute('role', 'presentation');
	_node.appendChild(_temp1);
	_temp1 = document.createElement('A');
	_temp1.className = 'jstree-anchor';
	_temp1.setAttribute('href','#');
	_temp1.setAttribute('tabindex','-1');
	_temp2 = document.createElement('I');
	_temp2.className = 'jstree-icon jstree-themeicon';
	_temp2.setAttribute('role', 'presentation');
	_temp1.appendChild(_temp2);
	_node.appendChild(_temp1);
	_temp1 = _temp2 = null;


	/**
	 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
	 * @name $.jstree
	 */
	$.jstree = {
		/**
		 * specifies the jstree version in use
		 * @name $.jstree.version
		 */
		version : '3.1.1',
		/**
		 * holds all the default options used when creating new instances
		 * @name $.jstree.defaults
		 */
		defaults : {
			/**
			 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
			 * @name $.jstree.defaults.plugins
			 */
			plugins : []
		},
		/**
		 * stores all loaded jstree plugins (used internally)
		 * @name $.jstree.plugins
		 */
		plugins : {},
		path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
		idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g
	};
	/**
	 * creates a jstree instance
	 * @name $.jstree.create(el [, options])
	 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
	 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
	 * @return {jsTree} the new instance
	 */
	$.jstree.create = function (el, options) {
		var tmp = new $.jstree.core(++instance_counter),
			opt = options;
		options = $.extend(true, {}, $.jstree.defaults, options);
		if(opt && opt.plugins) {
			options.plugins = opt.plugins;
		}
		$.each(options.plugins, function (i, k) {
			if(i !== 'core') {
				tmp = tmp.plugin(k, options[k]);
			}
		});
		$(el).data('jstree', tmp);
		tmp.init(el, options);
		return tmp;
	};
	/**
	 * remove all traces of jstree from the DOM and destroy all instances
	 * @name $.jstree.destroy()
	 */
	$.jstree.destroy = function () {
		$('.jstree:jstree').jstree('destroy');
		$(document).off('.jstree');
	};
	/**
	 * the jstree class constructor, used only internally
	 * @private
	 * @name $.jstree.core(id)
	 * @param {Number} id this instance's index
	 */
	$.jstree.core = function (id) {
		this._id = id;
		this._cnt = 0;
		this._wrk = null;
		this._data = {
			core : {
				themes : {
					name : false,
					dots : false,
					icons : false
				},
				selected : [],
				last_error : {},
				working : false,
				worker_queue : [],
				focused : null
			}
		};
	};
	/**
	 * get a reference to an existing instance
	 *
	 * __Examples__
	 *
	 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
	 *	// all of there will return the same instance
	 *	$.jstree.reference('tree');
	 *	$.jstree.reference('#tree');
	 *	$.jstree.reference($('#tree'));
	 *	$.jstree.reference(document.getElementByID('tree'));
	 *	$.jstree.reference('branch');
	 *	$.jstree.reference('#branch');
	 *	$.jstree.reference($('#branch'));
	 *	$.jstree.reference(document.getElementByID('branch'));
	 *
	 * @name $.jstree.reference(needle)
	 * @param {DOMElement|jQuery|String} needle
	 * @return {jsTree|null} the instance or `null` if not found
	 */
	$.jstree.reference = function (needle) {
		var tmp = null,
			obj = null;
		if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }

		if(!obj || !obj.length) {
			try { obj = $(needle); } catch (ignore) { }
		}
		if(!obj || !obj.length) {
			try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
		}
		if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
			tmp = obj;
		}
		else {
			$('.jstree').each(function () {
				var inst = $(this).data('jstree');
				if(inst && inst._model.data[needle]) {
					tmp = inst;
					return false;
				}
			});
		}
		return tmp;
	};
	/**
	 * Create an instance, get an instance or invoke a command on a instance.
	 *
	 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
	 *
	 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
	 *
	 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
	 *
	 * In any other case - nothing is returned and chaining is not broken.
	 *
	 * __Examples__
	 *
	 *	$('#tree1').jstree(); // creates an instance
	 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
	 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
	 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
	 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
	 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
	 *
	 * @name $().jstree([arg])
	 * @param {String|Object} arg
	 * @return {Mixed}
	 */
	$.fn.jstree = function (arg) {
		// check for string argument
		var is_method	= (typeof arg === 'string'),
			args		= Array.prototype.slice.call(arguments, 1),
			result		= null;
		if(arg === true && !this.length) { return false; }
		this.each(function () {
			// get the instance (if there is one) and method (if it exists)
			var instance = $.jstree.reference(this),
				method = is_method && instance ? instance[arg] : null;
			// if calling a method, and method is available - execute on the instance
			result = is_method && method ?
				method.apply(instance, args) :
				null;
			// if there is no instance and no method is being called - create one
			if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
				$.jstree.create(this, arg);
			}
			// if there is an instance and no method is called - return the instance
			if( (instance && !is_method) || arg === true ) {
				result = instance || false;
			}
			// if there was a method call which returned a result - break and return the value
			if(result !== null && result !== undefined) {
				return false;
			}
		});
		// if there was a method call with a valid return value - return that, otherwise continue the chain
		return result !== null && result !== undefined ?
			result : this;
	};
	/**
	 * used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 * @name $(':jstree')
	 * @return {jQuery}
	 */
	$.expr[':'].jstree = $.expr.createPseudo(function(search) {
		return function(a) {
			return $(a).hasClass('jstree') &&
				$(a).data('jstree') !== undefined;
		};
	});

	/**
	 * stores all defaults for the core
	 * @name $.jstree.defaults.core
	 */
	$.jstree.defaults.core = {
		/**
		 * data configuration
		 *
		 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
		 *
		 * You can also pass in a HTML string or a JSON array here.
		 *
		 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
		 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
		 *
		 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
		 *
		 * __Examples__
		 *
		 *	// AJAX
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : {
		 *				'url' : '/get/children/',
		 *				'data' : function (node) {
		 *					return { 'id' : node.id };
		 *				}
		 *			}
		 *		});
		 *
		 *	// direct data
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : [
		 *				'Simple root node',
		 *				{
		 *					'id' : 'node_2',
		 *					'text' : 'Root node with options',
		 *					'state' : { 'opened' : true, 'selected' : true },
		 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
		 *				}
		 *			]
		 *		});
		 *
		 *	// function
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : function (obj, callback) {
		 *				callback.call(this, ['Root 1', 'Root 2']);
		 *			}
		 *		});
		 *
		 * @name $.jstree.defaults.core.data
		 */
		data			: false,
		/**
		 * configure the various strings used throughout the tree
		 *
		 * You can use an object where the key is the string you need to replace and the value is your replacement.
		 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
		 * If left as `false` no replacement is made.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'strings' : {
		 *				'Loading ...' : 'Please wait ...'
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.strings
		 */
		strings			: false,
		/**
		 * determines what happens when a user tries to modify the structure of the tree
		 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
		 * You can set this to `true` to allow all interactions or use a function to have better control.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
		 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
		 *				// in case of 'rename_node' node_position is filled with the new node name
		 *				return operation === 'rename_node' ? true : false;
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.check_callback
		 */
		check_callback	: false,
		/**
		 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
		 * @name $.jstree.defaults.core.error
		 */
		error			: $.noop,
		/**
		 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
		 * @name $.jstree.defaults.core.animation
		 */
		animation		: 200,
		/**
		 * a boolean indicating if multiple nodes can be selected
		 * @name $.jstree.defaults.core.multiple
		 */
		multiple		: true,
		/**
		 * theme configuration object
		 * @name $.jstree.defaults.core.themes
		 */
		themes			: {
			/**
			 * the name of the theme to use (if left as `false` the default theme is used)
			 * @name $.jstree.defaults.core.themes.name
			 */
			name			: false,
			/**
			 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
			 * @name $.jstree.defaults.core.themes.url
			 */
			url				: false,
			/**
			 * the location of all jstree themes - only used if `url` is set to `true`
			 * @name $.jstree.defaults.core.themes.dir
			 */
			dir				: false,
			/**
			 * a boolean indicating if connecting dots are shown
			 * @name $.jstree.defaults.core.themes.dots
			 */
			dots			: true,
			/**
			 * a boolean indicating if node icons are shown
			 * @name $.jstree.defaults.core.themes.icons
			 */
			icons			: true,
			/**
			 * a boolean indicating if the tree background is striped
			 * @name $.jstree.defaults.core.themes.stripes
			 */
			stripes			: false,
			/**
			 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
			 * @name $.jstree.defaults.core.themes.variant
			 */
			variant			: false,
			/**
			 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
			 * @name $.jstree.defaults.core.themes.responsive
			 */
			responsive		: false
		},
		/**
		 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
		 * @name $.jstree.defaults.core.expand_selected_onload
		 */
		expand_selected_onload : true,
		/**
		 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
		 * @name $.jstree.defaults.core.worker
		 */
		worker : true,
		/**
		 * Force node text to plain text (and escape HTML). Defaults to `false`
		 * @name $.jstree.defaults.core.force_text
		 */
		force_text : false,
		/**
		 * Should the node should be toggled if the text is double clicked . Defaults to `true`
		 * @name $.jstree.defaults.core.dblclick_toggle
		 */
		dblclick_toggle : true
	};
	$.jstree.core.prototype = {
		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name plugin(deco [, opts])
		 * @param  {String} deco the plugin to decorate with
		 * @param  {Object} opts options for the plugin
		 * @return {jsTree}
		 */
		plugin : function (deco, opts) {
			var Child = $.jstree.plugins[deco];
			if(Child) {
				this._data[deco] = {};
				Child.prototype = this;
				return new Child(opts, this);
			}
			return this;
		},
		/**
		 * initialize the instance. Used internally.
		 * @private
		 * @name init(el, optons)
		 * @param {DOMElement|jQuery|String} el the element we are transforming
		 * @param {Object} options options for this instance
		 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
		 */
		init : function (el, options) {
			this._model = {
				data : {
					'#' : {
						id : '#',
						parent : null,
						parents : [],
						children : [],
						children_d : [],
						state : { loaded : false }
					}
				},
				changed : [],
				force_full_redraw : false,
				redraw_timeout : false,
				default_state : {
					loaded : true,
					opened : false,
					selected : false,
					disabled : false
				}
			};

			this.element = $(el).addClass('jstree jstree-' + this._id);
			this.settings = options;

			this._data.core.ready = false;
			this._data.core.loaded = false;
			this._data.core.rtl = (this.element.css("direction") === "rtl");
			this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
			this.element.attr('role','tree');
			if(this.settings.core.multiple) {
				this.element.attr('aria-multiselectable', true);
			}
			if(!this.element.attr('tabindex')) {
				this.element.attr('tabindex','0');
			}

			this.bind();
			/**
			 * triggered after all events are bound
			 * @event
			 * @name init.jstree
			 */
			this.trigger("init");

			this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
			this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function() {
					return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
			this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
			this.element.attr('aria-activedescendant','j' + this._id + '_loading');
			this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
			/**
			 * triggered after the loading text is shown and before loading starts
			 * @event
			 * @name loading.jstree
			 */
			this.trigger("loading");
			this.load_node('#');
		},
		/**
		 * destroy an instance
		 * @name destroy()
		 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
		 */
		destroy : function (keep_html) {
			if(this._wrk) {
				try {
					window.URL.revokeObjectURL(this._wrk);
					this._wrk = null;
				}
				catch (ignore) { }
			}
			if(!keep_html) { this.element.empty(); }
			this.teardown();
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name teardown()
		 */
		teardown : function () {
			this.unbind();
			this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			this.element = null;
		},
		/**
		 * bind all events. Used internally.
		 * @private
		 * @name bind()
		 */
		bind : function () {
			var word = '',
				tout = null,
				was_click = 0;
			this.element
				.on("dblclick.jstree", function () {
						if(document.selection && document.selection.empty) {
							document.selection.empty();
						}
						else {
							if(window.getSelection) {
								var sel = window.getSelection();
								try {
									sel.removeAllRanges();
									sel.collapse();
								} catch (ignore) { }
							}
						}
					})
				.on("mousedown.jstree", $.proxy(function (e) {
						if(e.target === this.element[0]) {
							e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
							was_click = +(new Date()); // ie does not allow to prevent losing focus
						}
					}, this))
				.on("mousedown.jstree", ".jstree-ocl", function (e) {
						e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
					})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
						this.toggle_node(e.target);
					}, this))
				.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this.settings.core.dblclick_toggle) {
							this.toggle_node(e.target);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						e.preventDefault();
						if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
						this.activate_node(e.currentTarget, e);
					}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						if(e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
						var o = null;
						if(this._data.core.rtl) {
							if(e.which === 37) { e.which = 39; }
							else if(e.which === 39) { e.which = 37; }
						}
						switch(e.which) {
							case 32: // aria defines space only with Ctrl
								if(e.ctrlKey) {
									e.type = "click";
									$(e.currentTarget).trigger(e);
								}
								break;
							case 13: // enter
								e.type = "click";
								$(e.currentTarget).trigger(e);
								break;
							case 37: // right
								e.preventDefault();
								if(this.is_open(e.currentTarget)) {
									this.close_node(e.currentTarget);
								}
								else {
									o = this.get_parent(e.currentTarget);
									if(o && o.id !== '#') { this.get_node(o, true).children('.jstree-anchor').focus(); }
								}
								break;
							case 38: // up
								e.preventDefault();
								o = this.get_prev_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 39: // left
								e.preventDefault();
								if(this.is_closed(e.currentTarget)) {
									this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
								}
								else if (this.is_open(e.currentTarget)) {
									o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
									if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
								}
								break;
							case 40: // down
								e.preventDefault();
								o = this.get_next_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 106: // aria defines * on numpad as open_all - not very common
								this.open_all();
								break;
							case 36: // home
								e.preventDefault();
								o = this._firstChild(this.get_container_ul()[0]);
								if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
								break;
							case 35: // end
								e.preventDefault();
								this.element.find('.jstree-anchor').filter(':visible').last().focus();
								break;
							/*
							// delete
							case 46:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									o = this.is_selected(o) ? this.get_selected() : o;
									this.delete_node(o);
								}
								break;
							// f2
							case 113:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									// this.edit(o);
								}
								break;
							default:
								// console.log(e.which);
								break;
							*/
						}
					}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
						if(data.status) {
							if(data.node.id === '#' && !this._data.core.loaded) {
								this._data.core.loaded = true;
								if(this._firstChild(this.get_container_ul()[0])) {
									this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
								}
								/**
								 * triggered after the root node is loaded for the first time
								 * @event
								 * @name loaded.jstree
								 */
								this.trigger("loaded");
							}
							if(!this._data.core.ready) {
								setTimeout($.proxy(function() {
									if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
										this._data.core.ready = true;
										if(this._data.core.selected.length) {
											if(this.settings.core.expand_selected_onload) {
												var tmp = [], i, j;
												for(i = 0, j = this._data.core.selected.length; i < j; i++) {
													tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
												}
												tmp = $.vakata.array_unique(tmp);
												for(i = 0, j = tmp.length; i < j; i++) {
													this.open_node(tmp[i], false, 0);
												}
											}
											this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
										}
										/**
										 * triggered after all nodes are finished loading
										 * @event
										 * @name ready.jstree
										 */
										this.trigger("ready");
									}
								}, this), 0);
							}
						}
					}, this))
				// quick searching when the tree is focused
				.on('keypress.jstree', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						if(tout) { clearTimeout(tout); }
						tout = setTimeout(function () {
							word = '';
						}, 500);

						var chr = String.fromCharCode(e.which).toLowerCase(),
							col = this.element.find('.jstree-anchor').filter(':visible'),
							ind = col.index(document.activeElement) || 0,
							end = false;
						word += chr;

						// match for whole word from current node down (including the current node)
						if(word.length > 1) {
							col.slice(ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// match for whole word from the beginning of the tree
							col.slice(0, ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
						// list nodes that start with that letter (only if word consists of a single char)
						if(new RegExp('^' + chr + '+$').test(word)) {
							// search for the next node starting with that letter
							col.slice(ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// search from the beginning
							col.slice(0, ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
					}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
						var s = this.settings.core.themes;
						this._data.core.themes.dots			= s.dots;
						this._data.core.themes.stripes		= s.stripes;
						this._data.core.themes.icons		= s.icons;
						this.set_theme(s.name || "default", s.url);
						this.set_theme_variant(s.variant);
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
						this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
					}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
						this._data.core.focused = null;
						$(e.currentTarget).filter('.jstree-hovered').mouseleave();
						this.element.attr('tabindex', '0');
					}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
						var tmp = this.get_node(e.currentTarget);
						if(tmp && tmp.id) {
							this._data.core.focused = tmp.id;
						}
						this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
						$(e.currentTarget).mouseenter();
						this.element.attr('tabindex', '-1');
					}, this))
				.on('focus.jstree', $.proxy(function () {
						if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
							was_click = 0;
							var act = this.get_node(this.element.attr('aria-activedescendant'), true);
							if(act) {
								act.find('> .jstree-anchor').focus();
							}
						}
					}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.hover_node(e.currentTarget);
					}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name unbind()
		 */
		unbind : function () {
			this.element.off('.jstree');
			$(document).off('.jstree-' + this._id);
		},
		/**
		 * trigger an event. Used internally.
		 * @private
		 * @name trigger(ev [, data])
		 * @param  {String} ev the name of the event to trigger
		 * @param  {Object} data additional data to pass with the event
		 */
		trigger : function (ev, data) {
			if(!data) {
				data = {};
			}
			data.instance = this;
			this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
		},
		/**
		 * returns the jQuery extended instance container
		 * @name get_container()
		 * @return {jQuery}
		 */
		get_container : function () {
			return this.element;
		},
		/**
		 * returns the jQuery extended main UL node inside the instance container. Used internally.
		 * @private
		 * @name get_container_ul()
		 * @return {jQuery}
		 */
		get_container_ul : function () {
			return this.element.children(".jstree-children").first();
		},
		/**
		 * gets string replacements (localization). Used internally.
		 * @private
		 * @name get_string(key)
		 * @param  {String} key
		 * @return {String}
		 */
		get_string : function (key) {
			var a = this.settings.core.strings;
			if($.isFunction(a)) { return a.call(this, key); }
			if(a && a[key]) { return a[key]; }
			return key;
		},
		/**
		 * gets the first child of a DOM node. Used internally.
		 * @private
		 * @name _firstChild(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_firstChild : function (dom) {
			dom = dom ? dom.firstChild : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the next sibling of a DOM node. Used internally.
		 * @private
		 * @name _nextSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_nextSibling : function (dom) {
			dom = dom ? dom.nextSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the previous sibling of a DOM node. Used internally.
		 * @private
		 * @name _previousSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_previousSibling : function (dom) {
			dom = dom ? dom.previousSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.previousSibling;
			}
			return dom;
		},
		/**
		 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
		 * @name get_node(obj [, as_dom])
		 * @param  {mixed} obj
		 * @param  {Boolean} as_dom
		 * @return {Object|jQuery}
		 */
		get_node : function (obj, as_dom) {
			if(obj && obj.id) {
				obj = obj.id;
			}
			var dom;
			try {
				if(this._model.data[obj]) {
					obj = this._model.data[obj];
				}
				else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
					obj = this._model.data[obj.replace(/^#/, '')];
				}
				else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
					obj = this._model.data['#'];
				}
				else {
					return false;
				}

				if(as_dom) {
					obj = obj.id === '#' ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
				}
				return obj;
			} catch (ex) { return false; }
		},
		/**
		 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
		 * @name get_path(obj [, glue, ids])
		 * @param  {mixed} obj the node
		 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
		 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
		 * @return {mixed}
		 */
		get_path : function (obj, glue, ids) {
			obj = obj.parents ? obj : this.get_node(obj);
			if(!obj || obj.id === '#' || !obj.parents) {
				return false;
			}
			var i, j, p = [];
			p.push(ids ? obj.id : obj.text);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
			}
			p = p.reverse().slice(1);
			return glue ? p.join(glue) : p;
		},
		/**
		 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_next_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_next_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this._firstChild(this.get_container_ul()[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			if(obj.hasClass("jstree-open")) {
				tmp = this._firstChild(obj.children('.jstree-children')[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				if(tmp !== null) {
					return $(tmp);
				}
			}
			tmp = obj[0];
			do {
				tmp = this._nextSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				return $(tmp);
			}
			return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
		},
		/**
		 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_prev_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_prev_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this.get_container_ul()[0].lastChild;
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._previousSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			tmp = obj[0];
			do {
				tmp = this._previousSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				obj = $(tmp);
				while(obj.hasClass("jstree-open")) {
					obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
				}
				return obj;
			}
			tmp = obj[0].parentNode.parentNode;
			return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
		},
		/**
		 * get the parent ID of a node
		 * @name get_parent(obj)
		 * @param  {mixed} obj
		 * @return {String}
		 */
		get_parent : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.parent;
		},
		/**
		 * get a jQuery collection of all the children of a node (node must be rendered)
		 * @name get_children_dom(obj)
		 * @param  {mixed} obj
		 * @return {jQuery}
		 */
		get_children_dom : function (obj) {
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				return this.get_container_ul().children(".jstree-node");
			}
			if(!obj || !obj.length) {
				return false;
			}
			return obj.children(".jstree-children").children(".jstree-node");
		},
		/**
		 * checks if a node has children
		 * @name is_parent(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_parent : function (obj) {
			obj = this.get_node(obj);
			return obj && (obj.state.loaded === false || obj.children.length > 0);
		},
		/**
		 * checks if a node is loaded (its children are available)
		 * @name is_loaded(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loaded : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.loaded;
		},
		/**
		 * check if a node is currently loading (fetching children)
		 * @name is_loading(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loading : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.loading;
		},
		/**
		 * check if a node is opened
		 * @name is_open(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_open : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.opened;
		},
		/**
		 * check if a node is in a closed state
		 * @name is_closed(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_closed : function (obj) {
			obj = this.get_node(obj);
			return obj && this.is_parent(obj) && !obj.state.opened;
		},
		/**
		 * check if a node has no children
		 * @name is_leaf(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_leaf : function (obj) {
			return !this.is_parent(obj);
		},
		/**
		 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
		 * @name load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
		 * @return {Boolean}
		 * @trigger load_node.jstree
		 */
		load_node : function (obj, callback) {
			var k, l, i, j, c;
			if($.isArray(obj)) {
				this._load_nodes(obj.slice(), callback);
				return true;
			}
			obj = this.get_node(obj);
			if(!obj) {
				if(callback) { callback.call(this, obj, false); }
				return false;
			}
			// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
			if(obj.state.loaded) {
				obj.state.loaded = false;
				for(k = 0, l = obj.children_d.length; k < l; k++) {
					for(i = 0, j = obj.parents.length; i < j; i++) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove_item(this._model.data[obj.parents[i]].children_d, obj.children_d[k]);
					}
					if(this._model.data[obj.children_d[k]].state.selected) {
						c = true;
						this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.children_d[k]);
					}
					delete this._model.data[obj.children_d[k]];
				}
				obj.children = [];
				obj.children_d = [];
				if(c) {
					this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
				}
			}
			obj.state.failed = false;
			obj.state.loading = true;
			this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
			this._load_node(obj, $.proxy(function (status) {
				obj = this._model.data[obj.id];
				obj.state.loading = false;
				obj.state.loaded = status;
				obj.state.failed = !obj.state.loaded;
				var dom = this.get_node(obj, true);
				if(obj.state.loaded && !obj.children.length && dom && dom.length && !dom.hasClass('jstree-leaf')) {
					dom.removeClass('jstree-closed jstree-open').addClass('jstree-leaf');
				}
				dom.removeClass("jstree-loading").attr('aria-busy',false);
				/**
				 * triggered after a node is loaded
				 * @event
				 * @name load_node.jstree
				 * @param {Object} node the node that was loading
				 * @param {Boolean} status was the node loaded successfully
				 */
				this.trigger('load_node', { "node" : obj, "status" : status });
				if(callback) {
					callback.call(this, obj, status);
				}
			}, this));
			return true;
		},
		/**
		 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
		 * @private
		 * @name _load_nodes(nodes [, callback])
		 * @param  {array} nodes
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
		 */
		_load_nodes : function (nodes, callback, is_callback) {
			var r = true,
				c = function () { this._load_nodes(nodes, callback, true); },
				m = this._model.data, i, j, tmp = [];
			for(i = 0, j = nodes.length; i < j; i++) {
				if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || !is_callback)) {
					if(!this.is_loading(nodes[i])) {
						this.load_node(nodes[i], c);
					}
					r = false;
				}
			}
			if(r) {
				for(i = 0, j = nodes.length; i < j; i++) {
					if(m[nodes[i]] && m[nodes[i]].state.loaded) {
						tmp.push(nodes[i]);
					}
				}
				if(callback && !callback.done) {
					callback.call(this, tmp);
					callback.done = true;
				}
			}
		},
		/**
		 * loads all unloaded nodes
		 * @name load_all([obj, callback])
		 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
		 * @param {function} callback a function to be executed once loading all the nodes is complete,
		 * @trigger load_all.jstree
		 */
		load_all : function (obj, callback) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var to_load = [],
				m = this._model.data,
				c = m[obj.id].children_d,
				i, j;
			if(obj.state && !obj.state.loaded) {
				to_load.push(obj.id);
			}
			for(i = 0, j = c.length; i < j; i++) {
				if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
					to_load.push(c[i]);
				}
			}
			if(to_load.length) {
				this._load_nodes(to_load, function () {
					this.load_all(obj, callback);
				});
			}
			else {
				/**
				 * triggered after a load_all call completes
				 * @event
				 * @name load_all.jstree
				 * @param {Object} node the recursively loaded node
				 */
				if(callback) { callback.call(this, obj); }
				this.trigger('load_all', { "node" : obj });
			}
		},
		/**
		 * handles the actual loading of a node. Used only internally.
		 * @private
		 * @name _load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
		 * @return {Boolean}
		 */
		_load_node : function (obj, callback) {
			var s = this.settings.core.data, t;
			// use original HTML
			if(!s) {
				if(obj.id === '#') {
					return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
						callback.call(this, status);
					});
				}
				else {
					return callback.call(this, false);
				}
				// return callback.call(this, obj.id === '#' ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
			}
			if($.isFunction(s)) {
				return s.call(this, obj, $.proxy(function (d) {
					if(d === false) {
						callback.call(this, false);
					}
					this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }) : d, function (status) {
						callback.call(this, status);
					});
					// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
				}, this));
			}
			if(typeof s === 'object') {
				if(s.url) {
					s = $.extend(true, {}, s);
					if($.isFunction(s.url)) {
						s.url = s.url.call(this, obj);
					}
					if($.isFunction(s.data)) {
						s.data = s.data.call(this, obj);
					}
					return $.ajax(s)
						.done($.proxy(function (d,t,x) {
								var type = x.getResponseHeader('Content-Type');
								if((type && type.indexOf('json') !== -1) || typeof d === "object") {
									return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
									//return callback.call(this, this._append_json_data(obj, d));
								}
								if((type && type.indexOf('html') !== -1) || typeof d === "string") {
									return this._append_html_data(obj, $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }), function (status) { callback.call(this, status); });
									// return callback.call(this, this._append_html_data(obj, $(d)));
								}
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								return callback.call(this, false);
							}, this))
						.fail($.proxy(function (f) {
								callback.call(this, false);
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this));
				}
				t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
				if(obj.id === '#') {
					return this._append_json_data(obj, t, function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_json_data(obj, t) : false) );
			}
			if(typeof s === 'string') {
				if(obj.id === '#') {
					return this._append_html_data(obj, $($.parseHTML(s)).filter(function () { return this.nodeType !== 3; }), function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_html_data(obj, $(s)) : false) );
			}
			return callback.call(this, false);
		},
		/**
		 * adds a node to the list of nodes to redraw. Used only internally.
		 * @private
		 * @name _node_changed(obj [, callback])
		 * @param  {mixed} obj
		 */
		_node_changed : function (obj) {
			obj = this.get_node(obj);
			if(obj) {
				this._model.changed.push(obj.id);
			}
		},
		/**
		 * appends HTML content to the tree. Used internally.
		 * @private
		 * @name _append_html_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the HTML string to parse and append
		 * @trigger model.jstree, changed.jstree
		 */
		_append_html_data : function (dom, data, cb) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			var dat = data.is('ul') ? data.children() : data,
				par = dom.id,
				chd = [],
				dpc = [],
				m = this._model.data,
				p = m[par],
				s = this._data.core.selected.length,
				tmp, i, j;
			dat.each($.proxy(function (i, v) {
				tmp = this._parse_model_from_html($(v), par, p.parents.concat());
				if(tmp) {
					chd.push(tmp);
					dpc.push(tmp);
					if(m[tmp].children_d.length) {
						dpc = dpc.concat(m[tmp].children_d);
					}
				}
			}, this));
			p.children = chd;
			p.children_d = dpc;
			for(i = 0, j = p.parents.length; i < j; i++) {
				m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
			}
			/**
			 * triggered when new data is inserted to the tree model
			 * @event
			 * @name model.jstree
			 * @param {Array} nodes an array of node IDs
			 * @param {String} parent the parent ID of the nodes
			 */
			this.trigger('model', { "nodes" : dpc, 'parent' : par });
			if(par !== '#') {
				this._node_changed(par);
				this.redraw();
			}
			else {
				this.get_container_ul().children('.jstree-initial-node').remove();
				this.redraw(true);
			}
			if(this._data.core.selected.length !== s) {
				this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
			}
			cb.call(this, true);
		},
		/**
		 * appends JSON content to the tree. Used internally.
		 * @private
		 * @name _append_json_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the JSON object to parse and append
		 * @param  {Boolean} force_processing internal param - do not set
		 * @trigger model.jstree, changed.jstree
		 */
		_append_json_data : function (dom, data, cb, force_processing) {
			if(this.element === null) { return; }
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			// *%$@!!!
			if(data.d) {
				data = data.d;
				if(typeof data === "string") {
					data = JSON.parse(data);
				}
			}
			if(!$.isArray(data)) { data = [data]; }
			var w = null,
				args = {
					'df'	: this._model.default_state,
					'dat'	: data,
					'par'	: dom.id,
					'm'		: this._model.data,
					't_id'	: this._id,
					't_cnt'	: this._cnt,
					'sel'	: this._data.core.selected
				},
				func = function (data, undefined) {
					if(data.data) { data = data.data; }
					var dat = data.dat,
						par = data.par,
						chd = [],
						dpc = [],
						add = [],
						df = data.df,
						t_id = data.t_id,
						t_cnt = data.t_cnt,
						m = data.m,
						p = m[par],
						sel = data.sel,
						tmp, i, j, rslt,
						parse_flat = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = d.id.toString(),
								i, j, c, e,
								tmp = {
									id			: tid,
									text		: d.text || '',
									icon		: d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: d.children || [],
									children_d	: d.children_d || [],
									data		: d.data,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tid;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							m[tmp.id] = tmp;
							for(i = 0, j = tmp.children.length; i < j; i++) {
								c = parse_flat(m[tmp.children[i]], tmp.id, ps);
								e = m[c];
								tmp.children_d.push(c);
								if(e.children_d.length) {
									tmp.children_d = tmp.children_d.concat(e.children_d);
								}
							}
							delete d.data;
							delete d.children;
							m[tmp.id].original = d;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						},
						parse_nest = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = false, i, j, c, e, tmp;
							do {
								tid = 'j' + t_id + '_' + (++t_cnt);
							} while(m[tid]);

							tmp = {
								id			: false,
								text		: typeof d === 'string' ? d : '',
								icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
								parent		: p,
								parents		: ps,
								children	: [],
								children_d	: [],
								data		: null,
								state		: { },
								li_attr		: { id : false },
								a_attr		: { href : '#' },
								original	: false
							};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.id) { tmp.id = d.id.toString(); }
							if(d && d.text) { tmp.text = d.text; }
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
								tmp.icon = true;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(tmp.li_attr.id && !tmp.id) {
								tmp.id = tmp.li_attr.id.toString();
							}
							if(!tmp.id) {
								tmp.id = tid;
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tmp.id;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children.length) {
								for(i = 0, j = d.children.length; i < j; i++) {
									c = parse_nest(d.children[i], tmp.id, ps);
									e = m[c];
									tmp.children.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								tmp.children_d = tmp.children_d.concat(tmp.children);
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							delete d.data;
							delete d.children;
							tmp.original = d;
							m[tmp.id] = tmp;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						};

					if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
						// Flat JSON support (for easy import from DB):
						// 1) convert to object (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if(!dat[i].children) {
								dat[i].children = [];
							}
							m[dat[i].id.toString()] = dat[i];
						}
						// 2) populate children (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							m[dat[i].parent.toString()].children.push(dat[i].id.toString());
							// populate parent.children_d
							p.children_d.push(dat[i].id.toString());
						}
						// 3) normalize && populate parents and children_d with recursion
						for(i = 0, j = p.children.length; i < j; i++) {
							tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
							dpc.push(tmp);
							if(m[tmp].children_d.length) {
								dpc = dpc.concat(m[tmp].children_d);
							}
						}
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					else {
						for(i = 0, j = dat.length; i < j; i++) {
							tmp = parse_nest(dat[i], par, p.parents.concat());
							if(tmp) {
								chd.push(tmp);
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
						}
						p.children = chd;
						p.children_d = dpc;
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					if(typeof window === 'undefined' || typeof window.document === 'undefined') {
						postMessage(rslt);
					}
					else {
						return rslt;
					}
				},
				rslt = function (rslt, worker) {
					if(this.element === null) { return; }
					this._cnt = rslt.cnt;
					this._model.data = rslt.mod; // breaks the reference in load_node - careful

					if(worker) {
						var i, j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice(), m = this._model.data;
						// if selection was changed while calculating in worker
						if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
							// deselect nodes that are no longer selected
							for(i = 0, j = r.length; i < j; i++) {
								if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
									m[r[i]].state.selected = false;
								}
							}
							// select nodes that were selected in the mean time
							for(i = 0, j = s.length; i < j; i++) {
								if($.inArray(s[i], r) === -1) {
									m[s[i]].state.selected = true;
								}
							}
						}
					}
					if(rslt.add.length) {
						this._data.core.selected = this._data.core.selected.concat(rslt.add);
					}

					this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });

					if(rslt.par !== '#') {
						this._node_changed(rslt.par);
						this.redraw();
					}
					else {
						// this.get_container_ul().children('.jstree-initial-node').remove();
						this.redraw(true);
					}
					if(rslt.add.length) {
						this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
					}
					cb.call(this, true);
				};
			if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
				try {
					if(this._wrk === null) {
						this._wrk = window.URL.createObjectURL(
							new window.Blob(
								['self.onmessage = ' + func.toString()],
								{type:"text/javascript"}
							)
						);
					}
					if(!this._data.core.working || force_processing) {
						this._data.core.working = true;
						w = new window.Worker(this._wrk);
						w.onmessage = $.proxy(function (e) {
							rslt.call(this, e.data, true);
							try { w.terminate(); w = null; } catch(ignore) { }
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}, this);
						if(!args.par) {
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}
						else {
							w.postMessage(args);
						}
					}
					else {
						this._data.core.worker_queue.push([dom, data, cb, true]);
					}
				}
				catch(e) {
					rslt.call(this, func(args), false);
					if(this._data.core.worker_queue.length) {
						this._append_json_data.apply(this, this._data.core.worker_queue.shift());
					}
					else {
						this._data.core.working = false;
					}
				}
			}
			else {
				rslt.call(this, func(args), false);
			}
		},
		/**
		 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_html(d [, p, ps])
		 * @param  {jQuery} d the jQuery object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_html : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = [].concat(ps); }
			if(p) { ps.unshift(p); }
			var c, e, m = this._model.data,
				data = {
					id			: false,
					text		: false,
					icon		: true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				}, i, tmp, tid;
			for(i in this._model.default_state) {
				if(this._model.default_state.hasOwnProperty(i)) {
					data.state[i] = this._model.default_state[i];
				}
			}
			tmp = $.vakata.attributes(d, true);
			$.each(tmp, function (i, v) {
				v = $.trim(v);
				if(!v.length) { return true; }
				data.li_attr[i] = v;
				if(i === 'id') {
					data.id = v.toString();
				}
			});
			tmp = d.children('a').first();
			if(tmp.length) {
				tmp = $.vakata.attributes(tmp, true);
				$.each(tmp, function (i, v) {
					v = $.trim(v);
					if(v.length) {
						data.a_attr[i] = v;
					}
				});
			}
			tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
			tmp.children("ins, i, ul").remove();
			tmp = tmp.html();
			tmp = $('<div />').html(tmp);
			data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
			tmp = d.data();
			data.data = tmp ? $.extend(true, {}, tmp) : null;
			data.state.opened = d.hasClass('jstree-open');
			data.state.selected = d.children('a').hasClass('jstree-clicked');
			data.state.disabled = d.children('a').hasClass('jstree-disabled');
			if(data.data && data.data.jstree) {
				for(i in data.data.jstree) {
					if(data.data.jstree.hasOwnProperty(i)) {
						data.state[i] = data.data.jstree[i];
					}
				}
			}
			tmp = d.children("a").children(".jstree-themeicon");
			if(tmp.length) {
				data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
			}
			if(data.state.icon !== undefined) {
				data.icon = data.state.icon;
			}
			if(data.icon === undefined || data.icon === null || data.icon === "") {
				data.icon = true;
			}
			tmp = d.children("ul").children("li");
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);
			data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
			if(tmp.length) {
				tmp.each($.proxy(function (i, v) {
					c = this._parse_model_from_html($(v), data.id, ps);
					e = this._model.data[c];
					data.children.push(c);
					if(e.children_d.length) {
						data.children_d = data.children_d.concat(e.children_d);
					}
				}, this));
				data.children_d = data.children_d.concat(data.children);
			}
			else {
				if(d.hasClass('jstree-closed')) {
					data.state.loaded = false;
				}
			}
			if(data.li_attr['class']) {
				data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
			}
			if(data.a_attr['class']) {
				data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
			}
			m[data.id] = data;
			if(data.state.selected) {
				this._data.core.selected.push(data.id);
			}
			return data.id;
		},
		/**
		 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_flat_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_flat_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = d.id.toString(),
				m = this._model.data,
				df = this._model.default_state,
				i, j, c, e,
				tmp = {
					id			: tid,
					text		: d.text || '',
					icon		: d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: d.children || [],
					children_d	: d.children_d || [],
					data		: d.data,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tid;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			m[tmp.id] = tmp;
			for(i = 0, j = tmp.children.length; i < j; i++) {
				c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
				e = m[c];
				tmp.children_d.push(c);
				if(e.children_d.length) {
					tmp.children_d = tmp.children_d.concat(e.children_d);
				}
			}
			delete d.data;
			delete d.children;
			m[tmp.id].original = d;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);

			tmp = {
				id			: false,
				text		: typeof d === 'string' ? d : '',
				icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
				parent		: p,
				parents		: ps,
				children	: [],
				children_d	: [],
				data		: null,
				state		: { },
				li_attr		: { id : false },
				a_attr		: { href : '#' },
				original	: false
			};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.id) { tmp.id = d.id.toString(); }
			if(d && d.text) { tmp.text = d.text; }
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
				tmp.icon = true;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(tmp.li_attr.id && !tmp.id) {
				tmp.id = tmp.li_attr.id.toString();
			}
			if(!tmp.id) {
				tmp.id = tid;
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tmp.id;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children.length) {
				for(i = 0, j = d.children.length; i < j; i++) {
					c = this._parse_model_from_json(d.children[i], tmp.id, ps);
					e = m[c];
					tmp.children.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				tmp.children_d = tmp.children_d.concat(tmp.children);
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			delete d.data;
			delete d.children;
			tmp.original = d;
			m[tmp.id] = tmp;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * redraws all nodes that need to be redrawn. Used internally.
		 * @private
		 * @name _redraw()
		 * @trigger redraw.jstree
		 */
		_redraw : function () {
			var nodes = this._model.force_full_redraw ? this._model.data['#'].children.concat([]) : this._model.changed.concat([]),
				f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
			for(i = 0, j = nodes.length; i < j; i++) {
				tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
				if(tmp && this._model.force_full_redraw) {
					f.appendChild(tmp);
				}
			}
			if(this._model.force_full_redraw) {
				f.className = this.get_container_ul()[0] ? this.get_container_ul()[0].className : null;
				f.setAttribute('role','group');
				this.element.empty().append(f);
				//this.get_container_ul()[0].appendChild(f);
			}
			if(fe !== null) {
				tmp = this.get_node(fe, true);
				if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
					tmp.children('.jstree-anchor').focus();
				}
				else {
					this._data.core.focused = null;
				}
			}
			this._model.force_full_redraw = false;
			this._model.changed = [];
			/**
			 * triggered after nodes are redrawn
			 * @event
			 * @name redraw.jstree
			 * @param {array} nodes the redrawn nodes
			 */
			this.trigger('redraw', { "nodes" : nodes });
		},
		/**
		 * redraws all nodes that need to be redrawn or optionally - the whole tree
		 * @name redraw([full])
		 * @param {Boolean} full if set to `true` all nodes are redrawn.
		 */
		redraw : function (full) {
			if(full) {
				this._model.force_full_redraw = true;
			}
			//if(this._model.redraw_timeout) {
			//	clearTimeout(this._model.redraw_timeout);
			//}
			//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
			this._redraw();
		},
		/**
		 * redraws a single node's children. Used internally.
		 * @private
		 * @name draw_children(node)
		 * @param {mixed} node the node whose children will be redrawn
		 */
		draw_children : function (node) {
			var obj = this.get_node(node),
				i = false,
				j = false,
				k = false,
				d = document;
			if(!obj) { return false; }
			if(obj.id === '#') { return this.redraw(true); }
			node = this.get_node(node, true);
			if(!node || !node.length) { return false; } // TODO: quick toggle

			node.children('.jstree-children').remove();
			node = node[0];
			if(obj.children.length && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], true, true));
				}
				node.appendChild(k);
			}
		},
		/**
		 * redraws a single node. Used internally.
		 * @private
		 * @name redraw_node(node, deep, is_callback, force_render)
		 * @param {mixed} node the node to redraw
		 * @param {Boolean} deep should child nodes be redrawn too
		 * @param {Boolean} is_callback is this a recursion call
		 * @param {Boolean} force_render should children of closed parents be drawn anyway
		 */
		redraw_node : function (node, deep, is_callback, force_render) {
			var obj = this.get_node(node),
				par = false,
				ind = false,
				old = false,
				i = false,
				j = false,
				k = false,
				c = '',
				d = document,
				m = this._model.data,
				f = false,
				s = false,
				tmp = null,
				t = 0,
				l = 0;
			if(!obj) { return false; }
			if(obj.id === '#') {  return this.redraw(true); }
			deep = deep || obj.children.length === 0;
			node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
			if(!node) {
				deep = true;
				//node = d.createElement('LI');
				if(!is_callback) {
					par = obj.parent !== '#' ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
					if(par !== null && (!par || !m[obj.parent].state.opened)) {
						return false;
					}
					ind = $.inArray(obj.id, par === null ? m['#'].children : m[obj.parent].children);
				}
			}
			else {
				node = $(node);
				if(!is_callback) {
					par = node.parent().parent()[0];
					if(par === this.element[0]) {
						par = null;
					}
					ind = node.index();
				}
				// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
				if(!deep && obj.children.length && !node.children('.jstree-children').length) {
					deep = true;
				}
				if(!deep) {
					old = node.children('.jstree-children')[0];
				}
				f = node.children('.jstree-anchor')[0] === document.activeElement;
				node.remove();
				//node = d.createElement('LI');
				//node = node[0];
			}
			node = _node.cloneNode(true);
			// node is DOM, deep is boolean

			c = 'jstree-node ';
			for(i in obj.li_attr) {
				if(obj.li_attr.hasOwnProperty(i)) {
					if(i === 'id') { continue; }
					if(i !== 'class') {
						node.setAttribute(i, obj.li_attr[i]);
					}
					else {
						c += obj.li_attr[i];
					}
				}
			}
			if(!obj.a_attr.id) {
				obj.a_attr.id = obj.id + '_anchor';
			}
			node.setAttribute('aria-selected', !!obj.state.selected);
			node.setAttribute('aria-level', obj.parents.length);
			node.setAttribute('aria-labelledby', obj.a_attr.id);
			if(obj.state.disabled) {
				node.setAttribute('aria-disabled', true);
			}

			if(obj.state.loaded && !obj.children.length) {
				c += ' jstree-leaf';
			}
			else {
				c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
				node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
			}
			if(obj.parent !== null && m[obj.parent].children[m[obj.parent].children.length - 1] === obj.id) {
				c += ' jstree-last';
			}
			node.id = obj.id;
			node.className = c;
			c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
			for(j in obj.a_attr) {
				if(obj.a_attr.hasOwnProperty(j)) {
					if(j === 'href' && obj.a_attr[j] === '#') { continue; }
					if(j !== 'class') {
						node.childNodes[1].setAttribute(j, obj.a_attr[j]);
					}
					else {
						c += ' ' + obj.a_attr[j];
					}
				}
			}
			if(c.length) {
				node.childNodes[1].className = 'jstree-anchor ' + c;
			}
			if((obj.icon && obj.icon !== true) || obj.icon === false) {
				if(obj.icon === false) {
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
				}
				else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
					node.childNodes[1].className += ' ' + obj.icon + ' jstree-themeicon-custom';	//新版jstree图标可配置 （杨兴康）
				}
				else {
					node.childNodes[1].childNodes[0].style.backgroundImage = 'url('+obj.icon+')';
					node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
					node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
				}
			}

			if(this.settings.core.force_text) {
				node.childNodes[1].appendChild(d.createTextNode(obj.text));
			}
			else {
				node.childNodes[1].innerHTML += obj.text;
			}


			if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], deep, true));
				}
				node.appendChild(k);
			}
			if(old) {
				node.appendChild(old);
			}
			if(!is_callback) {
				// append back using par / ind
				if(!par) {
					par = this.element[0];
				}
				for(i = 0, j = par.childNodes.length; i < j; i++) {
					if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
						tmp = par.childNodes[i];
						break;
					}
				}
				if(!tmp) {
					tmp = d.createElement('UL');
					tmp.setAttribute('role', 'group');
					tmp.className = 'jstree-children';
					par.appendChild(tmp);
				}
				par = tmp;

				if(ind < par.childNodes.length) {
					par.insertBefore(node, par.childNodes[ind]);
				}
				else {
					par.appendChild(node);
				}
				if(f) {
					t = this.element[0].scrollTop;
					l = this.element[0].scrollLeft;
					node.childNodes[1].focus();
					this.element[0].scrollTop = t;
					this.element[0].scrollLeft = l;
				}
			}
			if(obj.state.opened && !obj.state.loaded) {
				obj.state.opened = false;
				setTimeout($.proxy(function () {
					this.open_node(obj.id, false, 0);
				}, this), 0);
			}
			return node;
		},
		/**
		 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_node(obj [, callback, animation])
		 * @param {mixed} obj the node to open
		 * @param {Function} callback a function to execute once the node is opened
		 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
		 */
		open_node : function (obj, callback, animation) {
			var t1, t2, d, t;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.open_node(obj[t1], callback, animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			if(!this.is_closed(obj)) {
				if(callback) {
					callback.call(this, obj, false);
				}
				return false;
			}
			if(!this.is_loaded(obj)) {
				if(this.is_loading(obj)) {
					return setTimeout($.proxy(function () {
						this.open_node(obj, callback, animation);
					}, this), 500);
				}
				this.load_node(obj, function (o, ok) {
					return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
				});
			}
			else {
				d = this.get_node(obj, true);
				t = this;
				if(d.length) {
					if(animation && d.children(".jstree-children").length) {
						d.children(".jstree-children").stop(true, true);
					}
					if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
						this.draw_children(obj);
						//d = this.get_node(obj, true);
					}
					if(!animation) {
						this.trigger('before_open', { "node" : obj });
						d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
						d[0].setAttribute("aria-expanded", true);
					}
					else {
						this.trigger('before_open', { "node" : obj });
						d
							.children(".jstree-children").css("display","none").end()
							.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
							.children(".jstree-children").stop(true, true)
								.slideDown(animation, function () {
									this.style.display = "";
									t.trigger("after_open", { "node" : obj });
								});
					}
				}
				obj.state.opened = true;
				if(callback) {
					callback.call(this, obj, true);
				}
				if(!d.length) {
					/**
					 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
					 * @event
					 * @name before_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('before_open', { "node" : obj });
				}
				/**
				 * triggered when a node is opened (if there is an animation it will not be completed yet)
				 * @event
				 * @name open_node.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_node', { "node" : obj });
				if(!animation || !d.length) {
					/**
					 * triggered when a node is opened and the animation is complete
					 * @event
					 * @name after_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger("after_open", { "node" : obj });
				}
			}
		},
		/**
		 * opens every parent of a node (node should be loaded)
		 * @name _open_to(obj)
		 * @param {mixed} obj the node to reveal
		 * @private
		 */
		_open_to : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			var i, j, p = obj.parents;
			for(i = 0, j = p.length; i < j; i+=1) {
				if(i !== '#') {
					this.open_node(p[i], false, 0);
				}
			}
			return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
		},
		/**
		 * closes a node, hiding its children
		 * @name close_node(obj [, animation])
		 * @param {mixed} obj the node to close
		 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger close_node.jstree, after_close.jstree
		 */
		close_node : function (obj, animation) {
			var t1, t2, t, d;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.close_node(obj[t1], animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			if(this.is_closed(obj)) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			t = this;
			d = this.get_node(obj, true);
			if(d.length) {
				if(!animation) {
					d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
					d.attr("aria-expanded", false).children('.jstree-children').remove();
				}
				else {
					d
						.children(".jstree-children").attr("style","display:block !important").end()
						.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
						.children(".jstree-children").stop(true, true).slideUp(animation, function () {
							this.style.display = "";
							d.children('.jstree-children').remove();
							t.trigger("after_close", { "node" : obj });
						});
				}
			}
			obj.state.opened = false;
			/**
			 * triggered when a node is closed (if there is an animation it will not be complete yet)
			 * @event
			 * @name close_node.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_node',{ "node" : obj });
			if(!animation || !d.length) {
				/**
				 * triggered when a node is closed and the animation is complete
				 * @event
				 * @name after_close.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger("after_close", { "node" : obj });
			}
		},
		/**
		 * toggles a node - closing it if it is open, opening it if it is closed
		 * @name toggle_node(obj)
		 * @param {mixed} obj the node to toggle
		 */
		toggle_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.toggle_node(obj[t1]);
				}
				return true;
			}
			if(this.is_closed(obj)) {
				return this.open_node(obj);
			}
			if(this.is_open(obj)) {
				return this.close_node(obj);
			}
		},
		/**
		 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_all([obj, animation, original_obj])
		 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
		 * @param {jQuery} reference to the node that started the process (internal use)
		 * @trigger open_all.jstree
		 */
		open_all : function (obj, animation, original_obj) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if(this.is_closed(this._model.data[obj.children_d[i]])) {
						this._model.data[obj.children_d[i]].state.opened = true;
					}
				}
				return this.trigger('open_all', { "node" : obj });
			}
			original_obj = original_obj || dom;
			_this = this;
			dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
			dom.each(function () {
				_this.open_node(
					this,
					function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
					animation || 0
				);
			});
			if(original_obj.find('.jstree-closed').length === 0) {
				/**
				 * triggered when an `open_all` call completes
				 * @event
				 * @name open_all.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_all', { "node" : this.get_node(original_obj) });
			}
		},
		/**
		 * closes all nodes within a node (or the tree), revaling their children
		 * @name close_all([obj, animation])
		 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
		 * @trigger close_all.jstree
		 */
		close_all : function (obj, animation) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true),
				_this = this, i, j;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].state.opened = false;
				}
				return this.trigger('close_all', { "node" : obj });
			}
			dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
			$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
			/**
			 * triggered when an `close_all` call completes
			 * @event
			 * @name close_all.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_all', { "node" : obj });
		},
		/**
		 * checks if a node is disabled (not selectable)
		 * @name is_disabled(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_disabled : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.disabled;
		},
		/**
		 * enables a node - so that it can be selected
		 * @name enable_node(obj)
		 * @param {mixed} obj the node to enable
		 * @trigger enable_node.jstree
		 */
		enable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = false;
			this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
			/**
			 * triggered when an node is enabled
			 * @event
			 * @name enable_node.jstree
			 * @param {Object} node the enabled node
			 */
			this.trigger('enable_node', { 'node' : obj });
		},
		/**
		 * disables a node - so that it can not be selected
		 * @name disable_node(obj)
		 * @param {mixed} obj the node to disable
		 * @trigger disable_node.jstree
		 */
		disable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = true;
			this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
			/**
			 * triggered when an node is disabled
			 * @event
			 * @name disable_node.jstree
			 * @param {Object} node the disabled node
			 */
			this.trigger('disable_node', { 'node' : obj });
		},
		/**
		 * called when a node is selected by the user. Used internally.
		 * @private
		 * @name activate_node(obj, e)
		 * @param {mixed} obj the node
		 * @param {Object} e the related event
		 * @trigger activate_node.jstree, changed.jstree
		 */
		activate_node : function (obj, e) {
			if(this.is_disabled(obj)) {
				return false;
			}

			// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
			this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
			if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
			if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

			if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
				if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
					this.deselect_node(obj, false, e);
				}
				else {
					this.deselect_all(true);
					this.select_node(obj, false, false, e);
					this._data.core.last_clicked = this.get_node(obj);
				}
			}
			else {
				if(e.shiftKey) {
					var o = this.get_node(obj).id,
						l = this._data.core.last_clicked.id,
						p = this.get_node(this._data.core.last_clicked.parent).children,
						c = false,
						i, j;
					for(i = 0, j = p.length; i < j; i += 1) {
						// separate IFs work whem o and l are the same
						if(p[i] === o) {
							c = !c;
						}
						if(p[i] === l) {
							c = !c;
						}
						if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
							this.select_node(p[i], true, false, e);
						}
						else {
							this.deselect_node(p[i], true, e);
						}
					}
					this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
				}
				else {
					if(!this.is_selected(obj)) {
						this.select_node(obj, false, false, e);
					}
					else {
						this.deselect_node(obj, false, e);
					}
				}
			}
			/**
			 * triggered when an node is clicked or intercated with by the user
			 * @event
			 * @name activate_node.jstree
			 * @param {Object} node
			 */
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
		 * @private
		 * @name hover_node(obj)
		 * @param {mixed} obj
		 * @trigger hover_node.jstree
		 */
		hover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
				return false;
			}
			var o = this.element.find('.jstree-hovered'), t = this.element;
			if(o && o.length) { this.dehover_node(o); }

			obj.children('.jstree-anchor').addClass('jstree-hovered');
			/**
			 * triggered when an node is hovered
			 * @event
			 * @name hover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('hover_node', { 'node' : this.get_node(obj) });
			setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
		},
		/**
		 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
		 * @private
		 * @name dehover_node(obj)
		 * @param {mixed} obj
		 * @trigger dehover_node.jstree
		 */
		dehover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
				return false;
			}
			obj.children('.jstree-anchor').removeClass('jstree-hovered');
			/**
			 * triggered when an node is no longer hovered
			 * @event
			 * @name dehover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('dehover_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * select a node
		 * @name select_node(obj [, supress_event, prevent_open])
		 * @param {mixed} obj an array can be used to select multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
		 * @trigger select_node.jstree, changed.jstree
		 */
		select_node : function (obj, supress_event, prevent_open, e) {
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.select_node(obj[t1], supress_event, prevent_open, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.selected) {
				obj.state.selected = true;
				this._data.core.selected.push(obj.id);
				if(!prevent_open) {
					dom = this._open_to(obj);
				}
				if(dom && dom.length) {
					dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
				}
				/**
				 * triggered when an node is selected
				 * @event
				 * @name select_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this select_node
				 */
				this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					/**
					 * triggered when selection changes
					 * @event
					 * @name changed.jstree
					 * @param {Object} node
					 * @param {Object} action the action that caused the selection to change
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this changed event
					 */
					this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * deselect a node
		 * @name deselect_node(obj [, supress_event])
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_node.jstree, changed.jstree
		 */
		deselect_node : function (obj, supress_event, e) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.deselect_node(obj[t1], supress_event, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.selected) {
				obj.state.selected = false;
				this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
				if(dom.length) {
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
				}
				/**
				 * triggered when an node is deselected
				 * @event
				 * @name deselect_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this deselect_node
				 */
				this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * select all nodes in the tree
		 * @name select_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger select_all.jstree, changed.jstree
		 */
		select_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			this._data.core.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are selected
			 * @event
			 * @name select_all.jstree
			 * @param {Array} selected the current selection
			 */
			this.trigger('select_all', { 'selected' : this._data.core.selected });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * deselect all selected nodes
		 * @name deselect_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_all.jstree, changed.jstree
		 */
		deselect_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = false;
				}
			}
			this._data.core.selected = [];
			this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
			/**
			 * triggered when all nodes are deselected
			 * @event
			 * @name deselect_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 */
			this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * checks if a node is selected
		 * @name is_selected(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 */
		is_selected : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.state.selected;
		},
		/**
		 * get an array of all selected nodes
		 * @name get_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_selected : function (full) {
			return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
		},
		/**
		 * get an array of all top level selected nodes (ignoring children of selected nodes)
		 * @name get_top_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_top_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		},
		/**
		 * get an array of all bottom level selected nodes (ignoring selected parents)
		 * @name get_bottom_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_bottom_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		},
		/**
		 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
		 * @name get_state()
		 * @private
		 * @return {Object}
		 */
		get_state : function () {
			var state	= {
				'core' : {
					'open' : [],
					'scroll' : {
						'left' : this.element.scrollLeft(),
						'top' : this.element.scrollTop()
					},
					/*!
					'themes' : {
						'name' : this.get_theme(),
						'icons' : this._data.core.themes.icons,
						'dots' : this._data.core.themes.dots
					},
					*/
					'selected' : []
				}
			}, i;
			for(i in this._model.data) {
				if(this._model.data.hasOwnProperty(i)) {
					if(i !== '#') {
						if(this._model.data[i].state.opened) {
							state.core.open.push(i);
						}
						if(this._model.data[i].state.selected) {
							state.core.selected.push(i);
						}
					}
				}
			}
			return state;
		},
		/**
		 * sets the state of the tree. Used internally.
		 * @name set_state(state [, callback])
		 * @private
		 * @param {Object} state the state to restore
		 * @param {Function} callback an optional function to execute once the state is restored.
		 * @trigger set_state.jstree
		 */
		set_state : function (state, callback) {
			if(state) {
				if(state.core) {
					var res, n, t, _this, i;
					if(state.core.open) {
						if(!$.isArray(state.core.open) || !state.core.open.length) {
							delete state.core.open;
							this.set_state(state, callback);
						}
						else {
							this._load_nodes(state.core.open, function (nodes) {
								this.open_node(nodes, false, 0);
								delete state.core.open;
								this.set_state(state, callback);
							}, true);
						}
						return false;
					}
					if(state.core.scroll) {
						if(state.core.scroll && state.core.scroll.left !== undefined) {
							this.element.scrollLeft(state.core.scroll.left);
						}
						if(state.core.scroll && state.core.scroll.top !== undefined) {
							this.element.scrollTop(state.core.scroll.top);
						}
						delete state.core.scroll;
						this.set_state(state, callback);
						return false;
					}
					if(state.core.selected) {
						_this = this;
						this.deselect_all();
						$.each(state.core.selected, function (i, v) {
							_this.select_node(v, false, true);
						});
						delete state.core.selected;
						this.set_state(state, callback);
						return false;
					}
					for(i in state) {
						if(state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
							delete state[i];
						}
					}
					if($.isEmptyObject(state.core)) {
						delete state.core;
						this.set_state(state, callback);
						return false;
					}
				}
				if($.isEmptyObject(state)) {
					state = null;
					if(callback) { callback.call(this); }
					/**
					 * triggered when a `set_state` call completes
					 * @event
					 * @name set_state.jstree
					 */
					this.trigger('set_state');
					return false;
				}
				return true;
			}
			return false;
		},
		/**
		 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
		 * @name refresh()
		 * @param {Boolean} skip_loading an option to skip showing the loading indicator
		 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
		 * @trigger refresh.jstree
		 */
		refresh : function (skip_loading, forget_state) {
			this._data.core.state = forget_state === true ? {} : this.get_state();
			if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
			this._cnt = 0;
			this._model.data = {
				'#' : {
					id : '#',
					parent : null,
					parents : [],
					children : [],
					children_d : [],
					state : { loaded : false }
				}
			};
			var c = this.get_container_ul()[0].className;
			if(!skip_loading) {
				this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j'+this._id+'_loading');
			}
			this.load_node('#', function (o, s) {
				if(s) {
					this.get_container_ul()[0].className = c;
					if(this._firstChild(this.get_container_ul()[0])) {
						this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
					}
					this.set_state($.extend(true, {}, this._data.core.state), function () {
						/**
						 * triggered when a `refresh` call completes
						 * @event
						 * @name refresh.jstree
						 */
						this.trigger('refresh');
					});
				}
				this._data.core.state = null;
			});
		},
		/**
		 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
		 * @name refresh_node(obj)
		 * @param  {mixed} obj the node
		 * @trigger refresh_node.jstree
		 */
		refresh_node : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var opened = [], to_load = [], s = this._data.core.selected.concat([]);
			to_load.push(obj.id);
			if(obj.state.opened === true) { opened.push(obj.id); }
			this.get_node(obj, true).find('.jstree-open').each(function() { opened.push(this.id); });
			this._load_nodes(to_load, $.proxy(function (nodes) {
				this.open_node(opened, false, 0);
				this.select_node(this._data.core.selected);
				/**
				 * triggered when a node is refreshed
				 * @event
				 * @name refresh_node.jstree
				 * @param {Object} node - the refreshed node
				 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
				 */
				this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
			}, this));
		},
		/**
		 * set (change) the ID of a node
		 * @name set_id(obj, id)
		 * @param  {mixed} obj the node
		 * @param  {String} id the new ID
		 * @return {Boolean}
		 */
		set_id : function (obj, id) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var i, j, m = this._model.data;
			id = id.toString();
			// update parents (replace current ID with new one in children and children_d)
			m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
			for(i = 0, j = obj.parents.length; i < j; i++) {
				m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
			}
			// update children (replace current ID with new one in parent and parents)
			for(i = 0, j = obj.children.length; i < j; i++) {
				m[obj.children[i]].parent = id;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
			}
			i = $.inArray(obj.id, this._data.core.selected);
			if(i !== -1) { this._data.core.selected[i] = id; }
			// update model and obj itself (obj.id, this._model.data[KEY])
			i = this.get_node(obj.id, true);
			if(i) {
				i.attr('id', id).children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
				if(this.element.attr('aria-activedescendant') === obj.id) {
					this.element.attr('aria-activedescendant', id);
				}
			}
			delete m[obj.id];
			obj.id = id;
			obj.li_attr.id = id;
			m[id] = obj;
			return true;
		},
		/**
		 * get the text value of a node
		 * @name get_text(obj)
		 * @param  {mixed} obj the node
		 * @return {String}
		 */
		get_text : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.text;
		},
		/**
		 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
		 * @private
		 * @name set_text(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger set_text.jstree
		 */
		set_text : function (obj, val) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_text(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			obj.text = val;
			if(this.get_node(obj, true).length) {
				this.redraw_node(obj.id);
			}
			/**
			 * triggered when a node text value is changed
			 * @event
			 * @name set_text.jstree
			 * @param {Object} obj
			 * @param {String} text the new value
			 */
			this.trigger('set_text',{ "obj" : obj, "text" : val });
			return true;
		},
		/**
		 * gets a JSON representation of a node (or the whole tree)
		 * @name get_json([obj, options])
		 * @param  {mixed} obj
		 * @param  {Object} options
		 * @param  {Boolean} options.no_state do not return state information
		 * @param  {Boolean} options.no_id do not return ID
		 * @param  {Boolean} options.no_children do not include children
		 * @param  {Boolean} options.no_data do not include node data
		 * @param  {Boolean} options.flat return flat JSON instead of nested
		 * @return {Object}
		 */
		get_json : function (obj, options, flat) {
			obj = this.get_node(obj || '#');
			if(!obj) { return false; }
			if(options && options.flat && !flat) { flat = []; }
			var tmp = {
				'id' : obj.id,
				'text' : obj.text,
				'icon' : this.get_icon(obj),
				'li_attr' : $.extend(true, {}, obj.li_attr),
				'a_attr' : $.extend(true, {}, obj.a_attr),
				'state' : {},
				'data' : options && options.no_data ? false : $.extend(true, {}, obj.data)
				//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
			}, i, j;
			if(options && options.flat) {
				tmp.parent = obj.parent;
			}
			else {
				tmp.children = [];
			}
			if(!options || !options.no_state) {
				for(i in obj.state) {
					if(obj.state.hasOwnProperty(i)) {
						tmp.state[i] = obj.state[i];
					}
				}
			}
			if(options && options.no_id) {
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
			}
			if(options && options.flat && obj.id !== '#') {
				flat.push(tmp);
			}
			if(!options || !options.no_children) {
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(options && options.flat) {
						this.get_json(obj.children[i], options, flat);
					}
					else {
						tmp.children.push(this.get_json(obj.children[i], options));
					}
				}
			}
			return options && options.flat ? flat : (obj.id === '#' ? tmp.children : tmp);
		},
		/**
		 * create a new node (do not confuse with load_node)
		 * @name create_node([obj, node, pos, callback, is_loaded])
		 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
		 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
		 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
		 * @param  {Function} callback a function to be called once the node is created
		 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
		 * @return {String}            the ID of the newly create node
		 * @trigger model.jstree, create_node.jstree
		 */
		create_node : function (par, node, pos, callback, is_loaded) {
			if(par === null) { par = "#"; }
			par = this.get_node(par);
			if(!par) { return false; }
			pos = pos === undefined ? "last" : pos;
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
			}
			if(!node) { node = { "text" : this.get_string('New node') }; }
			if(typeof node === "string") { node = { "text" : node }; }
			if(node.text === undefined) { node.text = this.get_string('New node'); }
			var tmp, dpc, i, j;

			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children);
					par = tmp;
					break;
				case "after" :
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children) + 1;
					par = tmp;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > par.children.length) { pos = par.children.length; }
			if(!node.id) { node.id = true; }
			if(!this.check("create_node", node, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, par.id, par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : par.id });

			par.children_d = par.children_d.concat(dpc);
			for(i = 0, j = par.parents.length; i < j; i++) {
				this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
			}
			node = tmp;
			tmp = [];
			for(i = 0, j = par.children.length; i < j; i++) {
				tmp[i >= pos ? i+1 : i] = par.children[i];
			}
			tmp[pos] = node.id;
			par.children = tmp;

			this.redraw_node(par, true);
			if(callback) { callback.call(this, this.get_node(node)); }
			/**
			 * triggered when a node is created
			 * @event
			 * @name create_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the new node among the parent's children
			 */
			this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
			return node.id;
		},
		/**
		 * set the text value of a node
		 * @name rename_node(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger rename_node.jstree
		 */
		rename_node : function (obj, val) {
			var t1, t2, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.rename_node(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.text;
			if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
			/**
			 * triggered when a node is renamed
			 * @event
			 * @name rename_node.jstree
			 * @param {Object} node
			 * @param {String} text the new value
			 * @param {String} old the old value
			 */
			this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
			return true;
		},
		/**
		 * remove a node
		 * @name delete_node(obj)
		 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
		 * @return {Boolean}
		 * @trigger delete_node.jstree, changed.jstree
		 */
		delete_node : function (obj) {
			var t1, t2, par, pos, tmp, i, j, k, l, c;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.delete_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			par = this.get_node(obj.parent);
			pos = $.inArray(obj.id, par.children);
			c = false;
			if(!this.check("delete_node", obj, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(pos !== -1) {
				par.children = $.vakata.array_remove(par.children, pos);
			}
			tmp = obj.children_d.concat([]);
			tmp.push(obj.id);
			for(k = 0, l = tmp.length; k < l; k++) {
				for(i = 0, j = obj.parents.length; i < j; i++) {
					pos = $.inArray(tmp[k], this._model.data[obj.parents[i]].children_d);
					if(pos !== -1) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove(this._model.data[obj.parents[i]].children_d, pos);
					}
				}
				if(this._model.data[tmp[k]].state.selected) {
					c = true;
					pos = $.inArray(tmp[k], this._data.core.selected);
					if(pos !== -1) {
						this._data.core.selected = $.vakata.array_remove(this._data.core.selected, pos);
					}
				}
			}
			/**
			 * triggered when a node is deleted
			 * @event
			 * @name delete_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 */
			this.trigger('delete_node', { "node" : obj, "parent" : par.id });
			if(c) {
				this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				delete this._model.data[tmp[k]];
			}
			this.redraw_node(par, true);
			return true;
		},
		/**
		 * check if an operation is premitted on the tree. Used internally.
		 * @private
		 * @name check(chk, obj, par, pos)
		 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
		 * @param  {mixed} obj the node
		 * @param  {mixed} par the parent
		 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
		 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
		 * @return {Boolean}
		 */
		check : function (chk, obj, par, pos, more) {
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
			if(chk === "move_node" || chk === "copy_node") {
				if((!more || !more.is_multi) && (obj.id === par.id || $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
			}
			if(tmp && tmp.data) { tmp = tmp.data; }
			if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
				if(tmp.functions[chk] === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				}
				return tmp.functions[chk];
			}
			if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				return false;
			}
			return true;
		},
		/**
		 * get the last error
		 * @name last_error()
		 * @return {Object}
		 */
		last_error : function () {
			return this._data.core.last_error;
		},
		/**
		 * move a node to a new parent
		 * @name move_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger move_node.jstree
		 */
		move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);

			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(is_multi) {
				if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
					if(old_ins) { old_ins.delete_node(obj); }
					return tmp;
				}
				return false;
			}
			//var m = this._model.data;
			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(obj.parent === new_par.id) {
				dpc = new_par.children.concat();
				tmp = $.inArray(obj.id, dpc);
				if(tmp !== -1) {
					dpc = $.vakata.array_remove(dpc, tmp);
					if(pos > tmp) { pos--; }
				}
				tmp = [];
				for(i = 0, j = dpc.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = dpc[i];
				}
				tmp[pos] = obj.id;
				new_par.children = tmp;
				this._node_changed(new_par.id);
				this.redraw(new_par.id === '#');
			}
			else {
				// clean old parent and up
				tmp = obj.children_d.concat();
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					dpc = [];
					p = old_ins._model.data[obj.parents[i]].children_d;
					for(k = 0, l = p.length; k < l; k++) {
						if($.inArray(p[k], tmp) === -1) {
							dpc.push(p[k]);
						}
					}
					old_ins._model.data[obj.parents[i]].children_d = dpc;
				}
				old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = obj.id;
				new_par.children = dpc;
				new_par.children_d.push(obj.id);
				new_par.children_d = new_par.children_d.concat(obj.children_d);

				// update object
				obj.parent = new_par.id;
				tmp = new_par.parents.concat();
				tmp.unshift(new_par.id);
				p = obj.parents.length;
				obj.parents = tmp;

				// update object children
				tmp = tmp.concat();
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
					Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
				}

				if(old_par === '#' || new_par.id === '#') {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(old_par);
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw();
				}
			}
			if(callback) { callback.call(this, obj, new_par, pos); }
			/**
			 * triggered when a node is moved
			 * @event
			 * @name move_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the old position of the node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return obj.id;
		},
		/**
		 * copy a node to a new parent
		 * @name copy_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
		 * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
		 * @trigger model.jstree copy_node.jstree
		 */
		copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
			var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
			}

			if($.isArray(obj)) {
				if(obj.length === 1) {
					obj = obj[0];
				}
				else {
					//obj = obj.slice();
					for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
						if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
							par = tmp;
							pos = "after";
						}
					}
					this.redraw();
					return true;
				}
			}
			obj = obj && obj.id ? obj : this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);

			if(old_ins && old_ins._id) {
				obj = old_ins._model.data[obj.id];
			}

			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
			if(!node) { return false; }
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });

			// insert into new parent and up
			for(i = 0, j = new_par.parents.length; i < j; i++) {
				this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
			}
			dpc = [];
			for(i = 0, j = new_par.children.length; i < j; i++) {
				dpc[i >= pos ? i+1 : i] = new_par.children[i];
			}
			dpc[pos] = tmp.id;
			new_par.children = dpc;
			new_par.children_d.push(tmp.id);
			new_par.children_d = new_par.children_d.concat(tmp.children_d);

			if(new_par.id === '#') {
				this._model.force_full_redraw = true;
			}
			if(!this._model.force_full_redraw) {
				this._node_changed(new_par.id);
			}
			if(!skip_redraw) {
				this.redraw(new_par.id === '#');
			}
			if(callback) { callback.call(this, tmp, new_par, pos); }
			/**
			 * triggered when a node is copied
			 * @event
			 * @name copy_node.jstree
			 * @param {Object} node the copied node
			 * @param {Object} original the original node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the position of the original node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return tmp.id;
		},
		/**
		 * cut a node (a later call to `paste(obj)` would move the node)
		 * @name cut(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger cut.jstree
		 */
		cut : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'move_node';
			/**
			 * triggered when nodes are added to the buffer for moving
			 * @event
			 * @name cut.jstree
			 * @param {Array} node
			 */
			this.trigger('cut', { "node" : obj });
		},
		/**
		 * copy a node (a later call to `paste(obj)` would copy the node)
		 * @name copy(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger copy.jstree
		 */
		copy : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'copy_node';
			/**
			 * triggered when nodes are added to the buffer for copying
			 * @event
			 * @name copy.jstree
			 * @param {Array} node
			 */
			this.trigger('copy', { "node" : obj });
		},
		/**
		 * get the current buffer (any nodes that are waiting for a paste operation)
		 * @name get_buffer()
		 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
		 */
		get_buffer : function () {
			return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
		},
		/**
		 * check if there is something in the buffer to paste
		 * @name can_paste()
		 * @return {Boolean}
		 */
		can_paste : function () {
			return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
		},
		/**
		 * copy or move the previously cut or copied nodes to a new parent
		 * @name paste(obj [, pos])
		 * @param  {mixed} obj the new parent
		 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
		 * @trigger paste.jstree
		 */
		paste : function (obj, pos) {
			obj = this.get_node(obj);
			if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
			if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
				/**
				 * triggered when paste is invoked
				 * @event
				 * @name paste.jstree
				 * @param {String} parent the ID of the receiving node
				 * @param {Array} node the nodes in the buffer
				 * @param {String} mode the performed operation - "copy_node" or "move_node"
				 */
				this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
			}
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
		},
		/**
		 * clear the buffer of previously copied or cut nodes
		 * @name clear_buffer()
		 * @trigger clear_buffer.jstree
		 */
		clear_buffer : function () {
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
			/**
			 * triggered when the copy / cut buffer is cleared
			 * @event
			 * @name clear_buffer.jstree
			 */
			this.trigger('clear_buffer');
		},
		/**
		 * put a node in edit mode (input field to rename the node)
		 * @name edit(obj [, default_text, callback])
		 * @param  {mixed} obj
		 * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
		 * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node and a status parameter - true if the rename is successful, false otherwise. You can access the node's title using .text
		 */
		edit : function (obj, default_text, callback) {
			var rtl, w, a, s, t, h1, h2, fn, tmp;
			obj = this.get_node(obj);
			if(!obj) { return false; }
			if(this.settings.core.check_callback === false) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			tmp = obj;
			default_text = typeof default_text === 'string' ? default_text : obj.text;
			this.set_text(obj, "");
			obj = this._open_to(obj);
			tmp.text = default_text;

			rtl = this._data.core.rtl;
			w  = this.element.width();
			a  = obj.children('.jstree-anchor');
			s  = $('<span>');
			/*!
			oi = obj.children("i:visible"),
			ai = a.children("i:visible"),
			w1 = oi.width() * oi.length,
			w2 = ai.width() * ai.length,
			*/
			t  = default_text;
			h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body");
			h2 = $("<"+"input />", {
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"box-sizing" : "border-box",
							"display" : "inline-block",
							"height" : (this._data.core.li_height) + "px",
							"lineHeight" : (this._data.core.li_height) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = s.children(".jstree-rename-input"),
								v = i.val(),
								f = this.settings.core.force_text,
								nv;
							if(v === "") { v = t; }
							h1.remove();
							s.replaceWith(a);
							s.remove();
							t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
							this.set_text(obj, t);
							nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
							if(!nv) {
								this.set_text(obj, t); // move this up? and fix #483
							}
							if(callback) {
								callback.call(this, tmp, nv);
							}
						}, this),
						"keydown" : function (event) {
							var key = event.which;
							if(key === 27) {
								this.value = t;
							}
							if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
								event.stopImmediatePropagation();
							}
							if(key === 27 || key === 13) {
								event.preventDefault();
								this.blur();
							}
						},
						"click" : function (e) { e.stopImmediatePropagation(); },
						"mousedown" : function (e) { e.stopImmediatePropagation(); },
						"keyup" : function (event) {
							h2.width(Math.min(h1.text("pW" + this.value).width(),w));
						},
						"keypress" : function(event) {
							if(event.which === 13) { return false; }
						}
					});
				fn = {
						fontFamily		: a.css('fontFamily')		|| '',
						fontSize		: a.css('fontSize')			|| '',
						fontWeight		: a.css('fontWeight')		|| '',
						fontStyle		: a.css('fontStyle')		|| '',
						fontStretch		: a.css('fontStretch')		|| '',
						fontVariant		: a.css('fontVariant')		|| '',
						letterSpacing	: a.css('letterSpacing')	|| '',
						wordSpacing		: a.css('wordSpacing')		|| ''
				};
			s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
			a.replaceWith(s);
			h1.css(fn);
			h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
		},


		/**
		 * changes the theme
		 * @name set_theme(theme_name [, theme_url])
		 * @param {String} theme_name the name of the new theme to apply
		 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
		 * @trigger set_theme.jstree
		 */
		set_theme : function (theme_name, theme_url) {
			if(!theme_name) { return false; }
			if(theme_url === true) {
				var dir = this.settings.core.themes.dir;
				if(!dir) { dir = $.jstree.path + '/themes'; }
				theme_url = dir + '/' + theme_name + '/style.css';
			}
			if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
				$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
				themes_loaded.push(theme_url);
			}
			if(this._data.core.themes.name) {
				this.element.removeClass('jstree-' + this._data.core.themes.name);
			}
			this._data.core.themes.name = theme_name;
			this.element.addClass('jstree-' + theme_name);
			this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
			/**
			 * triggered when a theme is set
			 * @event
			 * @name set_theme.jstree
			 * @param {String} theme the new theme
			 */
			this.trigger('set_theme', { 'theme' : theme_name });
		},
		/**
		 * gets the name of the currently applied theme name
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme : function () { return this._data.core.themes.name; },
		/**
		 * changes the theme variant (if the theme has variants)
		 * @name set_theme_variant(variant_name)
		 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
		 */
		set_theme_variant : function (variant_name) {
			if(this._data.core.themes.variant) {
				this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
			this._data.core.themes.variant = variant_name;
			if(variant_name) {
				this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
		},
		/**
		 * gets the name of the currently applied theme variant
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme_variant : function () { return this._data.core.themes.variant; },
		/**
		 * shows a striped background on the container (if the theme supports it)
		 * @name show_stripes()
		 */
		show_stripes : function () { this._data.core.themes.stripes = true; this.get_container_ul().addClass("jstree-striped"); },
		/**
		 * hides the striped background on the container
		 * @name hide_stripes()
		 */
		hide_stripes : function () { this._data.core.themes.stripes = false; this.get_container_ul().removeClass("jstree-striped"); },
		/**
		 * toggles the striped background on the container
		 * @name toggle_stripes()
		 */
		toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
		/**
		 * shows the connecting dots (if the theme supports it)
		 * @name show_dots()
		 */
		show_dots : function () { this._data.core.themes.dots = true; this.get_container_ul().removeClass("jstree-no-dots"); },
		/**
		 * hides the connecting dots
		 * @name hide_dots()
		 */
		hide_dots : function () { this._data.core.themes.dots = false; this.get_container_ul().addClass("jstree-no-dots"); },
		/**
		 * toggles the connecting dots
		 * @name toggle_dots()
		 */
		toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
		/**
		 * show the node icons
		 * @name show_icons()
		 */
		show_icons : function () { this._data.core.themes.icons = true; this.get_container_ul().removeClass("jstree-no-icons"); },
		/**
		 * hide the node icons
		 * @name hide_icons()
		 */
		hide_icons : function () { this._data.core.themes.icons = false; this.get_container_ul().addClass("jstree-no-icons"); },
		/**
		 * toggle the node icons
		 * @name toggle_icons()
		 */
		toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
		/**
		 * set the node icon for a node
		 * @name set_icon(obj, icon)
		 * @param {mixed} obj
		 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 */
		set_icon : function (obj, icon) {
			var t1, t2, dom, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_icon(obj[t1], icon);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.icon;
			obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
			dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
			if(icon === false) {
				this.hide_icon(obj);
			}
			else if(icon === true || icon === null || icon === undefined || icon === '') {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				if(old === false) { this.show_icon(obj); }
			}
			else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
				dom.removeClass(old).css("background","");
				dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			else {
				dom.removeClass(old).css("background","");
				dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			return true;
		},
		/**
		 * get the node icon for a node
		 * @name get_icon(obj)
		 * @param {mixed} obj
		 * @return {String}
		 */
		get_icon : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.icon;
		},
		/**
		 * hide the icon on an individual node
		 * @name hide_icon(obj)
		 * @param {mixed} obj
		 */
		hide_icon : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			obj.icon = false;
			this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
			return true;
		},
		/**
		 * show the icon on an individual node
		 * @name show_icon(obj)
		 * @param {mixed} obj
		 */
		show_icon : function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			dom = this.get_node(obj, true);
			obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
			if(!obj.icon) { obj.icon = true; }
			dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
			return true;
		}
	};

	// helpers
	$.vakata = {};
	// collect attributes
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		if(node && node.attributes) {
			$.each(node.attributes, function (i, v) {
				if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
				if(v.value !== null && $.trim(v.value) !== '') {
					if(with_values) { attr[v.name] = v.value; }
					else { attr.push(v.name); }
				}
			});
		}
		return attr;
	};
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l, o = {};
		for(i = 0, l = array.length; i < l; i++) {
			if(o[array[i]] === undefined) {
				a.push(array[i]);
				o[array[i]] = true;
			}
		}
		return a;
	};
	// remove item from array
	$.vakata.array_remove = function(array, from, to) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		array.push.apply(array, rest);
		return array;
	};
	// remove item from array
	$.vakata.array_remove_item = function(array, item) {
		var tmp = $.inArray(item, array);
		return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
	};


/**
 * ### Checkbox plugin
 *
 * This plugin renders checkbox icons in front of each node, making multiple selection much easier.
 * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
 */

	var _i = document.createElement('I');
	_i.className = 'jstree-icon jstree-checkbox';
	_i.setAttribute('role', 'presentation');
	/**
	 * stores all defaults for the checkbox plugin
	 * @name $.jstree.defaults.checkbox
	 * @plugin checkbox
	 */
	$.jstree.defaults.checkbox = {
		/**
		 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		visible				: true,
		/**
		 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.three_state
		 * @plugin checkbox
		 */
		three_state			: true,
		/**
		 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.whole_node
		 * @plugin checkbox
		 */
		whole_node			: true,
		/**
		 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.keep_selected_style
		 * @plugin checkbox
		 */
		keep_selected_style	: true,
		/**
		 * This setting controls how cascading and undetermined nodes are applied.
		 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
		 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
		 * @name $.jstree.defaults.checkbox.cascade
		 * @plugin checkbox
		 */
		cascade				: '',
		/**
		 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
		 * @name $.jstree.defaults.checkbox.tie_selection
		 * @plugin checkbox
		 */
		tie_selection		: true
	};
	$.jstree.plugins.checkbox = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this._data.checkbox.uto = false;
			this._data.checkbox.selected = [];
			if(this.settings.checkbox.three_state) {
				this.settings.checkbox.cascade = 'up+down+undetermined';
			}
			this.element
				.on("init.jstree", $.proxy(function () {
						this._data.checkbox.visible = this.settings.checkbox.visible;
						if(!this.settings.checkbox.keep_selected_style) {
							this.element.addClass('jstree-checkbox-no-clicked');
						}
						if(this.settings.checkbox.tie_selection) {
							this.element.addClass('jstree-checkbox-selection');
						}
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
					}, this));
			if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				this.element
					.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
							// only if undetermined is in setting
							if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
							this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
						}, this));
			}
			if(!this.settings.checkbox.tie_selection) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							p = m[data.parent],
							dpc = data.nodes,
							i, j;
						for(i = 0, j = dpc.length; i < j; i++) {
							m[dpc[i]].state.checked = (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
							if(m[dpc[i]].state.checked) {
								this._data.checkbox.selected.push(dpc[i]);
							}
						}
					}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								chd = [],
								c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							if(s.indexOf('down') !== -1) {
								// apply down
								if(p.state[ t ? 'selected' : 'checked' ]) {
									for(i = 0, j = dpc.length; i < j; i++) {
										m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
									}
									this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
								}
								else {
									for(i = 0, j = dpc.length; i < j; i++) {
										if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
											for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
												m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
											}
											this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
										}
									}
								}
							}

							if(s.indexOf('up') !== -1) {
								// apply up
								for(i = 0, j = p.children_d.length; i < j; i++) {
									if(!m[p.children_d[i]].children.length) {
										chd.push(m[p.children_d[i]].parent);
									}
								}
								chd = $.vakata.array_unique(chd);
								for(k = 0, l = chd.length; k < l; k++) {
									p = m[chd[k]];
									while(p && p.id !== '#') {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								m = this._model.data,
								par = this.get_node(obj.parent),
								dom = this.get_node(obj, true),
								i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							// apply down
							if(s.indexOf('down') !== -1) {
								this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = m[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = true;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								while(par && par.id !== '#') {
									c = 0;
									for(i = 0, j = par.children.length; i < j; i++) {
										c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										par.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
										tmp = this.get_node(par, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									par = this.get_node(par.parent);
								}
							}

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
							var obj = this.get_node('#'),
								m = this._model.data,
								i, j, tmp;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								tmp = m[obj.children_d[i]];
								if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
									tmp.original.state.undetermined = false;
								}
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								dom = this.get_node(obj, true),
								i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;
							if(obj && obj.original && obj.original.state && obj.original.state.undetermined) {
								obj.original.state.undetermined = false;
							}

							// apply down
							if(s.indexOf('down') !== -1) {
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = this._model.data[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								for(i = 0, j = obj.parents.length; i < j; i++) {
									tmp = this._model.data[obj.parents[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
									tmp = this.get_node(obj.parents[i], true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
							}
							tmp = [];
							for(i = 0, j = this._data[ t ? 'core' : 'checkbox' ].selected.length; i < j; i++) {
								// apply down + apply up
								if(
									(s.indexOf('down') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.children_d) === -1) &&
									(s.indexOf('up') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.parents) === -1)
								) {
									tmp.push(this._data[ t ? 'core' : 'checkbox' ].selected[i]);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(tmp);

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
							}
						}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
				this.element
					.on('delete_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var p = this.get_node(data.parent),
								m = this._model.data,
								i, j, c, tmp, t = this.settings.checkbox.tie_selection;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									p.state[ t ? 'selected' : 'checked' ] = true;
									this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
									tmp = this.get_node(p, true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
								else {
									break;
								}
								p = this.get_node(p.parent);
							}
						}, this))
					.on('move_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var is_multi = data.is_multi,
								old_par = data.old_parent,
								new_par = this.get_node(data.parent),
								m = this._model.data,
								p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
							if(!is_multi) {
								p = this.get_node(old_par);
								while(p && p.id !== '#') {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}
							p = new_par;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									if(!p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								else {
									if(p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = false;
										this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
								}
								p = this.get_node(p.parent);
							}
						}, this));
			}
		};
		/**
		 * set the undetermined state where and if necessary. Used internally.
		 * @private
		 * @name _undetermined()
		 * @plugin checkbox
		 */
		this._undetermined = function () {
			if(this.element === null) { return; }
			var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
			for(i = 0, j = s.length; i < j; i++) {
				if(m[s[i]] && m[s[i]].parents) {
					for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
						if(o[m[s[i]].parents[k]] === undefined && m[s[i]].parents[k] !== '#') {
							o[m[s[i]].parents[k]] = true;
							p.push(m[s[i]].parents[k]);
						}
					}
				}
			}
			// attempt for server side undetermined state
			this.element.find('.jstree-closed').not(':has(.jstree-children)')
				.each(function () {
					var tmp = tt.get_node(this), tmp2;
					if(!tmp.state.loaded) {
						if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
							if(o[tmp.id] === undefined && tmp.id !== '#') {
								o[tmp.id] = true;
								p.push(tmp.id);
							}
							for(k = 0, l = tmp.parents.length; k < l; k++) {
								if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== '#') {
									o[tmp.parents[k]] = true;
									p.push(tmp.parents[k]);
								}
							}
						}
					}
					else {
						for(i = 0, j = tmp.children_d.length; i < j; i++) {
							tmp2 = m[tmp.children_d[i]];
							if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
								if(o[tmp2.id] === undefined && tmp2.id !== '#') {
									o[tmp2.id] = true;
									p.push(tmp2.id);
								}
								for(k = 0, l = tmp2.parents.length; k < l; k++) {
									if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== '#') {
										o[tmp2.parents[k]] = true;
										p.push(tmp2.parents[k]);
									}
								}
							}
						}
					}
				});

			this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
			for(i = 0, j = p.length; i < j; i++) {
				if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
					s = this.get_node(p[i], true);
					if(s && s.length) {
						s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
					}
				}
			}
		};
		this.redraw_node = function(obj, deep, is_callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var i, j, tmp = null;
				for(i = 0, j = obj.childNodes.length; i < j; i++) {
					if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
						tmp = obj.childNodes[i];
						break;
					}
				}
				if(tmp) {
					if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
					tmp.insertBefore(_i.cloneNode(false), tmp.childNodes[0]);
				}
			}
			if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
				this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
			}
			return obj;
		};
		/**
		 * show the node checkbox icons
		 * @name show_checkboxes()
		 * @plugin checkbox
		 */
		this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
		/**
		 * hide the node checkbox icons
		 * @name hide_checkboxes()
		 * @plugin checkbox
		 */
		this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
		/**
		 * toggle the node icons
		 * @name toggle_checkboxes()
		 * @plugin checkbox
		 */
		this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
		/**
		 * checks if a node is in an undetermined state
		 * @name is_undetermined(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		this.is_undetermined = function (obj) {
			obj = this.get_node(obj);
			var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
			if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
				return false;
			}
			if(!obj.state.loaded && obj.original.state.undetermined === true) {
				return true;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
					return true;
				}
			}
			return false;
		};

		this.activate_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
				e.ctrlKey = true;
			}
			if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
				return parent.activate_node.call(this, obj, e);
			}
			if(this.is_disabled(obj)) {
				return false;
			}
			if(this.is_checked(obj)) {
				this.uncheck_node(obj, e);
			}
			else {
				this.check_node(obj, e);
			}
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		};

		/**
		 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
		 * @name check_node(obj)
		 * @param {mixed} obj an array can be used to check multiple nodes
		 * @trigger check_node.jstree
		 * @plugin checkbox
		 */
		this.check_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.check_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checked) {
				obj.state.checked = true;
				this._data.checkbox.selected.push(obj.id);
				if(dom && dom.length) {
					dom.children('.jstree-anchor').addClass('jstree-checked');
				}
				/**
				 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this check_node
				 * @plugin checkbox
				 */
				this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
		 * @name uncheck_node(obj)
		 * @param {mixed} obj an array can be used to uncheck multiple nodes
		 * @trigger uncheck_node.jstree
		 * @plugin checkbox
		 */
		this.uncheck_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.uncheck_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checked) {
				obj.state.checked = false;
				this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
				if(dom.length) {
					dom.children('.jstree-anchor').removeClass('jstree-checked');
				}
				/**
				 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this uncheck_node
				 * @plugin checkbox
				 */
				this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
		 * @name check_all()
		 * @trigger check_all.jstree, changed.jstree
		 * @plugin checkbox
		 */
		this.check_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.select_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			this._data.checkbox.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name check_all.jstree
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
		};
		/**
		 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
		 * @name uncheck_all()
		 * @trigger uncheck_all.jstree
		 * @plugin checkbox
		 */
		this.uncheck_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = false;
				}
			}
			this._data.checkbox.selected = [];
			this.element.find('.jstree-checked').removeClass('jstree-checked');
			/**
			 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name uncheck_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
		};
		/**
		 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
		 * @name is_checked(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 * @plugin checkbox
		 */
		this.is_checked = function (obj) {
			if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			return obj.state.checked;
		};
		/**
		 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
		 * @name get_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
			return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
		};
		/**
		 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
		 * @name get_top_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_top_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
			var tmp = this.get_checked(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		};
		/**
		 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
		 * @name get_bottom_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_bottom_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
			var tmp = this.get_checked(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		};
		this.load_node = function (obj, callback) {
			var k, l, i, j, c, tmp;
			if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
				tmp = this.get_node(obj);
				if(tmp && tmp.state.loaded) {
					for(k = 0, l = tmp.children_d.length; k < l; k++) {
						if(this._model.data[tmp.children_d[k]].state.checked) {
							c = true;
							this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
						}
					}
				}
			}
			return parent.load_node.apply(this, arguments);
		};
		this.get_state = function () {
			var state = parent.get_state.apply(this, arguments);
			if(this.settings.checkbox.tie_selection) { return state; }
			state.checkbox = this._data.checkbox.selected.slice();
			return state;
		};
		this.set_state = function (state, callback) {
			var res = parent.set_state.apply(this, arguments);
			if(res && state.checkbox) {
				if(!this.settings.checkbox.tie_selection) {
					this.uncheck_all();
					var _this = this;
					$.each(state.checkbox, function (i, v) {
						_this.check_node(v);
					});
				}
				delete state.checkbox;
				this.set_state(state, callback);
				return false;
			}
			return res;
		};
	};

	// include the checkbox plugin by default
	// $.jstree.defaults.plugins.push("checkbox");

/**
 * ### Contextmenu plugin
 *
 * Shows a context menu when a node is right-clicked.
 */

	/**
	 * stores all defaults for the contextmenu plugin
	 * @name $.jstree.defaults.contextmenu
	 * @plugin contextmenu
	 */
	$.jstree.defaults.contextmenu = {
		/**
		 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
		 * @name $.jstree.defaults.contextmenu.select_node
		 * @plugin contextmenu
		 */
		select_node : true,
		/**
		 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
		 * @name $.jstree.defaults.contextmenu.show_at_node
		 * @plugin contextmenu
		 */
		show_at_node : true,
		/**
		 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
		 *
		 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required):
		 *
		 * * `separator_before` - a boolean indicating if there should be a separator before this item
		 * * `separator_after` - a boolean indicating if there should be a separator after this item
		 * * `_disabled` - a boolean indicating if this action should be disabled
		 * * `label` - a string - the name of the action (could be a function returning a string)
		 * * `action` - a function to be executed if this item is chosen
		 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
		 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
		 *
		 * @name $.jstree.defaults.contextmenu.items
		 * @plugin contextmenu
		 */
		items : function (o, cb) { // Could be an object directly
			return {
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
					"label"				: "Create",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.create_node(obj, {}, "last", function (new_node) {
							setTimeout(function () { inst.edit(new_node); },0);
						});
					}
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Rename",
					/*
					"shortcut"			: 113,
					"shortcut_label"	: 'F2',
					"icon"				: "glyphicon glyphicon-leaf",
					*/
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.edit(obj);
					}
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Delete",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						if(inst.is_selected(obj)) {
							inst.delete_node(inst.get_selected());
						}
						else {
							inst.delete_node(obj);
						}
					}
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : {
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.cut(inst.get_top_selected());
								}
								else {
									inst.cut(obj);
								}
							}
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.copy(inst.get_top_selected());
								}
								else {
									inst.copy(obj);
								}
							}
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"_disabled"			: function (data) {
								return !$.jstree.reference(data.reference).can_paste();
							},
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								inst.paste(obj);
							}
						}
					}
				}
			};
		}
	};

	$.jstree.plugins.contextmenu = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			var last_ts = 0, cto = null, ex, ey;
			this.element
				.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
						e.preventDefault();
						last_ts = e.ctrlKey ? +new Date() : 0;
						if(data || cto) {
							last_ts = (+new Date()) + 10000;
						}
						if(cto) {
							clearTimeout(cto);
						}
						if(!this.is_loading(e.currentTarget)) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
							$.vakata.context.hide();
						}
						last_ts = 0;
					}, this))
				.on("touchstart.jstree", ".jstree-anchor", function (e) {
						if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
							return;
						}
						ex = e.pageX;
						ey = e.pageY;
						cto = setTimeout(function () {
							$(e.currentTarget).trigger('contextmenu', true);
						}, 750);
					})
				.on('touchmove.vakata.jstree', function (e) {
						if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.pageX) > 50 || Math.abs(ey - e.pageY) > 50)) {
							clearTimeout(cto);
						}
					})
				.on('touchend.vakata.jstree', function (e) {
						if(cto) {
							clearTimeout(cto);
						}
					});

			/*
			if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
				var el = null, tm = null;
				this.element
					.on("touchstart", ".jstree-anchor", function (e) {
						el = e.currentTarget;
						tm = +new Date();
						$(document).one("touchend", function (e) {
							e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
							e.currentTarget = e.target;
							tm = ((+(new Date())) - tm);
							if(e.target === el && tm > 600 && tm < 1000) {
								e.preventDefault();
								$(el).trigger('contextmenu', e);
							}
							el = null;
							tm = null;
						});
					});
			}
			*/
			$(document).on("context_hide.vakata.jstree", $.proxy(function () { this._data.contextmenu.visible = false; }, this));
		};
		this.teardown = function () {
			if(this._data.contextmenu.visible) {
				$.vakata.context.hide();
			}
			parent.teardown.call(this);
		};

		/**
		 * prepare and show the context menu for a node
		 * @name show_contextmenu(obj [, x, y])
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Object} e the event if available that triggered the contextmenu
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 */
		this.show_contextmenu = function (obj, x, y, e) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var s = this.settings.contextmenu,
				d = this.get_node(obj, true),
				a = d.children(".jstree-anchor"),
				o = false,
				i = false;
			if(s.show_at_node || x === undefined || y === undefined) {
				o = a.offset();
				x = o.left;
				y = o.top + this._data.core.li_height;
			}
			if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
				this.activate_node(obj, e);
			}

			i = s.items;
			if($.isFunction(i)) {
				i = i.call(this, obj, $.proxy(function (i) {
					this._show_contextmenu(obj, x, y, i);
				}, this));
			}
			if($.isPlainObject(i)) {
				this._show_contextmenu(obj, x, y, i);
			}
		};
		/**
		 * show the prepared context menu for a node
		 * @name _show_contextmenu(obj, x, y, i)
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Number} i the object of items to show
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 * @private
		 */
		this._show_contextmenu = function (obj, x, y, i) {
			var d = this.get_node(obj, true),
				a = d.children(".jstree-anchor");
			$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
				var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
				$(data.element).addClass(cls);
			}, this));
			this._data.contextmenu.visible = true;
			$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
			/**
			 * triggered when the contextmenu is shown for a node
			 * @event
			 * @name show_contextmenu.jstree
			 * @param {Object} node the node
			 * @param {Number} x the x-coordinate of the menu relative to the document
			 * @param {Number} y the y-coordinate of the menu relative to the document
			 * @plugin contextmenu
			 */
			this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
		};
	};

	// contextmenu helper
	(function ($) {
		var right_to_left = false,
			vakata_context = {
				element		: false,
				reference	: false,
				position_x	: 0,
				position_y	: 0,
				items		: [],
				html		: "",
				is_visible	: false
			};

		$.vakata.context = {
			settings : {
				hide_onmouseleave	: 0,
				icons				: true
			},
			_trigger : function (event_name) {
				$(document).triggerHandler("context_" + event_name + ".vakata", {
					"reference"	: vakata_context.reference,
					"element"	: vakata_context.element,
					"position"	: {
						"x" : vakata_context.position_x,
						"y" : vakata_context.position_y
					}
				});
			},
			_execute : function (i) {
				i = vakata_context.items[i];
				return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
							"item"		: i,
							"reference"	: vakata_context.reference,
							"element"	: vakata_context.element,
							"position"	: {
								"x" : vakata_context.position_x,
								"y" : vakata_context.position_y
							}
						}) : false;
			},
			_parse : function (o, is_callback) {
				if(!o) { return false; }
				if(!is_callback) {
					vakata_context.html		= "";
					vakata_context.items	= [];
				}
				var str = "",
					sep = false,
					tmp;

				if(is_callback) { str += "<"+"ul>"; }
				$.each(o, function (i, val) {
					if(!val) { return true; }
					vakata_context.items.push(val);
					if(!sep && val.separator_before) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
					}
					sep = false;
					str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
					str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "'>";
					if($.vakata.context.settings.icons) {
						str += "<"+"i ";
						if(val.icon) {
							if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
							else { str += " class='" + val.icon + "' "; }
						}
						str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
					}
					str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
					if(val.submenu) {
						tmp = $.vakata.context._parse(val.submenu, true);
						if(tmp) { str += tmp; }
					}
					str += "<"+"/li>";
					if(val.separator_after) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
						sep = true;
					}
				});
				str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
				if(is_callback) { str += "</ul>"; }
				/**
				 * triggered on the document when the contextmenu is parsed (HTML is built)
				 * @event
				 * @plugin contextmenu
				 * @name context_parse.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
				return str.length > 10 ? str : false;
			},
			_show_submenu : function (o) {
				o = $(o);
				if(!o.length || !o.children("ul").length) { return; }
				var e = o.children("ul"),
					x = o.offset().left + o.outerWidth(),
					y = o.offset().top,
					w = e.width(),
					h = e.height(),
					dw = $(window).width() + $(window).scrollLeft(),
					dh = $(window).height() + $(window).scrollTop();
				// може да се спести е една проверка - дали няма някой от класовете вече нагоре
				if(right_to_left) {
					o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
				}
				else {
					o[x + w + 10 > dw ? "addClass" : "removeClass"]("vakata-context-right");
				}
				if(y + h + 10 > dh) {
					e.css("bottom","-1px");
				}
				e.show();
			},
			show : function (reference, position, data) {
				var o, e, x, y, w, h, dw, dh, cond = true;
				if(vakata_context.element && vakata_context.element.length) {
					vakata_context.element.width('');
				}
				switch(cond) {
					case (!position && !reference):
						return false;
					case (!!position && !!reference):
						vakata_context.reference	= reference;
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
					case (!position && !!reference):
						vakata_context.reference	= reference;
						o = reference.offset();
						vakata_context.position_x	= o.left + reference.outerHeight();
						vakata_context.position_y	= o.top;
						break;
					case (!!position && !reference):
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
				}
				if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
					data = $(reference).data('vakata_contextmenu');
				}
				if($.vakata.context._parse(data)) {
					vakata_context.element.html(vakata_context.html);
				}
				if(vakata_context.items.length) {
					vakata_context.element.appendTo("body");
					e = vakata_context.element;
					x = vakata_context.position_x;
					y = vakata_context.position_y;
					w = e.width();
					h = e.height();
					dw = $(window).width() + $(window).scrollLeft();
					dh = $(window).height() + $(window).scrollTop();
					if(right_to_left) {
						x -= (e.outerWidth() - $(reference).outerWidth());
						if(x < $(window).scrollLeft() + 20) {
							x = $(window).scrollLeft() + 20;
						}
					}
					if(x + w + 20 > dw) {
						x = dw - (w + 20);
					}
					if(y + h + 20 > dh) {
						y = dh - (h + 20);
					}

					vakata_context.element
						.css({ "left" : x, "top" : y })
						.show()
						.find('a').first().focus().parent().addClass("vakata-context-hover");
					vakata_context.is_visible = true;
					/**
					 * triggered on the document when the contextmenu is shown
					 * @event
					 * @plugin contextmenu
					 * @name context_show.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("show");
				}
			},
			hide : function () {
				if(vakata_context.is_visible) {
					vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
					vakata_context.is_visible = false;
					/**
					 * triggered on the document when the contextmenu is hidden
					 * @event
					 * @plugin contextmenu
					 * @name context_hide.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("hide");
				}
			}
		};
		$(function () {
			right_to_left = $("body").css("direction") === "rtl";
			var to = false;

			vakata_context.element = $("<ul class='vakata-context'></ul>");
			vakata_context.element
				.on("mouseenter", "li", function (e) {
					e.stopImmediatePropagation();

					if($.contains(this, e.relatedTarget)) {
						// премахнато заради delegate mouseleave по-долу
						// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						return;
					}

					if(to) { clearTimeout(to); }
					vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

					$(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
					$.vakata.context._show_submenu(this);
				})
				// тестово - дали не натоварва?
				.on("mouseleave", "li", function (e) {
					if($.contains(this, e.relatedTarget)) { return; }
					$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
					$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					if($.vakata.context.settings.hide_onmouseleave) {
						to = setTimeout(
							(function (t) {
								return function () { $.vakata.context.hide(); };
							}(this)), $.vakata.context.settings.hide_onmouseleave);
					}
				})
				.on("click", "a", function (e) {
					e.preventDefault();
				//})
				//.on("mouseup", "a", function (e) {
					if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
						$.vakata.context.hide();
					}
				})
				.on('keydown', 'a', function (e) {
						var o = null;
						switch(e.which) {
							case 13:
							case 32:
								e.type = "mouseup";
								e.preventDefault();
								$(e.currentTarget).trigger(e);
								break;
							case 37:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 38:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 39:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 40:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 27:
								$.vakata.context.hide();
								e.preventDefault();
								break;
							default:
								//console.log(e.which);
								break;
						}
					})
				.on('keydown', function (e) {
					e.preventDefault();
					var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
					if(a.parent().not('.vakata-context-disabled')) {
						a.click();
					}
				});

			$(document)
				.on("mousedown.vakata.jstree", function (e) {
					if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
						$.vakata.context.hide();
					}
				})
				.on("context_show.vakata.jstree", function (e, data) {
					vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
					if(right_to_left) {
						vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
					}
					// also apply a RTL class?
					vakata_context.element.find("ul").hide().end();
				});
		});
	}($));
	// $.jstree.defaults.plugins.push("contextmenu");

/**
 * ### Drag'n'drop plugin
 *
 * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
 */

	/**
	 * stores all defaults for the drag'n'drop plugin
	 * @name $.jstree.defaults.dnd
	 * @plugin dnd
	 */
	$.jstree.defaults.dnd = {
		/**
		 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
		 * @name $.jstree.defaults.dnd.copy
		 * @plugin dnd
		 */
		copy : true,
		/**
		 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
		 * @name $.jstree.defaults.dnd.open_timeout
		 * @plugin dnd
		 */
		open_timeout : 500,
		/**
		 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) - return `false` to prevent dragging
		 * @name $.jstree.defaults.dnd.is_draggable
		 * @plugin dnd
		 */
		is_draggable : true,
		/**
		 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
		 * @name $.jstree.defaults.dnd.check_while_dragging
		 * @plugin dnd
		 */
		check_while_dragging : true,
		/**
		 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
		 * @name $.jstree.defaults.dnd.always_copy
		 * @plugin dnd
		 */
		always_copy : false,
		/**
		 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
		 * @name $.jstree.defaults.dnd.inside_pos
		 * @plugin dnd
		 */
		inside_pos : 0,
		/**
		 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
		 * @name $.jstree.defaults.dnd.drag_selection
		 * @plugin dnd
		 */
		drag_selection : true,
		/**
		 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
		 * @name $.jstree.defaults.dnd.touch
		 * @plugin dnd
		 */
		touch : true,
		/**
		 * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
		 * @name $.jstree.defaults.dnd.large_drop_target
		 * @plugin dnd
		 */
		large_drop_target : false,
		/**
		 * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
		 * @name $.jstree.defaults.dnd.large_drag_target
		 * @plugin dnd
		 */
		large_drag_target : false
	};
	// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
	$.jstree.plugins.dnd = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
					if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
						return true;
					}
					if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
						return true;
					}
					var obj = this.get_node(e.target),
						mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
						txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
					if(this.settings.core.force_text) {
						txt = $.vakata.html.escape(txt);
					}
					if(obj && obj.id && obj.id !== "#" && (e.which === 1 || e.type === "touchstart") &&
						(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]))))
					) {
						this.element.trigger('mousedown.jstree');
						return $.vakata.dnd.start(e, { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] }, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
					}
				}, this));
		};
	};

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			laster = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

		$(document)
			.on('dnd_start.vakata.jstree', function (e, data) {
				lastmv = false;
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.appendTo('body'); //.show();
			})
			.on('dnd_move.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}

				var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm;
				// if we are over an instance
				if(ins && ins._data && ins._data.dnd) {
					marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
					data.helper
						.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
						.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'show' : 'hide' ]();


					// if are hovering the container itself add a new root node
					if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
						ok = true;
						for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
							ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), '#', 'last', { 'dnd' : true, 'ref' : ins.get_node('#'), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
							if(!ok) { break; }
						}
						if(ok) {
							lastmv = { 'ins' : ins, 'par' : '#', 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
							return;
						}
					}
					else {
						// if we are hovering a tree node
						ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = data.event.pageY - off.top;
							h = ref.outerHeight();
							if(rel < h / 3) {
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							$.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										ip = ins.settings.dnd.inside_pos;
										tm = ins.get_node(ref.parent());
										l = off.left - 2;
										t = off.top + h / 2 + 1;
										p = tm.id;
										i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
										break;
									case 'a':
										l = off.left - 6;
										t = off.top + h;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								ok = true;
								for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
									op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
									ps = i;
									if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
										pr = ins.get_node(p);
										if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
											ps -= 1;
										}
									}
									ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
									if(!ok) {
										if(ins && ins.last_error) { laster = ins.last_error(); }
										break;
									}
								}
								if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
									opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
								}
								if(ok) {
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
									laster = {};
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				marker.hide();
			})
			.on('dnd_scroll.vakata.jstree', function (e, data) {
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
			})
			.on('dnd_stop.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide().detach();
				var i, j, nodes = [];
				if(lastmv) {
					for(i = 0, j = data.data.nodes.length; i < j; i++) {
						nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
					}
					lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
				}
				else {
					i = $(data.event.target).closest('.jstree');
					if(i.length && laster && laster.error && laster.error === 'check') {
						i = i.jstree(true);
						if(i) {
							i.settings.core.error.call(this, laster);
						}
					}
				}
			})
			.on('keyup.jstree keydown.jstree', function (e, data) {
				data = $.vakata.dnd._get();
				if(data && data.data && data.data.jstree) {
					data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
				}
			});
	});

	// helpers
	(function ($) {
		$.vakata.html = {
			div : $('<div />'),
			escape : function (str) {
				return $.vakata.html.div.text(str).html();
			},
			strip : function (str) {
				return $.vakata.html.div.empty().append($.parseHTML(str)).text();
			}
		};
		// private variable
		var vakata_dnd = {
			element	: false,
			target	: false,
			is_down	: false,
			is_drag	: false,
			helper	: false,
			helper_w: 0,
			data	: false,
			init_x	: 0,
			init_y	: 0,
			scroll_l: 0,
			scroll_t: 0,
			scroll_e: false,
			scroll_i: false,
			is_touch: false
		};
		$.vakata.dnd = {
			settings : {
				scroll_speed		: 10,
				scroll_proximity	: 20,
				helper_left			: 5,
				helper_top			: 10,
				threshold			: 5,
				threshold_touch		: 50
			},
			_trigger : function (event_name, e) {
				var data = $.vakata.dnd._get();
				data.event = e;
				$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
			},
			_get : function () {
				return {
					"data"		: vakata_dnd.data,
					"element"	: vakata_dnd.element,
					"helper"	: vakata_dnd.helper
				};
			},
			_clean : function () {
				if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				vakata_dnd = {
					element	: false,
					target	: false,
					is_down	: false,
					is_drag	: false,
					helper	: false,
					helper_w: 0,
					data	: false,
					init_x	: 0,
					init_y	: 0,
					scroll_l: 0,
					scroll_t: 0,
					scroll_e: false,
					scroll_i: false,
					is_touch: false
				};
				$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
			},
			_scroll : function (init_only) {
				if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					return false;
				}
				if(!vakata_dnd.scroll_i) {
					vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
					return false;
				}
				if(init_only === true) { return false; }

				var i = vakata_dnd.scroll_e.scrollTop(),
					j = vakata_dnd.scroll_e.scrollLeft();
				vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
				vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
				if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
					/**
					 * triggered on the document when a drag causes an element to scroll
					 * @event
					 * @plugin dnd
					 * @name dnd_scroll.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {jQuery} event the element that is scrolling
					 */
					$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
				}
			},
			start : function (e, data, html) {
				if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
				try {
					e.currentTarget.unselectable = "on";
					e.currentTarget.onselectstart = function() { return false; };
					if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
				} catch(ignore) { }
				vakata_dnd.init_x	= e.pageX;
				vakata_dnd.init_y	= e.pageY;
				vakata_dnd.data		= data;
				vakata_dnd.is_down	= true;
				vakata_dnd.element	= e.currentTarget;
				vakata_dnd.target	= e.target;
				vakata_dnd.is_touch	= e.type === "touchstart";
				if(html !== false) {
					vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
						"display"		: "block",
						"margin"		: "0",
						"padding"		: "0",
						"position"		: "absolute",
						"top"			: "-2000px",
						"lineHeight"	: "16px",
						"zIndex"		: "10000"
					});
				}
				$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				return false;
			},
			drag : function (e) {
				if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(!vakata_dnd.is_down) { return; }
				if(!vakata_dnd.is_drag) {
					if(
						Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
						Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
					) {
						if(vakata_dnd.helper) {
							vakata_dnd.helper.appendTo("body");
							vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
						}
						vakata_dnd.is_drag = true;
						/**
						 * triggered on the document when a drag starts
						 * @event
						 * @plugin dnd
						 * @name dnd_start.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the start (probably mousemove)
						 */
						$.vakata.dnd._trigger("start", e);
					}
					else { return; }
				}

				var d  = false, w  = false,
					dh = false, wh = false,
					dw = false, ww = false,
					dt = false, dl = false,
					ht = false, hl = false;

				vakata_dnd.scroll_t = 0;
				vakata_dnd.scroll_l = 0;
				vakata_dnd.scroll_e = false;
				$($(e.target).parentsUntil("body").addBack().get().reverse())
					.filter(function () {
						return	(/^auto|scroll$/).test($(this).css("overflow")) &&
								(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
					})
					.each(function () {
						var t = $(this), o = t.offset();
						if(this.scrollHeight > this.offsetHeight) {
							if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
							if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
						}
						if(this.scrollWidth > this.offsetWidth) {
							if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
							if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
						}
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = $(this);
							return false;
						}
					});

				if(!vakata_dnd.scroll_e) {
					d  = $(document); w = $(window);
					dh = d.height(); wh = w.height();
					dw = d.width(); ww = w.width();
					dt = d.scrollTop(); dl = d.scrollLeft();
					if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
					if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
					if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
					if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
						vakata_dnd.scroll_e = d;
					}
				}
				if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

				if(vakata_dnd.helper) {
					ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
					hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
					if(dh && ht + 25 > dh) { ht = dh - 50; }
					if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
					vakata_dnd.helper.css({
						left	: hl + "px",
						top		: ht + "px"
					});
				}
				/**
				 * triggered on the document when a drag is in progress
				 * @event
				 * @plugin dnd
				 * @name dnd_move.vakata
				 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
				 * @param {DOM} element the DOM element being dragged
				 * @param {jQuery} helper the helper shown next to the mouse
				 * @param {Object} event the event that caused this to trigger (most likely mousemove)
				 */
				$.vakata.dnd._trigger("move", e);
				return false;
			},
			stop : function (e) {
				if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) {
					/**
					 * triggered on the document when a drag stops (the dragged element is dropped)
					 * @event
					 * @plugin dnd
					 * @name dnd_stop.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused the stop
					 */
					$.vakata.dnd._trigger("stop", e);
				}
				else {
					if(e.type === "touchend" && e.target === vakata_dnd.target) {
						var to = setTimeout(function () { $(e.target).click(); }, 100);
						$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
					}
				}
				$.vakata.dnd._clean();
				return false;
			}
		};
	}($));

	// include the dnd plugin by default
	// $.jstree.defaults.plugins.push("dnd");


/**
 * ### Massload plugin
 *
 * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).
 */

	/**
	 * massload configuration
	 *
	 * It is possible to set this to a standard jQuery-like AJAX config.
	 * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
	 *
	 * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
	 *
	 * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
	 *
	 *	{
	 *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
	 *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
	 *	}
	 * 
	 * @name $.jstree.defaults.massload
	 * @plugin massload
	 */
	$.jstree.defaults.massload = null;
	$.jstree.plugins.massload = function (options, parent) {
		this.init = function (el, options) {
			parent.init.call(this, el, options);
			this._data.massload = {};
		};
		this._load_nodes = function (nodes, callback, is_callback) {
			var s = this.settings.massload;
			if(is_callback && !$.isEmptyObject(this._data.massload)) {
				return parent._load_nodes.call(this, nodes, callback, is_callback);
			}
			if($.isFunction(s)) {
				return s.call(this, nodes, $.proxy(function (data) {
					if(data) {
						for(var i in data) {
							if(data.hasOwnProperty(i)) {
								this._data.massload[i] = data[i];
							}
						}
					}
					parent._load_nodes.call(this, nodes, callback, is_callback);
				}, this));
			}
			if(typeof s === 'object' && s && s.url) {
				s = $.extend(true, {}, s);
				if($.isFunction(s.url)) {
					s.url = s.url.call(this, nodes);
				}
				if($.isFunction(s.data)) {
					s.data = s.data.call(this, nodes);
				}
				return $.ajax(s)
					.done($.proxy(function (data,t,x) {
							if(data) {
								for(var i in data) {
									if(data.hasOwnProperty(i)) {
										this._data.massload[i] = data[i];
									}
								}
							}
							parent._load_nodes.call(this, nodes, callback, is_callback);
						}, this))
					.fail($.proxy(function (f) {
							parent._load_nodes.call(this, nodes, callback, is_callback);
						}, this));
			}
			return parent._load_nodes.call(this, nodes, callback, is_callback);
		};
		this._load_node = function (obj, callback) {
			var d = this._data.massload[obj.id];
			if(d) {
				return this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(function () { return this.nodeType !== 3; }) : d, function (status) {
					callback.call(this, status);
					delete this._data.massload[obj.id];
				});
			}
			return parent._load_node.call(this, obj, callback);
		};
	};

/**
 * ### Search plugin
 *
 * Adds search functionality to jsTree.
 */

	/**
	 * stores all defaults for the search plugin
	 * @name $.jstree.defaults.search
	 * @plugin search
	 */
	$.jstree.defaults.search = {
		/**
		 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results. 
		 * 
		 * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
		 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to 
		 * @name $.jstree.defaults.search.ajax
		 * @plugin search
		 */
		ajax : false,
		/**
		 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
		 * @name $.jstree.defaults.search.fuzzy
		 * @plugin search
		 */
		fuzzy : false,
		/**
		 * Indicates if the search should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.search.case_sensitive
		 * @plugin search
		 */
		case_sensitive : false,
		/**
		 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers). 
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches
		 * @plugin search
		 */
		show_only_matches : false,
		/**
		 * Indicates if the children of matched element are shown (when show_only_matches is true)
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches_children
		 * @plugin search
		 */
		show_only_matches_children : false,
		/**
		 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
		 * @name $.jstree.defaults.search.close_opened_onclear
		 * @plugin search
		 */
		close_opened_onclear : true,
		/**
		 * Indicates if only leaf nodes should be included in search results. Default is `false`.
		 * @name $.jstree.defaults.search.search_leaves_only
		 * @plugin search
		 */
		search_leaves_only : false,
		/**
		 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
		 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
		 * @name $.jstree.defaults.search.search_callback
		 * @plugin search
		 */
		search_callback : false
	};

	$.jstree.plugins.search = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this._data.search.str = "";
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = false;
			this._data.search.smc = false;

			this.element
				.on('before_open.jstree', $.proxy(function (e, data) {
						var i, j, f, r = this._data.search.res, s = [], o = $();
						if(r && r.length) {
							this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
							this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
							if(this._data.search.som && this._data.search.res.length) {
								for(i = 0, j = r.length; i < j; i++) {
									s = s.concat(this.get_node(r[i]).parents);
								}
								s = $.vakata.array_remove_item($.vakata.array_unique(s),'#');
								o = s.length ? $(this.element[0].querySelectorAll('#' + $.map(s, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))) : $();

								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								o = o.add(this._data.search.dom);
								if(this._data.search.smc) {
									this._data.search.dom.children(".jstree-children").find(".jstree-node").show();
								}
								o.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som) {
							if(data.nodes.length) {
								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								if(this._data.search.smc) {
									data.nodes.children(".jstree-children").find(".jstree-node").show();
								}
								data.nodes.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("clear_search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.nodes.length) {
							this.element.find(".jstree-node").css("display","").filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
						}
					}, this));
		};
		/**
		 * used to search the tree nodes for a given string
		 * @name search(str [, skip_async])
		 * @param {String} str the search string
		 * @param {Boolean} skip_async if set to true server will not be queried even if configured
		 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
		 * @param {mixed} inside an optional node to whose children to limit the search
		 * @param {Boolean} append if set to true the results of this search are appended to the previous search
		 * @plugin search
		 * @trigger search.jstree
		 */
		this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
			if(str === false || $.trim(str.toString()) === "") {
				return this.clear_search();
			}
			inside = this.get_node(inside);
			inside = inside && inside.id ? inside.id : null;
			str = str.toString();
			var s = this.settings.search,
				a = s.ajax ? s.ajax : false,
				m = this._model.data,
				f = null,
				r = [],
				p = [], i, j;
			if(this._data.search.res.length && !append) {
				this.clear_search();
			}
			if(show_only_matches === undefined) {
				show_only_matches = s.show_only_matches;
			}
			if(show_only_matches_children === undefined) {
				show_only_matches_children = s.show_only_matches_children;
			}
			if(!skip_async && a !== false) {
				if($.isFunction(a)) {
					return a.call(this, str, $.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append);
							}, true);
						}, this), inside);
				}
				else {
					a = $.extend({}, a);
					if(!a.data) { a.data = {}; }
					a.data.str = str;
					if(inside) {
						a.data.inside = inside;
					}
					return $.ajax(a)
						.fail($.proxy(function () {
							this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
							this.settings.core.error.call(this, this._data.core.last_error);
						}, this))
						.done($.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches, inside, append);
							}, true);
						}, this));
				}
			}
			if(!append) {
				this._data.search.str = str;
				this._data.search.dom = $();
				this._data.search.res = [];
				this._data.search.opn = [];
				this._data.search.som = show_only_matches;
				this._data.search.smc = show_only_matches_children;
			}

			f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
			$.each(m[inside ? inside : '#'].children_d, function (ii, i) {
				var v = m[i];
				if(v.text && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) ) {
					r.push(i);
					p = p.concat(v.parents);
				}
			});
			if(r.length) {
				p = $.vakata.array_unique(p);
				this._search_open(p);
				if(!append) {
					this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
					this._data.search.res = r;
				}
				else {
					this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
					this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
				}
				this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes
			 * @param {String} str the search string
			 * @param {Array} res a collection of objects represeing the matching nodes
			 * @plugin search
			 */
			this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
		};
		/**
		 * used to clear the last search (removes classes and shows all nodes if filtering is on)
		 * @name clear_search()
		 * @plugin search
		 * @trigger clear_search.jstree
		 */
		this.clear_search = function () {
			this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
			if(this.settings.search.close_opened_onclear) {
				this.close_node(this._data.search.opn, 0);
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name clear_search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
			 * @param {String} str the search string (the last search string)
			 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
			 * @plugin search
			 */
			this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
			this._data.search.str = "";
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.dom = $();
		};
		/**
		 * opens nodes that need to be opened to reveal the search results. Used only internally.
		 * @private
		 * @name _search_open(d)
		 * @param {Array} d an array of node IDs
		 * @plugin search
		 */
		this._search_open = function (d) {
			var t = this;
			$.each(d.concat([]), function (i, v) {
				if(v === "#") { return true; }
				try { v = $('#' + v.replace($.jstree.idregex,'\\$&'), t.element); } catch(ignore) { }
				if(v && v.length) {
					if(t.is_closed(v)) {
						t._data.search.opn.push(v[0].id);
						t.open_node(v, function () { t._search_open(d); }, 0);
					}
				}
			});
		};
	};

	// helpers
	(function ($) {
		// from http://kiro.me/projects/fuse.html
		$.vakata.search = function(pattern, txt, options) {
			options = options || {};
			options = $.extend({}, $.vakata.search.defaults, options);
			if(options.fuzzy !== false) {
				options.fuzzy = true;
			}
			pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
			var MATCH_LOCATION	= options.location,
				MATCH_DISTANCE	= options.distance,
				MATCH_THRESHOLD	= options.threshold,
				patternLen = pattern.length,
				matchmask, pattern_alphabet, match_bitapScore, search;
			if(patternLen > 32) {
				options.fuzzy = false;
			}
			if(options.fuzzy) {
				matchmask = 1 << (patternLen - 1);
				pattern_alphabet = (function () {
					var mask = {},
						i = 0;
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] = 0;
					}
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
					}
					return mask;
				}());
				match_bitapScore = function (e, x) {
					var accuracy = e / patternLen,
						proximity = Math.abs(MATCH_LOCATION - x);
					if(!MATCH_DISTANCE) {
						return proximity ? 1.0 : accuracy;
					}
					return accuracy + (proximity / MATCH_DISTANCE);
				};
			}
			search = function (text) {
				text = options.caseSensitive ? text : text.toLowerCase();
				if(pattern === text || text.indexOf(pattern) !== -1) {
					return {
						isMatch: true,
						score: 0
					};
				}
				if(!options.fuzzy) {
					return {
						isMatch: false,
						score: 1
					};
				}
				var i, j,
					textLen = text.length,
					scoreThreshold = MATCH_THRESHOLD,
					bestLoc = text.indexOf(pattern, MATCH_LOCATION),
					binMin, binMid,
					binMax = patternLen + textLen,
					lastRd, start, finish, rd, charMatch,
					score = 1,
					locations = [];
				if (bestLoc !== -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					}
				}
				bestLoc = -1;
				for (i = 0; i < patternLen; i++) {
					binMin = 0;
					binMid = binMax;
					while (binMin < binMid) {
						if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
							binMin = binMid;
						} else {
							binMax = binMid;
						}
						binMid = Math.floor((binMax - binMin) / 2 + binMin);
					}
					binMax = binMid;
					start = Math.max(1, MATCH_LOCATION - binMid + 1);
					finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
					rd = new Array(finish + 2);
					rd[finish + 1] = (1 << i) - 1;
					for (j = finish; j >= start; j--) {
						charMatch = pattern_alphabet[text.charAt(j - 1)];
						if (i === 0) {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
						} else {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
						}
						if (rd[j] & matchmask) {
							score = match_bitapScore(i, j - 1);
							if (score <= scoreThreshold) {
								scoreThreshold = score;
								bestLoc = j - 1;
								locations.push(bestLoc);
								if (bestLoc > MATCH_LOCATION) {
									start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
								} else {
									break;
								}
							}
						}
					}
					if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
						break;
					}
					lastRd = rd;
				}
				return {
					isMatch: bestLoc >= 0,
					score: score
				};
			};
			return txt === true ? { 'search' : search } : search(txt);
		};
		$.vakata.search.defaults = {
			location : 0,
			distance : 100,
			threshold : 0.6,
			fuzzy : false,
			caseSensitive : false
		};
	}($));

	// include the search plugin by default
	// $.jstree.defaults.plugins.push("search");

/**
 * ### Sort plugin
 *
 * Automatically sorts all siblings in the tree according to a sorting function.
 */

	/**
	 * the settings function used to sort the nodes.
	 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
	 * @name $.jstree.defaults.sort
	 * @plugin sort
	 */
	$.jstree.defaults.sort = function (a, b) {
		//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
		return this.get_text(a) > this.get_text(b) ? 1 : -1;
	};
	$.jstree.plugins.sort = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this.element
				.on("model.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, true);
					}, this))
				.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent || data.node.parent, false);
						this.redraw_node(data.parent || data.node.parent, true);
					}, this))
				.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, false);
						this.redraw_node(data.parent, true);
					}, this));
		};
		/**
		 * used to sort a node's children
		 * @private
		 * @name sort(obj [, deep])
		 * @param  {mixed} obj the node
		 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
		 * @plugin sort
		 * @trigger search.jstree
		 */
		this.sort = function (obj, deep) {
			var i, j;
			obj = this.get_node(obj);
			if(obj && obj.children && obj.children.length) {
				obj.children.sort($.proxy(this.settings.sort, this));
				if(deep) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this.sort(obj.children_d[i], false);
					}
				}
			}
		};
	};

	// include the sort plugin by default
	// $.jstree.defaults.plugins.push("sort");

/**
 * ### State plugin
 *
 * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
 */

	var to = false;
	/**
	 * stores all defaults for the state plugin
	 * @name $.jstree.defaults.state
	 * @plugin state
	 */
	$.jstree.defaults.state = {
		/**
		 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
		 * @name $.jstree.defaults.state.key
		 * @plugin state
		 */
		key		: 'jstree',
		/**
		 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
		 * @name $.jstree.defaults.state.events
		 * @plugin state
		 */
		events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
		/**
		 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
		 * @name $.jstree.defaults.state.ttl
		 * @plugin state
		 */
		ttl		: false,
		/**
		 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
		 * @name $.jstree.defaults.state.filter
		 * @plugin state
		 */
		filter	: false
	};
	$.jstree.plugins.state = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			var bind = $.proxy(function () {
				this.element.on(this.settings.state.events, $.proxy(function () {
					if(to) { clearTimeout(to); }
					to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
				}, this));
				/**
				 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
				 * @event
				 * @name state_ready.jstree
				 * @plugin state
				 */
				this.trigger('state_ready');
			}, this);
			this.element
				.on("ready.jstree", $.proxy(function (e, data) {
						this.element.one("restore_state.jstree", bind);
						if(!this.restore_state()) { bind(); }
					}, this));
		};
		/**
		 * save the state
		 * @name save_state()
		 * @plugin state
		 */
		this.save_state = function () {
			var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
			$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
		};
		/**
		 * restore the state from the user's computer
		 * @name restore_state()
		 * @plugin state
		 */
		this.restore_state = function () {
			var k = $.vakata.storage.get(this.settings.state.key);
			if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
			if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
			if(!!k && k.state) { k = k.state; }
			if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
			if(!!k) {
				this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
				this.set_state(k);
				return true;
			}
			return false;
		};
		/**
		 * clear the state on the user's computer
		 * @name clear_state()
		 * @plugin state
		 */
		this.clear_state = function () {
			return $.vakata.storage.del(this.settings.state.key);
		};
	};

	(function ($, undefined) {
		$.vakata.storage = {
			// simply specifying the functions in FF throws an error
			set : function (key, val) { return window.localStorage.setItem(key, val); },
			get : function (key) { return window.localStorage.getItem(key); },
			del : function (key) { return window.localStorage.removeItem(key); }
		};
	}($));

	// include the state plugin by default
	// $.jstree.defaults.plugins.push("state");

/**
 * ### Types plugin
 *
 * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
 */

	/**
	 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
	 *
	 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
	 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
	 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
	 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
	 *
	 * There are two predefined types:
	 *
	 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
	 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
	 *
	 * @name $.jstree.defaults.types
	 * @plugin types
	 */
	$.jstree.defaults.types = {
		'#' : {},
		'default' : {}
	};

	$.jstree.plugins.types = function (options, parent) {
		this.init = function (el, options) {
			var i, j;
			if(options && options.types && options.types['default']) {
				for(i in options.types) {
					if(i !== "default" && i !== "#" && options.types.hasOwnProperty(i)) {
						for(j in options.types['default']) {
							if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
								options.types[i][j] = options.types['default'][j];
							}
						}
					}
				}
			}
			parent.init.call(this, el, options);
			this._model.data['#'].type = '#';
		};
		this.refresh = function (skip_loading, forget_state) {
			parent.refresh.call(this, skip_loading, forget_state);
			this._model.data['#'].type = '#';
		};
		this.bind = function () {
			this.element
				.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							dpc = data.nodes,
							t = this.settings.types,
							i, j, c = 'default';
						for(i = 0, j = dpc.length; i < j; i++) {
							c = 'default';
							if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
								c = m[dpc[i]].original.type;
							}
							if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
								c = m[dpc[i]].data.jstree.type;
							}
							m[dpc[i]].type = c;
							if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
								m[dpc[i]].icon = t[c].icon;
							}
						}
						m['#'].type = '#';
					}, this));
			parent.bind.call(this);
		};
		this.get_json = function (obj, options, flat) {
			var i, j,
				m = this._model.data,
				opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
				tmp = parent.get_json.call(this, obj, opt, flat);
			if(tmp === false) { return false; }
			if($.isArray(tmp)) {
				for(i = 0, j = tmp.length; i < j; i++) {
					tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
					if(options && options.no_id) {
						delete tmp[i].id;
						if(tmp[i].li_attr && tmp[i].li_attr.id) {
							delete tmp[i].li_attr.id;
						}
						if(tmp[i].a_attr && tmp[i].a_attr.id) {
							delete tmp[i].a_attr.id;
						}
					}
				}
			}
			else {
				tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
				if(options && options.no_id) {
					tmp = this._delete_ids(tmp);
				}
			}
			return tmp;
		};
		this._delete_ids = function (tmp) {
			if($.isArray(tmp)) {
				for(var i = 0, j = tmp.length; i < j; i++) {
					tmp[i] = this._delete_ids(tmp[i]);
				}
				return tmp;
			}
			delete tmp.id;
			if(tmp.li_attr && tmp.li_attr.id) {
				delete tmp.li_attr.id;
			}
			if(tmp.a_attr && tmp.a_attr.id) {
				delete tmp.a_attr.id;
			}
			if(tmp.children && $.isArray(tmp.children)) {
				tmp.children = this._delete_ids(tmp.children);
			}
			return tmp;
		};
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
			m = m && m._model && m._model.data ? m._model.data : null;
			switch(chk) {
				case "create_node":
				case "move_node":
				case "copy_node":
					if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
						tmp = this.get_rules(par);
						if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(m && obj.children_d && obj.parents) {
							d = 0;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								d = Math.max(d, m[obj.children_d[i]].parents.length);
							}
							d = d - obj.parents.length + 1;
						}
						if(d <= 0 || d === undefined) { d = 1; }
						do {
							if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							par = this.get_node(par.parent);
							tmp = this.get_rules(par);
							d++;
						} while(par);
					}
					break;
			}
			return true;
		};
		/**
		 * used to retrieve the type settings object for a node
		 * @name get_rules(obj)
		 * @param {mixed} obj the node to find the rules for
		 * @return {Object}
		 * @plugin types
		 */
		this.get_rules = function (obj) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var tmp = this.get_type(obj, true);
			if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
			if(tmp.max_children === undefined) { tmp.max_children = -1; }
			if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
			return tmp;
		};
		/**
		 * used to retrieve the type string or settings object for a node
		 * @name get_type(obj [, rules])
		 * @param {mixed} obj the node to find the rules for
		 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
		 * @return {String|Object}
		 * @plugin types
		 */
		this.get_type = function (obj, rules) {
			obj = this.get_node(obj);
			return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
		};
		/**
		 * used to change a node's type
		 * @name set_type(obj, type)
		 * @param {mixed} obj the node to change
		 * @param {String} type the new type
		 * @plugin types
		 */
		this.set_type = function (obj, type) {
			var t, t1, t2, old_type, old_icon;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_type(obj[t1], type);
				}
				return true;
			}
			t = this.settings.types;
			obj = this.get_node(obj);
			if(!t[type] || !obj) { return false; }
			old_type = obj.type;
			old_icon = this.get_icon(obj);
			obj.type = type;
			if(old_icon === true || (t[old_type] && t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
				this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
			}
			return true;
		};
	};
	// include the types plugin by default
	// $.jstree.defaults.plugins.push("types");

/**
 * ### Unique plugin
 *
 * Enforces that no nodes with the same name can coexist as siblings.
 */

	/**
	 * stores all defaults for the unique plugin
	 * @name $.jstree.defaults.unique
	 * @plugin unique
	 */
	$.jstree.defaults.unique = {
		/**
		 * Indicates if the comparison should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.unique.case_sensitive
		 * @plugin unique
		 */
		case_sensitive : false,
		/**
		 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
		 * @name $.jstree.defaults.unique.duplicate
		 * @plugin unique
		 */
		duplicate : function (name, counter) {
			return name + ' (' + counter + ')';
		}
	};

	$.jstree.plugins.unique = function (options, parent) {
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			if(!par || !par.children) { return true; }
			var n = chk === "rename_node" ? pos : obj.text,
				c = [],
				s = this.settings.unique.case_sensitive,
				m = this._model.data, i, j;
			for(i = 0, j = par.children.length; i < j; i++) {
				c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
			}
			if(!s) { n = n.toLowerCase(); }
			switch(chk) {
				case "delete_node":
					return true;
				case "rename_node":
					i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "create_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "copy_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "move_node":
					i = ( (obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
			}
			return true;
		};
		this.create_node = function (par, node, pos, callback, is_loaded) {
			if(!node || node.text === undefined) {
				if(par === null) {
					par = "#";
				}
				par = this.get_node(par);
				if(!par) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				if(!node) { node = {}; }
				var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
				n = tmp = this.get_string('New node');
				dpc = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
				}
				i = 1;
				while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
					n = cb.call(this, tmp, (++i)).toString();
				}
				node.text = n;
			}
			return parent.create_node.call(this, par, node, pos, callback, is_loaded);
		};
	};

	// include the unique plugin by default
	// $.jstree.defaults.plugins.push("unique");


/**
 * ### Wholerow plugin
 *
 * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
 */

	var div = document.createElement('DIV');
	div.setAttribute('unselectable','on');
	div.setAttribute('role','presentation');
	div.className = 'jstree-wholerow';
	div.innerHTML = '&#160;';
	$.jstree.plugins.wholerow = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('ready.jstree set_state.jstree', $.proxy(function () {
						this.hide_dots();
					}, this))
				.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
						//div.style.height = this._data.core.li_height + 'px';
						this.get_container_ul().addClass('jstree-wholerow-ul');
					}, this))
				.on("deselect_all.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
					}, this))
				.on("changed.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						var tmp = false, i, j;
						for(i = 0, j = data.selected.length; i < j; i++) {
							tmp = this.get_node(data.selected[i], true);
							if(tmp && tmp.length) {
								tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
							}
						}
					}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
						this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
					}, this))
				.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
						if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
						this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
					}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
						e.preventDefault();
						var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
					}, this))
				/*!
				.on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
						if(e.target === e.currentTarget) {
							var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
							e.target = a[0];
							a.trigger(e);
						}
					})
				*/
				.on("click.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					}, this))
				.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if(!this.is_disabled(e.currentTarget)) {
							this.hover_node(e.currentTarget);
						}
						return false;
					}, this))
				.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		};
		this.teardown = function () {
			if(this.settings.wholerow) {
				this.element.find(".jstree-wholerow").remove();
			}
			parent.teardown.call(this);
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var tmp = div.cloneNode(true);
				//tmp.style.height = this._data.core.li_height + 'px';
				if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
				if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
				obj.insertBefore(tmp, obj.childNodes[0]);
			}
			return obj;
		};
	};
	// include the wholerow plugin by default
	// $.jstree.defaults.plugins.push("wholerow");
	if(document.registerElement && Object && Object.create) {
		var proto = Object.create(HTMLElement.prototype);
		proto.createdCallback = function () {
			var c = { core : {}, plugins : [] }, i;
			for(i in $.jstree.plugins) {
				if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
					c.plugins.push(i);
					if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
						c[i] = JSON.parse(this.getAttribute(i));
					}
				}
			}
			for(i in $.jstree.defaults.core) {
				if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
					c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
				}
			}
			$(this).jstree(c);
		};
		// proto.attributeChangedCallback = function (name, previous, value) { };
		try {
			document.registerElement("vakata-jstree", { prototype: proto });
		} catch(ignore) { }
	}

}));

// 不管外面怎么调用，其实只让他new 一次即可，可是事件的话，因为在有的应用中不需要事件，要不将事件标记加到tree的data上

it.TreeView = function(mainPane){
    this.mainPane = mainPane;
    if(!this.mainPane){
        this.mainPane = $('body');
    }
    var self = this;
    this.treeView = $('<div id = "plugin_tree_view_id" class="black-font-color"></div>');
        // on事件一开始就加上，只要添加一次即可，如果在setData的时候则会出现添加多次的情况
    this.treeView
        .on("changed.jstree", function(e, data){
            self.clickNode(e, data);
        })
        .on("hover_node.jstree", function(e, data){
            self.mouseover(e, data);
        })
        .jstree({
                'core' : {
                    'data' : [],
                    "themes": { "theme": "default", "dots": false, "icons": true } //"dots": false,
               }
       });
    this.treePane = $('<div id="tree-content" class="scroll-class" style="height:100px;overflow:auto; position: relative;display: block;top:15px"></div>');
    this.treePane.append(this.treeView);
    this.mainPane.append(this.treePane);
    this.dataSet = null;

    this.clickNodeFunction = null;
    this.mouseoverNodeFunction = null;
    this.sortFunction = null;

};

mono.extend(it.TreeView,Object,{

    isClick : function(data){
        return true;
    },

    clickNode : function(e, data){
        if(data.selected.length) {
            var asset = data.instance.get_node(data.selected[0]);
            if(asset.select_flag){ // 如果是联动选中的标记的话，就直接返回
                delete asset.select_flag;
                return;
            }
            if(asset.original) {
                if(this.clickNodeFunction){
                    this.clickNodeFunction(asset.original,data);
                }
            }
        }
    },

    mouseover : function(e,data){
        if(!data || !data.node || !data.node.original){
            return ;
        }
        if(this.mouseoverNodeFunction){
            this.mouseoverNodeFunction(data.node.original);
        }
        var tooltopText = data.node.original.text;
        if(tooltopText){
            tooltopText = tooltopText.replace('<label color=#F00>','');
            tooltopText = tooltopText.replace('</label>','');
            var nodeId = data.node.id;
            if (nodeId) {
                nodeId = nodeId.replaceAll('/','\\/');
                // nodeId = nodeId.replace('\\','\\\\');
                nodeId = nodeId.replaceAll('@','\\@');
            }
            $("#"+nodeId).prop('title',tooltopText);
        }
    },

    isSortById : function(){
        return false;
    },

    /**
     * tree的排序
     * @param treeNode1 是tree结点的类型
     * @param treeNode2 是tree结点的类型
     * @returns {number}
     */
    sort: function(treeNode1, treeNode2) {
        if (this.sortFunction) {
            return this.sortFunction(treeNode1, treeNode2);
        }
        // if (treeNode1 && treeNode2 && treeNode1.text && treeNode2.text) {
        //     if (treeNode1.text > treeNode2.text) {
        //         return 1;
        //     }else if (treeNode2.text > treeNode1.text) {
        //         return -1;
        //     }else {
        //         return 0;
        //     }
        // }
        // return 0;
        var text1, text2;
        if (treeNode1) {
            if (this.isSortById()) {
                text1 = treeNode1.id;
            } else {
                text1 = treeNode1.text;
            }
        } else {
            text1 = treeNode1;
        }
        if (treeNode2) {
            if (this.isSortById()) {
                text1 = treeNode2.id;
            } else {
                text2 = treeNode2.text;
            }
        } else {
            text2 = treeNode2;
        }
        return it.Util.compare(text1, text2);
    },

    /**
     * 往tree中添加数据
     * @param data{[]} 数据集合
     * @param withIcon 是否显示图标，true显示图标，false不显示图标
     */
    setData: function (data, withIcon) {
        if(!this.dataSet && !data) return ;
        this.dataSet = data;
        if (this.treeView.jstree(false)
            && this.treeView.jstree(false)._model
            && this.treeView.jstree(false)._model.data) {
            this.treeView.jstree(false)._model.data = {}; //需要手动的清空一下model
        }
        this.treeView.data('jstree', false).empty();
        if (!data) return;
        var icons = true;
        if (withIcon != undefined) {
            icons = withIcon;
        }

        var self = this;

        this.treeView.data('jstree', false).empty()
            .jstree({
                'core': {
                    'data': data,
                    "themes": { "theme": "default", "dots": true, "icons": icons } //"dots": false
                },

                "plugins": ["sort"],

                'sort': function (a, b) {
                    var a_org_node = this.get_node(a) ? this.get_node(a).original : null;
                    var b_org_node = this.get_node(b) ? this.get_node(b).original : null;
                    return self.sort(a_org_node,b_org_node);
                }

            });

    },

    setSelectNode : function(nodeId){
        if (!nodeId) return;
        var mainTree = this.treeView.jstree(true);
        var var_node = mainTree.get_node(nodeId);
        if (var_node) {
            var_node.select_flag = true; // 设置一个标记,标记这个后，然后在选中的时候，可以根据该标记决定是否要触发选中事件
        }
        mainTree.deselect_all();
        mainTree.select_node(nodeId);
        this.scrollTreeByNodeId(nodeId);
    },

    getNodeById : function(nodeId){
        if (!nodeId) return;
        var mainTree = this.treeView.jstree(true);
        return mainTree.get_node(nodeId);
    },

    clearTreeData: function () {
        this.treeView.data('jstree', false).empty();
    },

    show: function () {
        this.treeView.show();
    },

    hidden: function () {
        this.treeView.hide();
    },

    /**
     * 展开
     * @param idOrNode
     */
    open : function(idOrNode){

    },

    /**
     * 合并
     * @param idOrNode
     */
    close : function(idOrNode){

    },

    /**
     * 滚动滚动条，使得选中的对象在可视范围内，在联动选中时要用到，这改的是绝对的位置，应该是滚动滚动条至某地
     * @param nodeId
     */
    scrollTreeByNodeId: function (nodeId) {
        if (!nodeId) return;
        var div_select_row = $('#' + nodeId);
        if (!div_select_row || div_select_row.length < 1) {
            return;
        }

        var min_top_offset =  0;
        if(this.treePane.parent() && this.treePane.parent().height() > 0){
            min_top_offset = this.treePane.parent().height() - this.treePane.height();
        }

        var tree_content = this.treePane; // $('#tree-content');
        var tree_content_height = tree_content[0].clientHeight;//$('#tree-content').height();
        if (!tree_content_height) {
            tree_content_height = 400;
        }
        var select_row_offset_top = 0;
        if (div_select_row.offset()) {
            select_row_offset_top = div_select_row.offset().top;
        }

        if (select_row_offset_top < min_top_offset) { // 也就是选中的row跑到了显示区域上面去了，此时整tree应该下移，下移就是+差值
            var new_scrollTop = tree_content.scrollTop() - (min_top_offset - select_row_offset_top);
            if (new_scrollTop) {
                tree_content.scrollTop(new_scrollTop);
            }
        } else if (select_row_offset_top > tree_content_height + min_top_offset) {
            //表示选中的行已经跑到了显示区域的下方,此时整个tree往上滚，上移是-差值
            var new_scrollTop = tree_content.scrollTop() + (select_row_offset_top - (tree_content_height + min_top_offset) + 70 );
            if (new_scrollTop) {
                tree_content.scrollTop(new_scrollTop);
            }
        }
    },

    /**
     * 设置树的height
     * @private
     */
    setTreeHeight: function (height) {
        if(height && height > 15){
            this.treePane.height(height-15);
        }
    }

});


/**
 * 将数值组织成树的管理类
 */
/**
 *
 * @param dataManager
 * @param dataType 数据类型，it.Data，it.Link
 * @constructor
 */
it.OrganizeTreeManager = function(dataManager,dataType){
    if(!dataManager){
        console.log('dataManager can not be null');
    }
    this.dataManager = dataManager;
    this.dataType = dataType;
};

mono.extend(it.OrganizeTreeManager,Object,{

    includeParent : function(data){
        return true;
    },

    getDataByNode : function(treeNode){
        if(treeNode && treeNode.id){
            return this.getDataById(treeNode.id);
        }
        return null;
    },

    /**
     * 便于其他的类型进行扩展
     * @param id
     * @returns {*}
     */
    getDataById : function(id){
        if(!id) return null;
        if(this.dataType && this.dataType === 'link'){
            return this.dataManager.getLinkById(id);
        }else{
            return this.dataManager.getDataById(id);
        }
    },

    isOpen : function(data){
        return true;
    },

    /**
     * 创建显示的内容
     * @param data
     * @returns {*}
     */
    createLabel : function(data){
        if(data){
            return data.getId();
        }else{
            return "";
        }
    },

    /**
     * 便于其他的类型进行扩展
     * @param data
     * @returns {*}
     */
    getParentIdByData : function(data){
        if(!data){
            return null;
        }
        if(data instanceof it.Link){
            return null;
        }else{
            return data.getParentId();
        }
    },

    /**
     * 创建tree的结点
     * @param data
     * @param children
     * @returns {*}
     */
    createNode : function(data,children){
        if(data){
//            var obj = {id:data.getId(),text:data.getId(),parentId:data.getParentId(),o_data:data};
            var obj = {id:data.getId(),text:this.createLabel(data),parentId:this.getParentIdByData(data)};
            if(children){
                obj.children = children;
            }else{
                obj.children = [];
            }
            if(this.isOpen(data)){
                var state = obj.state;
                if(state){
                    state['opened'] = true;
                }else{
                    obj.state = {"opened":true};
                }
            }
            return obj;
        }
        return null;
    },

    /**
     * 给树的node添加孩子
     * @param data
     * @param child
     */
    addChild : function(node,child){
        if(!node || !child){
            return node;
        }
        var children = this.getChildren(node);
        if(children){
            children.push(child);
        }else {
            node.children = [child];
        }
        return node;
    },

    /**
     * 获取树节点的孩子
     * @param node
     */
    getChildren : function(node){
        return node.children;
    },

    /**
     * 针对当前的搜索数据组织成树，这里可以单独的封装一把
     *
     * 基本思想：
     * 1、遍历datas，找到data的parentid，
     * 2、找到parentid的data，如果没有则new一个；
     * 3、将自己加到parentid的data的孩子中；
     * 4、如果没有parent，那就将其置为root；
     * 5、有个选择是，是否添加其parent，如果不添加的话，那就将其置成其parent‘s parent的孩子，依次往上
     *
     * 至少要遍历两次：第一次计算其parent，第二次组织成树
     *
     */
    organizeTree : function(datas){
        if(!datas || datas.length < 1) return null;
        var results = {}; //obj = {id:id,data:data,children:children}
        for(var i = 0 ; i < datas.length ; i++){
            var data = datas[i];
            if(!data) continue;
            var obj = this.createNode(data);
            results[data.getId()] = obj;
        }
        var treeData = [];
        var treeMap = it.Util.clone(results);
        for(var id in results){
//            var obj = results[id];
            var obj = treeMap[id]; // treeMap的范围要打印results,因为其包含了parent，并且treeData中的数据来自treeMap
            this.organizeParent(obj,treeData,treeMap);
        }
        return treeData;
    },

    /**
     * 将obj加到树上，没有父亲的话就是根
     * @param obj
     * @param treeData
     * @param treeMap
     * @returns {root} ，组织好后，并返回其root
     */
    organizeParent : function(obj,treeData,treeMap){
        if(!obj) return null;
        var pid = obj.parentId;
        if(!pid){
            treeData.push(obj);
            return obj;
        }
        var parent = treeMap[pid]; // 看看搜索的结果中是否包含其parent
        if(parent){
            this.addChild(parent,obj);
        }else if(this.includeParent(obj.data)){
            var parentData = this.getDataById(pid);
            if(!parentData){
                treeData.push(obj);
            }else{
                var pObj = this.createNode(parentData,[obj]);
                treeMap[parentData.getId()] = pObj;
                this.organizeParent(pObj,treeData,treeMap,this);
            }
        }else{ // 找往上data的祖宗
            var ancestorObj = this.getAncestorInTreeMap(pid,treeMap);
            if(ancestorObj){
                this.addChild(ancestorObj,obj);
            }else{
                treeData.push(obj);
            }
        }
    },

    /**
     * 找其祖宗节点
     * @param parentid
     * @param treeMap
     * @returns {*}
     */
    getAncestorInTreeMap : function(parentid,treeMap){
        if(!parentid || !treeMap) return null;
        if(treeMap[parentid]){
            return treeMap[parentid];
        }else{
            var parentData = this.getDataById(parentid);
            if(!parentData || !this.getParentIdByData(parentData)){
                return null;
            }else{
                return this.getAncestorInTreeMap(this.getParentIdByData(parentData),treeMap,this);
            }
        }
    }

});
/**
 * Created by macpro2 on 7/7/15.
 */
/* 图例 */

var $Diagram = function (options) {
    options = options || {};
    this.diagramPane = $('<div class="diagram"></div>');
    if(options.width){
        this.diagramPane.css('width', options.width)
    }
    this.diagramContentPane = $('<div class="diagram-content"></div>'); //用来放item的div
    var main = $('#itv-main');
    main.append(this.diagramPane);
    this.serialNumColorMap = {};
    this.num = 1; //单位数量(即每个单位对应的U数，非连续的就为1)
    this.hideDiagram();
};

mono.extend($Diagram, Object, {

    /**
     * @param data[{color:#00000,value:0-5},...]
     */
    setData: function (datas, titleText, mouseOverCb, mouseoutCb) {
        if (!datas || datas.length < 1) {
            return;
        }
        this.diagramPane.empty();
        this.diagramContentPane.empty();
        this.diagramPane.show();
        if (!titleText) {
            titleText = '连续可用空间图例';
        }
        var title = $('<div class="title">' + titleText + '</div>');
        this.diagramPane.append(title);
        this.diagramPane.append(this.diagramContentPane);
        // var width = 100 / datas.length + '%';
        if (datas instanceof Array) {
            for (var i = 0; i < datas.length; i++) {
                var data = datas[i];
                this.createItem(data);//, width
            }
        }
        if(mouseOverCb){
            this.diagramPane.mouseover(function(event) {
                var $target = $(event.target).parent();
                if($target.hasClass('diagram-item')){
                    var index = $target.index();
                    mouseOverCb(index, $target);
                }
            });
        }
        if(mouseoutCb){
            this.diagramPane.mouseout(function(event) {
                var $target = $(event.target).parent();
                if($target.hasClass('diagram-item')){
                    var index = $target.index();
                    mouseoutCb(index, $target);
                }
            });
        }
        
    },

    createItem: function (data) {
        if (!data) return;
        var value = data.value;
        var color = data.color;
        var width = data.width;
        if (!value || !color) {
            return;
        }
        var row = $('<div class="diagram-item"></div>');
        // row.css('width', width); //不再均分了，而是自动布局,但是为了扩展也支持传参 update by Kevin 2016-11-23
        if (width) {
            row.css('width', width);
        }
        var div_color = $('<div class="cl"></div>');
        div_color.css('background-color', color);
        row.append(div_color);
        var label_Name = $('<label class="lb">' + value + '</label>');
        row.append(label_Name);
        this.diagramContentPane.append(row);
    },

    /**
     *
     * @param num 表示连续可用的空间，47U
     * 剩余的个数越少，颜色就越接近与红色
     */
    showSerialDiagram: function (num) {
        var datas = [];
        this.serialNumColorMap = {};
        num = parseInt(num);
        if (!num) {
            num = 1;
        }
        this.num = num;
        var total_count = Math.floor(47 / num);
        var unit_count = Math.floor(total_count / 4); //ceil

        var color = this.getCapacityColor(null, 0.1);
        var data = {color: color, value: (unit_count * 3 + 1) + '-' + total_count};
        if (total_count <= 4) {
            data.value = total_count;
            this.serialNumColorMap[total_count] = color;
        } else {
            for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
                this.serialNumColorMap[i] = color;
            }
        }

        datas.push(data);


        color = this.getCapacityColor(null, 0.3);
        data = {color: color, value: (unit_count * 2 + 1) + '-' + (unit_count * 3)};
        if (total_count > 1 && total_count <= 4) {
            data.value = total_count - 1;
            this.serialNumColorMap[total_count - 1] = color;
        } else {
            for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 1) {
            datas.push(data);
        }


        color = this.getCapacityColor(null, 0.6);
        data = {color: color, value: (unit_count + 1) + '-' + (unit_count * 2)};
        if (total_count > 2 && total_count <= 4) {
            data.value = total_count - 2;
            this.serialNumColorMap[total_count - 2] = color;
        } else {
            for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 2) {
            datas.push(data);
        }

        color = this.getCapacityColor(null, 0.8);
        data = {color: color, value: '1-' + unit_count};
        if (total_count > 3 && total_count <= 4) {
            data.value = total_count - 3;
            this.serialNumColorMap[total_count - 3] = color;
        } else {
            for (var i = 1; i <= unit_count; i++) {
                this.serialNumColorMap[i] = color;
            }
        }
        if (total_count > 3) {
            datas.push(data);
        }

        this.setData(datas, '连续可用空间图例');
    },


//value 表示的是已用的
    showTotalSpaceDiagram: function () {
        var datas = [];
        this.num = 1;
        var color = this.getCapacityColor(null, 0.1);
        var data = {color: color, value: '1-25%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.3);
        data = {color: color, value: '25-50%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.6);
        data = {color: color, value: '50-75%'};
        datas.push(data);
        color = this.getCapacityColor(null, 0.8);
        data = {color: color, value: '75-100%'};
        datas.push(data);
        this.setData(datas, '非连续可用空间图例');
    },

    hideDiagram: function () {
        this.diagramPane.empty();
        this.diagramPane.hide();
    },

    getCapacityColor: function (rack, ratio) {
        // ratio 表示的是已用的百分比
        if (!ratio) {
            return '#5DBDE0';//'#BEEB9F';
        } else if (ratio <= 0.25) {
            return '#5DBDE0';//'#BEEB9F'; 绿
        } else if (ratio <= 0.5) {
            return '#6FD772';  // FFFF99 黄
        } else if (ratio <= 0.75) {
            return '#FFC95A';//'#FFBB11'; 橙
        } else {
            return '#Fd674F';// FF3357 '#FF6138'; //红色，表示已用的很多
        }
    }

});

it.Diagram = $Diagram;







/**
 * 搜索管理，IT搜索于空间搜索切换
 * 这个比较复杂，想实现一个功能的话，还非得把两个功能都实现，建议客户重新组织，
 * 可以通过SpaceSearchManager和ITSearchManager来自己去实现
 * @param sceneManager
 * @param itSearchInputPanel
 * @param spaceSearchInputPanel
 * @constructor
 */

it.SearchManager = function(sceneManager,itSearchInputPanel,spaceSearchInputPanel,spaceMode){
    this.sceneManager = sceneManager;
    this.itSearchManager = null;//new it.ITSearchManager(this.sceneManager);
    this.spaceSearchManager = null;//new it.SpaceSearchManager(this.sceneManager);
    this.itSearchInputPanel = itSearchInputPanel;
    this.spaceSearchInputPanel = spaceSearchInputPanel;
    this.showModel = '';
    this.spaceMode = spaceMode || 1;
    this.init();
};

mono.extend(it.SearchManager,Object,{

    init : function(){
        this.spaceSearchManager = new it.SpaceSearchManager(this.sceneManager,this.spaceSearchInputPanel,this.spaceMode);
        this.itSearchManager = new it.ITSearchManager(this.sceneManager,this.itSearchInputPanel);
        this.itSearchManager.clearAll(); // 切换前，先清除
        this.itSearchManager.clearAllVirtual();
        this.itSearchManager.hide();
        this.spaceSearchManager.clearAll(); // 切换前，先清除
        this.spaceSearchManager.clearAllVirtual();
        this.spaceSearchManager.hide();
    },

    /**
     * 显示IT搜索
     */
    showITSearch : function(){
        this.switch(false);
    },

    /**
     * 隐藏IT搜索
     */
    hideITSearch : function(){
        if(this.itSearchManager){
            this.itSearchManager.clearAll(); // 切换前，先清除
            this.itSearchManager.clearAllVirtual();
            this.itSearchManager.hide();
        }
    },

    /**
     * 显示空间搜索
     */
    showSpaceSearch : function(){
        this.switch(true);
    },

    /**
     * 隐藏空间搜索
     */
    hideSpaceSearch : function(){
        if(this.spaceSearchManager){
            this.spaceSearchManager.clearAll(); // 切换前，先清除
            this.spaceSearchManager.clearAllVirtual();
            this.spaceSearchManager.hide();
        }
    },

    /**
     * 空间搜索和资产搜索之间的切换，显示资产搜索时就会将空间搜索隐藏掉，显示空间搜索时资产搜索会被隐藏
     * @param isSpace
     */
    switch : function(isSpace){
        if (isSpace) {
            if (this.showModel === 'S') {
                return;
            }
            this.showModel = 'S';
            this.itSearchManager.clearAll(); // 切换前，先清除
            this.itSearchManager.clearAllVirtual();
            this.itSearchManager.hide();
            this.spaceSearchManager.virtualAllNodes();
            this.spaceSearchManager.setupInit();
            this.spaceSearchManager.show();
        } else {
            if (this.showModel === 'IT') {
                return ;
            }
            this.showModel = 'IT';
            this.spaceSearchManager.clearAll(); // 切换前，先清除
            this.spaceSearchManager.clearAllVirtual();
            this.spaceSearchManager.clearInit();
            this.spaceSearchManager.hide();
            this.itSearchManager.show();
        }
    },

    getITSearchTree : function(){
        if(this.itSearchManager){
            return this.itSearchManager.getTreeView();
        }
        return null;
    },

    getSpaceSearchTree : function(){
        if(this.spaceSearchManager){
           return this.spaceSearchManager.getTreeView();
        }
        return null;
    },

    getITSearchOrganizeTreeManager : function(){
        if(this.itSearchManager){
            return this.itSearchManager.getOrganizeTreeManager();
        }
        return null;
    },

    getSpaceSearchOrganizeTreeManager : function(){
        if(this.spaceSearchManager){
            return this.spaceSearchManager.getOrganizeTreeManager();
        }
        return null;
    },

    setPanelLocation:function(obj){
        this.setITSearchPanelLocation(obj);
        this.setSpaceSearchPanelLocation(obj);
    },

    setITSearchPanelLocation : function(obj){
        var searPanel = this.itSearchManager.searPanel;
        if(obj){
            searPanel.css('left','auto');
            searPanel.css('right','auto');
            searPanel.css('bottom','auto');
            searPanel.css('top','auto');
            if(obj.left != null && obj.left != undefined){
                searPanel.css('left',parseInt(obj.left)+'px');
            }
            if(obj.right != null && obj.right != undefined){
                searPanel.css('right',parseInt(obj.right)+'px');
            }
            if(obj.bottom != null && obj.bottom != undefined){
                searPanel.css('bottom',parseInt(obj.bottom)+'px');
            }
            if(obj.top != null && obj.top != undefined){
                searPanel.css('top',parseInt(obj.top)+'px');
            }
        }
    },

    setSpaceSearchPanelLocation : function(obj){
        var searPanel = this.spaceSearchManager.searPanel;
        if(obj){
            searPanel.css('left','auto');
            searPanel.css('right','auto');
            searPanel.css('bottom','auto');
            searPanel.css('top','auto');
            if(obj.left != null && obj.left != undefined){
                searPanel.css('left',parseInt(obj.left)+'px');
            }
            if(obj.right != null && obj.right != undefined){
                searPanel.css('right',parseInt(obj.right)+'px');
            }
            if(obj.bottom != null && obj.bottom != undefined){
                searPanel.css('bottom',parseInt(obj.bottom)+'px');
            }
            if(obj.top != null && obj.top != undefined){
                searPanel.css('top',parseInt(obj.top)+'px');
            }
        }
    },

    getItSearchPane : function(){
        return this.itSearchManager.searPanel;
    },

    getSpaceSearchPane : function(){
        return this.spaceSearchManager.searPanel;
    },

    setParent : function(parent){
        if(parent && $(parent)){
            parent = $(parent);
            parent.append(this.itSearchManager.searPanel);
            parent.append(this.spaceSearchManager.searPanel);
        }else{
            $('body').append(this.itSearchManager.searPanel);
            $('body').append(this.spaceSearchManager.searPanel);
        }
    }

});

// /**
//  *
//  * @param sceneManager
//  * @param inputPane
//  * @constructor
//  */
// it.BaseSearch = function(sceneManager,inputPane){
//     if(!sceneManager) {
//         console.error("agument sceneManager can not be null");
//         return;
//     }
//     this.sceneManager = sceneManager;
//     this.dataManager = this.sceneManager.dataManager;
//     this.dataFinder = new it.DataFinder(this.sceneManager.dataManager);
//     var self = this;
//     this.dataFinder.filter = function(data){
//         return self.filter(data);
//     };
// //    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
//     this.virtualManager = this.getVirtualManager() || new it.VirtualManager(sceneManager);
//     this.virtualManager.isDealWithFunction = function(data){ // 如果是房间的话则不出来透明
//         if(!data) return false;
//         var category = self.dataManager.getCategoryForData(data);
//         if(category
//             && category.getId().indexOf('room') >=0 ){
//             return false;
//         }
//         return true;
//     }
//     this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
//     this.treeView = null;
//     this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
//     this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
//     this.inputPane = inputPane||this.createInputPane();
//     this.searPanel = null;
//     this.clearAllFunction = null;
//     this.initSearchPane();
// };

// mono.extend(it.BaseSearch,Object,{

//     createInputPane : function(){
//         return new it.BasePanel();
//     },

//     getVirtualManager : function(){
//         return new it.VirtualManager(this.sceneManager);
//     },

//     removeVirtualManager : function(){
//         this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualManager);
//     },

//     filter:function(data){
//        return true;
//     },

//     clearAllVirtual : function(){
//         this.virtualManager.clearAll();
//     },

//     initSearchPane : function(){
//         this.searPanel = $('.search-main-pane');
//         var paneIndex = 0;
//         if(this.searPanel && this.searPanel.length > 0){
//             paneIndex = this.searPanel.length;
//         }
//         this.searPanel = $('<div id = "search-main-pane_'+paneIndex+'" class="search-main-pane"></div>');
// //        this.searPanel.css('left',10);
// //        this.searPanel.css('top',10);
//         this.searPanel.append(this.inputPane.getContentPane());
//         this.treeView = new it.TreeView(this.searPanel);
// //        $('body').append(this.searPanel);
//         var self = this;
//         this.treeView.clickNodeFunction = function(treeData){
//             self.clickTreeNode(treeData);
//         };

//         this.treeView.mouseoverNodeFunction = function(treeData){
//             self.mouseOverTreeNode(treeData);
//         };

//         this.inputPane.doClickFunction = function(values){
// //            var values = [{key:'u:userId',value:'aaa',operation:'like'}];
//             self.beforeDoClick();
//             self.setData(values);
//             var height = self.searPanel.height() - self.inputPane.getContentPane().height();
//             self.treeView.setTreeHeight(height);
//         };

//         this.inputPane.doClearFunction = function(){
//             self.clearSearch();
//         };
//     },

//     beforeDoClick : function(){

//     },

//     show : function(){
//         this.searPanel.show();
//     },

//     beforHide : function(){

//     },

//     hide : function(){
//         this.beforHide();
//         this.searPanel.hide();
//     },

//     /**
//      * 处理查询条件，该类根据查询条件获取查询的结果，然后组织tree
//      * @param conditions，指的是所有的查询条件
//      */
//     setData : function(conditions){
//         var results = this.dataFinder.find(conditions);
//         var treeNodes = null;
//         if (!results || results.length < 1) {
//             this.treeView.clearTreeData();
// //            return;
//         }else{
//             treeNodes = this.orgTreeManager.organizeTree(results);
//             this.treeView.setData(treeNodes, false);
//         }
//         this.setResult(results,treeNodes);
//     },

//     /**
//      * 处理查询出来的结果
//      * @param results
//      * @param treeNodes
//      */
//     setResult : function(results,treeNodes){

//     },

//     clearSearch : function(){
//         this.treeView.setData(null);
//         this.clearSearchData();
//         this.sceneManager.network3d.dirtyNetwork();
//     },

//     /**
//      * 点击搜索中的“清除”时，所要处理的就是清除搜索的结果即可，显示所有
//     */
//     clearSearchData : function(){

//     },

//     /**
//      * 清除其初始化的东西,默认是清除搜索的结果
//      */
//     clearAll : function(){
//         this.treeView.setData(null);
//         if(this.inputPane.clearInput){
//             this.inputPane.clearInput();
//         }
//         if(this.clearAllFunction){
//             this.clearAllFunction();
//         }else{
//             this.clearSearchData();
//         }
//     },

//     getRootDataBySceneAndData : function(scene,data,scope){
//         if(!scene || !data){
//             return null;
//         }
//         scope = scope || this;
//         var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
//         if(dataType && dataType.getCategoryId() === scene.getCategoryId()){
//             return data;
//         }else if(data.getParentId()){
//             var parent = this.sceneManager.dataManager.getDataById(data.getParentId());
//             if(parent){
//                 return scope.getRootDataBySceneAndData(scene,parent,scope);
//             }
//         }
//         return null;
//     },

//     /**
//      * 点击树上的节点，camera自动移过去
//      * 注意：当前是在dc场景下，点击node时应当判断其所在的场景，如果不是在同一场景下得清空，否则的会会存在问题;
//      * 注意2：即使nodeScene和currentScene，有可能它们的rootNode不一样，如，1楼的机柜和2楼的机柜;
//      *
//      * @param treeData
//      */
//     clickTreeNode : function(treeData){
//         var id = treeData.id;
//         if(!id) return;
//         var data = this.sceneManager.dataManager.getDataById(id);
//         if(!data || !this.treeView.isClick(data)) return;
//         var assetNode = this.sceneManager.dataNodeMap[id];
// //        var nodeData = this.sceneManager.getNodeData(assetNode);

//         if(!this.sceneManager.isCurrentSceneInstance(data)){ //如果一下子跳到其他的场景的某个非根对象
//             var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
//             if(sceneAndRootData){
//                 this.sceneManager.gotoScene(sceneAndRootData.scene,sceneAndRootData.rootData);
//                 //如果是整个楼层的话，就不需这么lookAt了(严格意义上说是Data本身就在场景的root就不需再去设置镜头了)
//                 if(sceneAndRootData.rootData != data){
//                     assetNode = this.sceneManager.dataNodeMap[id];
//                     if(!assetNode){
//                         this.sceneManager.loadLazyData(data);
//                     }
//                 }else{
//                     assetNode = null;
//                 }
//             }
//         }
//         //注意以下两种情况：
//         //1、还没有创建，如lazyable的设备，只有在focus该机柜时，它的孩子设备才会被创建(第一次)并加到box中
//         //2、有可能就是存在该场景中，只是不在box中而已，如：lazyable模式下，设备都被移除掉了
//         var box3d = this.sceneManager.network3d.getDataBox();
//         if(!assetNode || !box3d.getDataById(assetNode.getId())){
//             this.sceneManager.loadLazyData(data);
//             if(!assetNode){
//                 assetNode = this.sceneManager.dataNodeMap[data.getId()];
//             }
//         }
//         if(this.defaultEventHandler){
//             this.defaultEventHandler.lookAt(assetNode);
//         }
//     },

//     mouseOverTreeNode : function(treeData){
//         var id = treeData.id;
//         if (id) {
//             var assetNode = this.sceneManager.dataNodeMap[id];
//             if (assetNode) {
//                 this.sceneManager.network3d.getDataBox().getSelectionModel().clearSelection();
//                 assetNode.setSelected(true);
//             }
//         }
//     },

//     getTreeView : function(){
//         return this.treeView;
//     },

//     getOrganizeTreeManager : function(){
//         return this.orgTreeManager;
//     },

// });

// /**
//  * 资产搜索的处理
//  * @param sceneManager
//  * @constructor
//  */
// it.ITSearchManager = function(sceneManager,inputPane){
//     it.ITSearchManager.superClass.constructor.call(this, sceneManager,inputPane);
//     this._assetImage = "data:image/png;base64,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";
// }

// mono.extend(it.ITSearchManager,it.BaseSearch,{

//     createInputPane : function(){
//         return new it.ITSearchPanel();
//     },

//     clearSearchData : function(){
//         this.clearBillboard();
//     },

//     setResult : function(results,treeNodes){
//         this.clearBillboard();
//         this.virtualManager.addAll();
//         if(!treeNodes) return;
//         for(var i = 0 ; i < treeNodes.length; i++){
//             var treeNode = treeNodes[i];
//             this.showData(treeNode);
//         }
//     },

//     showData : function(treeNode){
//         var data = this.orgTreeManager.getDataByNode(treeNode);
//         if(!data) return;
//         if(this.showBillboard(data)){
//             this.addDataBillBoard(data);
//         }
//         this.virtualManager.remove(data); //同理 removeByDescendant
//         var children = this.orgTreeManager.getChildren(treeNode);
//         if(children && children.length > 0){
//             for(var i = 0 ;i < children.length ; i++){
//                 var child = children[i];
//                 if(child){
//                     this.showData(child,this);
//                 }
//             }
//         }
//     },

//     /***
//      * Data是否显示其billboard
//      * @param data
//      * @returns {boolean}
//      */
//     showBillboard : function(data){
//         if(!data) return false;
//         var assetType = data.getDataTypeId();
//         if(assetType){
//             if(assetType.indexOf('equipment') >=0){
//                 return false;
//             }
//             if(assetType.indexOf('room') >=0){
//                 return false;
//             }
//             if(assetType.indexOf('floor') >=0){
//                 return false;
//             }
//         }
//         return true;
//     },

//     clearBillboard : function(){
//         if(this.sceneManager.dataNodeMap){
//             for(var id in this.sceneManager.dataNodeMap){
//                 var node = this.sceneManager.dataNodeMap[id];
//                 if(node && node.getClient('asset_billboard')){
//                     var billboard = node.getClient('asset_billboard');
//                     billboard.setParent(null);
//                     this.sceneManager.network3d.getDataBox().remove(billboard);
//                 }
//             }
//         }
//         this.virtualManager.clearAll();
//     },

//     /**
//      * 创建资产的Billboard
//      * @param data
//      */
//     addDataBillBoard : function(data){
//         if(!data) return;
//         var node = this.sceneManager.dataNodeMap[data.getId()];
//         if(!node) return;
//         var box = this.sceneManager.network3d.getDataBox();
//         if(!box.getDataById(node.getId())){
//             return ;
//         }
//         var billboard = new mono.Billboard();
//         billboard.setPosition(0, node.getBoundingBox().max.y + 20, 0);
//         billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
//         billboard.setStyle('m.transparent', true);
// //        billboard.setStyle('m.texture.image', TML.Factory3D.getImagePath('asset.png'));
//         billboard.setStyle('m.texture.image', this._assetImage);
//         billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
//         // billboard.setStyle('m.vertical', true);
//         billboard.setScale(40, 50, 1);
//         billboard.setParent(node);
//         billboard.setClient('it_data',data);
//         box.add(billboard);
//         node.setClient('asset_billboard', billboard);
//     }

// });

// it.SpaceSearchVirtualManager = function(sceneManager,spaceManager){
//     it.VirtualManager.call(this,sceneManager);
//     this.spaceManager = spaceManager;
// }

// mono.extend(it.SpaceSearchVirtualManager,it.VirtualManager,{

//     beforeAdd: function(data) {
//         if (data) {
//             // delete data._userDataMap['dyna_user_data_totalSpace']; //总空间
//             // delete data._userDataMap['dyna_user_data_totalOccupation']; //总的占用空间
//             delete data._userDataMap['dyna_user_data_maxSerSpace']; //最大的连续空间
//             // delete data._userDataMap['dyna_user_data_totalEmpSpace']; //总的剩余空间
//             delete data._userDataMap['dyna_user_data_totalCount']; //总共可以放“uNumber”U的个数
//             delete data._userDataMap['dyna_user_data_empCount']; //空余的“uNumber”U的个数
//         }
//     },

//     filterMaterial : function(originalMaterial,filterdMaterial,node){

//         var sm = this.sceneManager;
// //        var vm = sm.viewManager3d;
//         var sm2 = this.spaceManager;
// //        var focusNode = vm.getFocusNode();
//         var map = this.materialMap;

//         if(sm.getNodeData(node)){
//             return filterdMaterial;
//         }
//         if(sm2.isSpaceNode(node)){
//             var parent = node.getParent();
//             if(sm2.isSpaceNode(parent)){
//                 parent = parent.getParent();
//             }
//             var transFlag = false;
//             if(parent){
//                 var data = this.getDataByNode(parent);
//                 if(data){
//                     id = this.getBId(data);
//                     if(this._global_tmap[id]){ // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
//                         transFlag = this._global_tmap[id];
//                     }else if(this._tmap[id]){
//                         transFlag = this._tmap[id];
//                     }
//                 }
//             }
//             if(!transFlag){
//                 return filterdMaterial;
//             }

// //                if(node.isDescendantOf(focusNode)){
// //                    return filterdMaterial;
// //                }else{
//                     var id = originalMaterial.getUniqueCode();
//                     var m = this.materialMap[id];
//                     if(!m){
//                         m = originalMaterial.clone();
//                         this.materialMap[id] = m;
//                         m.transparent = true;
//                         m.opacity = 0.05;
//                     }
//                     return m;
// //                }
//         }
//     }

// });

// /**
//  *  空间可视化搜索的处理
//  *  还得提供场景切换时空间可视化需重新计算的接口，空间可视化永远处理的是当前场景下的
//  * @param sceneManager
//  * @constructor
//  */
// it.SpaceSearchManager = function(sceneManager,inputPane,mode){
//     it.BaseSearch.call(this,sceneManager,inputPane);
//     this.spaceManager = new it.SpaceManager(this.dataManager,this.sceneManager);
//     this.diagram = new it.Diagram();
//     this.isVirtualFunction = null;
//     this.virtualNode = [];
//     this.spaceMap = {};
//     this.mode = mode || 1;
//     var self = this;
//     this.spaceManager.spaceNodeColorFunction = function(percent,data,space){
//         // ratio 表示的是已用的百分比
//         if (space) {
//             // var occupationCount = parseInt(space.getTotal()/self.getUNumber());
//             if (data && data.getUserData('dyna_user_data_empCount')) {
//                 var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
//                 // var totalCount = parseInt(space.getTotal()/self.getUNumber());
//                 // if (totalCount) {
//                 // percent = 1-occupationCount/totalCount;
//                 // }
//                 var num = self.getUNumber()||1;
//                 var total_count = Math.floor(47 / num);
//                 var unit_count = Math.floor(total_count / 4); //ceil
//                 if (total_count <= 4) {
//                     if (occupationCount === 1) {
//                         return '#5DBDE0';
//                     } else if (occupationCount === 2) {
//                         return '#6FD772';
//                     } else if (occupationCount === 3) {
//                         return '#FFC95A';
//                     } else {
//                         return '#Fd674F';
//                     }
//                 } else {
//                     if (occupationCount <= unit_count) {
//                         return '#Fd674F';
//                     } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
//                         return '#FFC95A';
//                     } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
//                         return '#6FD772';
//                     } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
//                         return '#5DBDE0';
//                     }else{
//                         console.log('can not compute the spaceNodeColorFunction color !');
//                     }
//                 }
//             }
//         }
//         if(!percent){ //空间可视化时，计算内部的颜色时
//             return '#5DBDE0';//'#BEEB9F';
//         }else if(percent <= 0.25){
//             return '#5DBDE0';//'#BEEB9F'; 绿
//         }else if(percent <= 0.5){
//             return '#6FD772';  // FFFF99 黄
//         }else if(percent <= 0.75){
//             return '#FFC95A';//'#FFBB11'; 橙
//         }else{
//             return '#Fd674F';// FF3357 '#FF6138'; //红色，表示已用的很多
//         }
//     };
//     this.spaceManager.spaceNodeFrameColorFunction = function(percent,data,space){
//         if (space) {
//             // var occupationCount = parseInt(space.getTotal()/self.getUNumber());
//             if (data && data.getUserData('dyna_user_data_empCount')) {
//                 var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
//                 var num = self.getUNumber()||1;
//                 var total_count = Math.floor(47 / num);
//                 var unit_count = Math.floor(total_count / 4); //ceil
//                 if (total_count <= 4) {
//                     if (occupationCount === 1) {
//                         return '#018ABD';
//                     } else if (occupationCount === 2) {
//                         return '#1A920A';
//                     } else if (occupationCount === 3) {
//                         return '#E68D00';
//                     } else {
//                         return '#CE3118';
//                     }
//                 } else {
//                     if (occupationCount <= unit_count) {
//                         return '#CE3118';
//                     } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
//                         return '#E68D00';
//                     } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
//                         return '#1A920A';
//                     } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
//                         return '#018ABD';
//                     }else{
//                         console.log('can not compute the spaceNodeFrameColorFunction color !');
//                     }
//                 }
//             }
//         }
//         if(!percent){ //空间可视化时，计算内部的颜色时
//             return '#018ABD';//'#BEEB9F';
//         }else if(percent <= 0.25){
//             return '#018ABD';//'#BEEB9F'; 绿
//         }else if(percent <= 0.5){
//             return '#1A920A';  // FFFF99 黄
//         }else if(percent <= 0.75){
//             return '#E68D00';//'#FFBB11'; 橙
//         }else{
//             return '#CE3118';// FF3357 '#FF6138'; //红色，表示已用的很多
//         }
//     };
//     this.resetTreeLabel();
//     this.virtualAllNodes();
//     this.clearAllFunction = function(){
//         this.clearSpaceNode();
//     }
//     this.sceneChangeListener = function(eve){
//         if (eve.data && eve.data.getCategoryId() && eve.data.getCategoryId().toLowerCase() == 'floor') {
//             self.showSpaceNode();
//         }
//     }
//     //重新计算空间可视化,当然不是空间可视的模式下的Remove掉该监听
// }

// mono.extend(it.SpaceSearchManager,it.BaseSearch,{

//     /**
//      * 切换到空间可视化时，一些初始化的一些动作，如添加场景变化的监听，隐藏掉哪些资产
//      */
//     setupInit : function(){
//         this.sceneManager.addSceneChangeListener(this.sceneChangeListener);
//         if(!this.visOrVirtFilter){ // 以免重复创建
//             this.visOrVirtFilter = this.setVisibleOrVirtualData(this.sceneManager);
//             if(this.visOrVirtFilter){
//                 if(this.visOrVirtFilter instanceof it.VisibleManager){
//                     this.sceneManager.viewManager3d.addVisibleFilter(this.visOrVirtFilter);
//                 }else if(this.visOrVirtFilter instanceof it.VirtualManager){
//                     this.sceneManager.viewManager3d.addMaterialFilter(this.visOrVirtFilter);
//                 }
//             }
//         }
//         this.setupDoOther(this.sceneManager);
//     },

//     /**
//      * 空间可视化卸载。从空间可视化切换到IT可视化时，的去掉那些在空间可视化时的初始化的动作
//      * 可是如果我从floor的空间可视化跳到上一层呢？ 那么就不会clear了，
//      *         并且使得building中都有彩色（不过可以在sceneChangeListener中判断）
//      * */
//     clearInit : function(){
//         this.sceneManager.removeSceneChangeListener(this.sceneChangeListener);
//         if(this.visOrVirtFilter){
//             if(this.visOrVirtFilter instanceof it.VisibleManager){
//                 this.sceneManager.viewManager3d.removeVisibleFilter(this.visOrVirtFilter);
//             }else if(this.visOrVirtFilter instanceof it.VirtualManager){
//                 this.sceneManager.viewManager3d.removeMaterialFilter(this.visOrVirtFilter);
//             }
//         }
//         this.clearDoOther(this.sceneManager);
//     },

//     /**
//      * 在空间可视化时，哪些资产应该被隐藏掉
//      * @param dataTypeId
//      * @param data
//      * @returns {boolean}
//      */
//     invisibleOrVirtualData : function(dataTypeId,data){
//         if(!dataTypeId && !data){
//             return false;
//         }
//         var category = this.sceneManager.dataManager.getCategoryForDataType(dataTypeId);
//         if(category && category.getId() && category.getId().toLowerCase().indexOf('channel') >=0 ){
//             return true;
//         }
//         return false;
//     },

//     /**
//      * 设置不可见(或虚化)的data
//      * @param visibleFilter或virtualManager
//      */
//     setVisibleOrVirtualData: function(sceneManager){
//         var visibleFilter = new it.VisibleManager(sceneManager);
//         var groupByType = this.dataManager._dataTypeDatas;
//         if(groupByType){
//             for(var typeId in groupByType){
//                 if(this.invisibleOrVirtualData(typeId)){
//                     var datas = groupByType[typeId];
//                     if(datas){
//                         for(var id in datas){
//                             visibleFilter.setVisible(datas[id],false);
//                         }
//                     }
//                 }
//             }
//         }
//         return visibleFilter;
//     },

//     /**
//      * 初始化时的其他动作，这里留给用户自己扩展
//      * @param sceneManager
//      */
//     setupDoOther : function(sceneManager){

//     },

//     /**
//      * 卸载时的其他动作，这里留给用户扩展
//      * @param sceneManager
//      */
//     clearDoOther : function(sceneManager){

//     },

//     createInputPane : function(){
//         this.inputPane = new it.SpaceSearchPanel();
//         return this.inputPane;
//     },

//     getVirtualManager : function(){
//         return new it.SpaceSearchVirtualManager(this.sceneManager, new it.SpaceManager(this.dataManager,this.sceneManager));
//     },

//     resetTreeLabel : function(){
//         var self = this;
//         this.orgTreeManager.createLabel = function(treeData){
//             return self.setLabel(treeData);
//         }
//     },

//     getUNumber : function(){
//         if(this.inputPane){
//           return parseInt(this.inputPane.getUNumber());
//         }else{
//            return 1;
//         }
//     },

//     setLabel : function(treeData){
//         if(!treeData || !treeData.getId()){
//             return null;
//         }
//         var id = treeData.getId();
//         var data = this.dataManager.getDataById(id);//获取data，将计算的结果保存进去，以免其他地方重复计算
//         // var space = this.spaceMap[id];
//         var prex = this.getTreeNodeLabel(treeData);
//         if (!prex) {
//             prex = id;
//         }
//         var count = 0;
//         // var uNumber = this.getUNumber();
//         // if(space && uNumber){
//             // var count = 0;
//             // var empList = space.getEmptyList();
//             // if(empList && empList.length > 0){
//             //     for(var i = 0 ; i < empList.length ; i++){
//             //         var ep = empList[i];
//             //         if(ep.total >= uNumber){
//             //             count += Math.floor(ep.total/uNumber);
//             //         }
//             //     }
//             // }
//             if (data) {
//                 // data.setUserData('dyna_user_data_totalCount',parseInt(space.getTotal()/uNumber));//总共可以放“uNumber”U的个数
//                 count = parseInt(data.getUserData('dyna_user_data_empCount'));//空余的“uNumber”U的个数
//             }
//             // return prex + '('+count+'个)';
//         // }else{
//             // return prex;
//         // }
//         if (count) {
//             prex +=  '('+count+'个)';
//         }
//         return prex;
//     },

//     /**
//      * 搜索树的叶子结点的前缀
//      */
//     getTreeNodeLabel : function(treeData){
//         if (treeData) {
//             return treeData.getId();
//         }
//         return "";
//     },

//     /**
//      * 重写，先计算每个data，然后再组织tree
//      */
//     setData : function(conditions){
//         var results = this.dataFinder.find(conditions);
//         var treeNodes = null;
//         this.setResult(results);
//         if (!results || results.length < 1) {
//             this.treeView.clearTreeData();
//         }else{
//             treeNodes = this.orgTreeManager.organizeTree(results);
//             this.treeView.setData(treeNodes, false);
//         }
//     },

//     setResult : function(result,treeNodes){
//         this.clearSpaceNode(); // 先清空
//         this.virtualManager.addAll();
//         if(!result) return;
//         var nodes = [];
//         for(var i = 0 ; i < result.length; i++){
//             var data = result[i];
//             var node = this.sceneManager.dataNodeMap[data.getId()];
//             //根据node获取其color Cube
// //            var spaceNode = this.getSpaceNode(node);
//             this.virtualManager.remove(data);
//             if(node){
//                 this._dealWithOneNode(node);
//                 nodes.push(node);
//             }
//         }
//         this.showSpaceNode(); //不需要在处理sceneData啦,20161025。需要处理整个scene中所有的nodes，否则那些机柜不会从box中移除的
//     },

//     beforHide : function(){
//         this.diagram.hideDiagram();
//     },

//     /**
//      * 点击搜索中的“清除”时，所要处理的就是清除搜索的结果即可，显示所有
//       */
//     clearSearchData : function(){
//         this.initAllNodes();
//         this.showSpaceNode();
//         this.virtualManager.clearAll();
//     },

//     clearSpaceNode : function(){
//         var nodes = this.getAllNodes();//this.virtualNode;
//         this.spaceManager.remove1DSpaceNodeForNodes(nodes);
//         this.spaceManager.hideSpaceMode();
//         this.showSerialDiagram(1,nodes);
//     },

//     virtualAllNodes : function(){
//         this.initAllNodes();
//         this.showSpaceNode();
//     },

//     showSpaceNode : function(nodes){
//         nodes = nodes || this.getSceneNodes();
//         if(nodes && nodes.length > 0){
//             this.showSerialDiagram(this.getUNumber(),nodes);
//         }else{ //当没有node的时候就隐藏掉
//             this.diagram.hideDiagram();
//         }
// //        this.spaceManager.remove1DSpaceNodeForNodes(nodes);//要先清除，再create，否则会重复创建
//         this.spaceManager.create1DSpaceNodeForNodes(nodes,this.mode); // 创建前，先移除已经放到该创建函数中了。
//         this.spaceManager.showSpaceMode();
//     },

//     /**
//      * 重写例图的显示内容
//      * @param num 表示连续可用的空间，47U
//      * 剩余的个数越少，颜色就越接近与红色
//      */
//     showSerialDiagram : function (num,nodes) {
//         var datas = [];
//         var serialNumColorMap = {};
//         num = parseInt(num);
//         if (!num) {
//             num = 1;
//         }
//         this.num = num;
//         var total_count = Math.floor(47 / num);
//         var unit_count = Math.floor(total_count / 4); //ceil

//         var color = this.getCapacityColor(0.1);
//         var data = {color: color, 
//                     minCount:(unit_count * 3 + 1),
//                     maxCount:total_count,
//                     value: (unit_count * 3 + 1) + '-' + total_count
//                 };
//         if (total_count <= 4) {
//             data.value = total_count;
//             data.minCount = total_count;
//             data.maxCount = total_count;
//             serialNumColorMap[total_count] = color;
//         } else {
//             for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         datas.push(data);


//         color = this.getCapacityColor(0.3);
//         data = {color: color, 
//                 minCount:(unit_count * 2 + 1),
//                 maxCount: unit_count * 3,
//                 value: (unit_count * 2 + 1) + '-' + (unit_count * 3)
//             };
//         if (total_count > 1 && total_count <= 4) {
//             data.value = total_count - 1;
//             data.minCount = total_count-1;
//             data.maxCount = total_count-1;
//             serialNumColorMap[total_count - 1] = color;
//         } else {
//             for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 1) {
//             datas.push(data);
//         }

//         color = this.getCapacityColor(0.6);
//         data = {color: color, 
//                 minCount:(unit_count + 1),
//                 maxCount: unit_count * 2,
//                 value: (unit_count + 1) + '-' + (unit_count * 2)
//             };
//         if (total_count > 2 && total_count <= 4) {
//             data.value = total_count - 2;
//             data.minCount = total_count - 2;
//             data.maxCount = total_count - 2;
//             serialNumColorMap[total_count - 2] = color;
//         } else {
//             for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 2) {
//             datas.push(data);
//         }

//         color = this.getCapacityColor(0.8);
//         data = {color: color, 
//                 minCount: 1,
//                 maxCount: unit_count,
//                 value: '1-' + unit_count };
//         if (total_count > 3 && total_count <= 4) {
//             data.value = total_count - 3 ;
//             data.minCount = total_count - 3;
//             data.maxCount = total_count - 3;
//             serialNumColorMap[total_count - 3] = color;
//         } else {
//             for (var i = 1; i <= unit_count; i++) {
//                 serialNumColorMap[i] = color;
//             }
//         }
//         if (total_count > 3) {
//             datas.push(data);
//         }
//         if (nodes && nodes.length > 0) {
//             var totalMap = {};
//             for(var i = 0 ; i < nodes.length ;i++){
//                 var data = this.sceneManager.getNodeData(nodes[i]);
//                 var dColor = serialNumColorMap[data.getUserData('dyna_user_data_empCount')];
//                 if (dColor) {
//                     if(totalMap[dColor]){
//                         totalMap[dColor]  ++;
//                     }else{
//                         totalMap[dColor]  = 1;
//                     }
//                 }
//             }
//             for (var i = 0; i < datas.length; i++) {
//                 var itemData = datas[i];
//                 if (!itemData) {
//                     continue;
//                 }
//                 if (totalMap[itemData.color]) {
//                     var strValue = '';
//                     if (itemData.minCount) {
//                         strValue = itemData.minCount;
//                     }
//                     if (itemData.minCount != itemData.maxCount) {
//                         strValue += '-' + itemData.maxCount;
//                     }
//                     strValue += '('+ totalMap[itemData.color] +')';
//                     itemData.value = strValue;
//                 }
//             }
//         }
//         this.diagram.setData(datas, '连续可用空间图例');
//     },

//     getCapacityColor: function (ratio) {
//         // ratio 表示的是已用的百分比
//         if (!ratio) {
//             return '#5DBDE0';//'#BEEB9F';
//         } else if (ratio <= 0.25) {
//             return '#5DBDE0';//'#BEEB9F'; 绿
//         } else if (ratio <= 0.5) {
//             return '#6FD772';  // FFFF99 黄
//         } else if (ratio <= 0.75) {
//             return '#FFC95A';//'#FFBB11'; 橙
//         } else {
//             return '#Fd674F';// FF3357 '#FF6138'; //红色，表示已用的很多
//         }
//     },

//     isDealwith : function(node){
//         if(!node) return false;
//         if(this.isVirtualFunction){
//             return this.isVirtualFunction(node);
//         }
//         var data = this.sceneManager.getNodeData(node);
//         if(!data) return false;
//         // var type = this.sceneManager.dataManager.getDataTypeForData(data);
//         // if(!type) return false;
//         // if(type._model.indexOf('.rack') >0){
//         //     return true;
//         // }
//         var category = this.sceneManager.dataManager.getCategoryForData(data);
//         if (category && category.getId().toLowerCase() == 'rack') {
//             return true;
//         }
//         return false;
//     },

//     getDataSpace : function(data){
//         if (!data) {
//             return null;
//         }
//         var space = this.spaceMap[data.getId()];
//         if (!space) {
//             var dataSpace = this.spaceManager.computeSpace(data);
//              if(dataSpace && (dataSpace instanceof it.Space1)){
//                 this.spaceMap[data.getId()] = dataSpace;
//                 space = dataSpace;
//              }
//         }
//         return space;
//     },

//     _dealWithOneNode : function(node){
//         var uNumber = this.getUNumber();
//         if (!uNumber) {
//             uNumber = 1;
//         }
//         if(node){
//             if(this.isDealwith(node)){
//                 var data = this.sceneManager.getNodeData(node);
//                 if(!data) return ;
//                 // var space = this.spaceMap[data.getId()]; 
//                 // if (!space) {
//                 //     space = this.spaceManager.computeSpace(data);
//                 //     if(space && (space instanceof it.Space1)){
//                 //        this.spaceMap[data.getId()] = space;
//                 //     }
//                 // }
//                 var space = this.getDataSpace(data);
//                 var count = 0;
//                 // if(space && (space instanceof it.Space1)){
//                 if (space) {
//                     // this.spaceMap[it.SceneManager.getNodeDataId(node)] = space;
//                     var maxEmpSerSpace = 0,totalEmpSpace = space.getTotal() - space.getOccupation();
//                     var empList = space.getEmptyList();
//                     if(empList && empList.length > 0){
//                         for(var i = 0 ; i < empList.length ; i++){
//                             var ep = empList[i];
//                             if(ep.total > maxEmpSerSpace){
//                                 maxEmpSerSpace = ep.total;
//                             }
//                             if(ep.total >= uNumber){
//                                count += Math.floor(ep.total/uNumber);
//                             }  
//                         }
//                     }
//                     data.setUserData('dyna_user_data_totalSpace',space.getTotal());//总空间
//                     data.setUserData('dyna_user_data_totalOccupation',space.getOccupation());//总的占用空间
//                     data.setUserData('dyna_user_data_maxSerSpace',maxEmpSerSpace);//最大的连续空间
//                     data.setUserData('dyna_user_data_totalEmpSpace',totalEmpSpace);//总的剩余空间
//                     data.setUserData('dyna_user_data_totalCount',parseInt(space.getTotal()/uNumber));//总共可以放“uNumber”U的个数
//                     data.setUserData('dyna_user_data_empCount',count);//空余的“uNumber”U的个数
//                     this.virtualNode.push(node);
//                 }
//             }
//         }
//     },

//     /**
//      * 获取所有的Node，此方法在这里没什么用
//      * @returns {*}
//      */
//     getAllNodes : function(){
//         var nodeMap = this.sceneManager.dataNodeMap;
//         if(!nodeMap) return null;
//         var allNodes = [];
//         for(var id in nodeMap){
//             var node = nodeMap[id];
//             if(node && this.isDealwith(node)) {
//                 var data = this.sceneManager.getNodeData(node);
//                 if (!data) return;
//                 // var space = this.spaceManager.computeSpace(data);
//                 // if (space && (space instanceof it.Space1)) {
//                 var space = this.getDataSpace(data);
//                 if (space) {
//                     allNodes.push(node);
//                 }
//             }
//         }
//         return allNodes;
//     },

//     /**
//      * 获取当前场景下的所有的node
//      */
//     getSceneNodes : function(){
//         var sceneNodes = [];
//         var sceneDatas = this.sceneManager.getSceneDatas();
//         if(sceneDatas){
//             var nodeMaps = this.sceneManager.dataNodeMap;
//             for(var id in sceneDatas){
//                 var node = nodeMaps[id];
//                 var data = sceneDatas[id];
//                 if(node && data && this.isDealwith(node)){
//                     // var space = this.spaceManager.computeSpace(data);
//                     var space = this.getDataSpace(data);
//                     // if (space && (space instanceof it.Space1)) {
//                     if (space) {
//                         this._dealWithOneNode(node);
//                         sceneNodes.push(node);
//                     }
//                 }
//             }
//         }
//         return sceneNodes;
//     },

//     initAllNodes : function(){
//         var nodeMap = this.sceneManager.dataNodeMap;
//         if(!nodeMap) return null;
//         this.virtualNode = [];
//         for(var id in nodeMap){
//             var node = nodeMap[id];
//             var data = this.sceneManager.getNodeData(node);
//             if (data) {
//                 data.setUserData('dyna_user_data_totalCount',null);//计算的时候清空
//                 data.setUserData('dyna_user_data_empCount',null);
//             }
//             this._dealWithOneNode(node);
//         }
//         return this.virtualNode;
//     }

// });
/**
 *
 * @param sceneManager
 * @param inputPane
 * @constructor
 */
it.BaseSearch = function(sceneManager,inputPane){
    if(!sceneManager) {
        console.error("agument sceneManager can not be null");
        return;
    }
    this.sceneManager = sceneManager;
    this.dataManager = this.sceneManager.dataManager;
    this.dataFinder = new it.DataFinder(this.sceneManager.dataManager);
    var self = this;
    this.dataFinder.filter = function(data){
        return self.filter(data);
    };
//    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
    this.virtualManager = this.getVirtualManager() || new it.VirtualManager(sceneManager);
    this.virtualManager.isDealWithFunction = function(data){ // 如果是房间的话则不出来透明
        if(!data) return false;
        var category = self.dataManager.getCategoryForData(data);
        if (category) {
            var catId = category.getId().toLowerCase();
            if (catId.indexOf('room') >= 0) {
                return false;
            } else if (catId.indexOf('datacenter') >= 0) {
                return false;
            } else if (catId.indexOf('building') >= 0) {
                return false;
            }else if (catId.indexOf('earth') >= 0) {
                return false;
            }
        }
        return true;
    }
    this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
    this.treeView = null;
    this.orgTreeManager = new it.OrganizeTreeManager(this.sceneManager.dataManager);
    this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
    this.inputPane = inputPane||this.createInputPane();
    this.searPanel = null;
    this.clearAllFunction = null;
    this.initSearchPane();
};

mono.extend(it.BaseSearch,Object,{

    createInputPane : function(){
        return new it.BasePanel();
    },

    getVirtualManager : function(){
        return new it.VirtualManager(this.sceneManager);
    },

    addVirtualManager : function(){
        this.sceneManager.viewManager3d.addMaterialFilter(this.virtualManager);
    },

    removeVirtualManager : function(){
        this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualManager);
    },

    filter:function(data){
       return true;
    },

    clearAllVirtual : function(){
        this.virtualManager.clearAll();
    },
    
    /**
     * 当没有搜索出任何东西时的接口
     */
    showNoData : function(){
        
    },

    initSearchPane : function(){
        this.searPanel = $('.search-main-pane');
        var paneIndex = 0;
        if(this.searPanel && this.searPanel.length > 0){
            paneIndex = this.searPanel.length;
        }
        this.searPanel = $('<div id = "search-main-pane_'+paneIndex+'" class="search-main-pane"></div>');
//        this.searPanel.css('left',10);
//        this.searPanel.css('top',10);
        this.searPanel.append(this.inputPane.getContentPane());
        this.treeView = new it.TreeView(this.searPanel);
//        $('body').append(this.searPanel);
        var self = this;
        this.treeView.clickNodeFunction = function(treeData){
            self.clickTreeNode(treeData);
        };

        this.treeView.mouseoverNodeFunction = function(treeData){
            self.mouseOverTreeNode(treeData);
        };

        this.inputPane.doClickFunction = function(values){
//            var values = [{key:'u:userId',value:'aaa',operation:'like'}];
            self.beforeDoClick();
            self.setData(values);
            var height = self.searPanel.height() - self.inputPane.getContentPane().height();
            self.treeView.setTreeHeight(height);
            self.sceneManager.viewManager3d.clearVisibleMap();
        };

        this.inputPane.doClearFunction = function(){
            self.clearSearch();
        };
    },

    beforeDoClick : function(){

    },

    show : function(){
        this.searPanel.show();
    },

    beforHide : function(){

    },

    hide : function(){
        this.beforHide();
        this.searPanel.hide();
    },

    /**
     * 处理查询条件，该类根据查询条件获取查询的结果，然后组织tree
     * @param conditions，指的是所有的查询条件
     */
    setData : function(conditions){
        // var results = this.dataFinder.find(conditions);
        var results = this.getResultByConditions(conditions);
        var treeNodes = null;
        if (!results || results.length < 1) {
            this.treeView.clearTreeData();
//            return;
        }else{
            treeNodes = this.orgTreeManager.organizeTree(results);
            this.treeView.setData(treeNodes, false);
        }
        this.setResult(results,treeNodes);
    },

    /**
     * 根据条件获取查询的结果
     * 单独拿出来是为了方便扩展，重写这个方法可以对接第三方
     */
    getResultByConditions : function(conditions){
        return this.dataFinder.find(conditions);
    },

    /**
     * 处理查询出来的结果
     * @param results
     * @param treeNodes
     */
    setResult : function(results,treeNodes){

    },

    clearSearch : function(){
        this.treeView.setData(null);
        this.clearSearchData();
        this.sceneManager.network3d.dirtyNetwork();
    },

    /**
     * 点击搜索中的“清除”时，所要处理的就是清除搜索的结果即可，显示所有
    */
    clearSearchData : function(){

    },

    /**
     * 清除其初始化的东西,默认是清除搜索的结果
     */
    clearAll : function(){
        this.treeView.setData(null);
        if(this.inputPane.clearInput){
            this.inputPane.clearInput();
        }
        // this.removeVirtualManager();
        if(this.clearAllFunction){
            this.clearAllFunction();
        }else{
            this.clearSearchData();
        }
    },

    shouldClick : function(data){
        return true;
    },

    getRootDataBySceneAndData : function(scene,data,scope){
        if(!scene || !data){
            return null;
        }
        scope = scope || this;
        var dataType = this.sceneManager.dataManager.getDataTypeForData(data);
        if(dataType && dataType.getCategoryId() === scene.getCategoryId()){
            return data;
        }else if(data.getParentId()){
            var parent = this.sceneManager.dataManager.getDataById(data.getParentId());
            if(parent){
                return scope.getRootDataBySceneAndData(scene,parent,scope);
            }
        }
        return null;
    },

    /**
     * 点击树上的节点，camera自动移过去
     * 注意：当前是在dc场景下，点击node时应当判断其所在的场景，如果不是在同一场景下得清空，否则的会会存在问题;
     * 注意2：即使nodeScene和currentScene，有可能它们的rootNode不一样，如，1楼的机柜和2楼的机柜;
     *
     * @param treeData
     */
    clickTreeNode : function(treeData){
        var id = treeData.id;
        if(!id) return;
        if(!this.sceneManager.viewManager3d.enableDBLClick){ //表示锁定，场景切换的过程中，不可点击再切换
            return;
        }
        var data = this.sceneManager.dataManager.getDataById(id);
        if(!data || !this.treeView.isClick(data)) return;
        var assetNode = this.sceneManager.dataNodeMap[id];
//        var nodeData = this.sceneManager.getNodeData(assetNode);
        if(!this.shouldClick(data)){
            return;
        }
        if(!this.sceneManager.isCurrentSceneInstance(data,true)){ //如果一下子跳到其他的场景的某个非根对象
            var sceneAndRootData = this.sceneManager.getSceneAndRootByData(data);
            if(sceneAndRootData){
                this.sceneManager.gotoScene(sceneAndRootData.scene,sceneAndRootData.rootData,null,false);
                //以下有可能存在一些不合理，因为gotoScene中可能会存在很长时间的动画，特别是楼层切换那块，马上这么调用，有可能有问题
                //如果是整个楼层的话，就不需这么lookAt了(严格意义上说是Data本身就在场景的root就不需再去设置镜头了)
                if(sceneAndRootData.rootData != data){
                    assetNode = this.sceneManager.dataNodeMap[id];
                    if(!assetNode){
                        this.sceneManager.loadLazyData(data);
                    }
                }else{
                    return ; //根节点就是clickData，那就返回吧
                }
            }
        }
        //注意以下两种情况：
        //1、还没有创建，如lazyable的设备，只有在focus该机柜时，它的孩子设备才会被创建(第一次)并加到box中
        //2、有可能就是存在该场景中，只是不在box中而已，如：lazyable模式下，设备都被移除掉了
        var box3d = this.sceneManager.network3d.getDataBox();
        if(!assetNode || !box3d.getDataById(assetNode.getId())){
            this.sceneManager.loadLazyData(data);
            if(!assetNode){
                assetNode = this.sceneManager.dataNodeMap[data.getId()];
            }
        }
        if(this.defaultEventHandler 
            && assetNode != this.sceneManager.getCurrentRootNode()){ //gotoScene中有setFocus，并且该方法有可能会重写
            this.defaultEventHandler.lookAt(assetNode);
        }
    },

    mouseOverTreeNode : function(treeData){
        var id = treeData.id;
        this.sceneManager.network3d.getDataBox().getSelectionModel().clearSelection();
        if (id) {
            var assetNode = this.sceneManager.dataNodeMap[id];
            if (assetNode) {
                assetNode.setSelected(true);
            }
        }
    },

    getTreeView : function(){
        return this.treeView;
    },

    getOrganizeTreeManager : function(){
        return this.orgTreeManager;
    },

});

/**
 * 资产搜索的处理
 * @param sceneManager
 * @constructor
 */
it.ITSearchManager = function(sceneManager,inputPane){
    it.ITSearchManager.superClass.constructor.call(this, sceneManager,inputPane);
    this._assetImage = "data:image/png;base64,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";
}

mono.extend(it.ITSearchManager,it.BaseSearch,{

    createInputPane : function(){
        return new it.ITSearchPanel();
    },

    clearSearchData : function(){
        this.clearBillboard();
    },

    setResult : function(results,treeNodes){
        this.clearBillboard();
        this.virtualManager.addAll();
        if(!treeNodes) {
            this.showNoData();
            return;
        }
        for(var i = 0 ; i < treeNodes.length; i++){
            var treeNode = treeNodes[i];
            this.showData(treeNode);
        }
    },

    showData : function(treeNode){
        var data = this.orgTreeManager.getDataByNode(treeNode);
        if(!data){
            return;
        }
        if(this.showBillboard(data)){
            this.addDataBillBoard(data);
        }
        this.virtualManager.remove(data); //同理 removeByDescendant
        var children = this.orgTreeManager.getChildren(treeNode);
        if(children && children.length > 0){
            for(var i = 0 ;i < children.length ; i++){
                var child = children[i];
                if(child){
                    this.showData(child,this);
                }
            }
        }
    },

    /***
     * Data是否显示其billboard
     * @param data
     * @returns {boolean}
     */
    showBillboard : function(data){
        if(!data) return false;
        var assetType = data.getDataTypeId();
        if(assetType){
            if(assetType.indexOf('equipment') >=0){
                return false;
            }
            if(assetType.indexOf('room') >=0){
                return false;
            }
            if(assetType.indexOf('floor') >=0){
                return false;
            }
        }
        return true;
    },

    clearBillboard : function(){
        if(this.sceneManager.dataNodeMap){
            for(var id in this.sceneManager.dataNodeMap){
                var node = this.sceneManager.dataNodeMap[id];
                if(node && node.getClient('asset_billboard')){
                    var billboard = node.getClient('asset_billboard');
                    billboard.setParent(null);
                    this.sceneManager.network3d.getDataBox().remove(billboard);
                }
            }
        }
        this.virtualManager.clearAll();
    },

    /**
     * 创建资产的Billboard
     * @param data
     */
    addDataBillBoard : function(data){
        if(!data) return;
        var node = this.sceneManager.dataNodeMap[data.getId()];
        if(!node) return;
        var box = this.sceneManager.network3d.getDataBox();
        if(!box.getDataById(node.getId())){
            return ;
        }
        var billboard = new mono.Billboard();
        billboard.setPosition(0, node.getBoundingBox().max.y + 20, 0);
        billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        billboard.setStyle('m.transparent', true);
//        billboard.setStyle('m.texture.image', TML.Factory3D.getImagePath('asset.png'));
        billboard.setStyle('m.texture.image', this._assetImage);
        billboard.setStyle('m.alignment', mono.BillboardAlignment.bottomCenter);
        // billboard.setStyle('m.vertical', true);
        billboard.setScale(40, 50, 1);
        billboard.setParent(node);
        billboard.setClient('it_data',data);
        box.add(billboard);
        node.setClient('asset_billboard', billboard);
    }

});

it.SpaceSearchVirtualManager = function (sceneManager, spaceManager) {
    it.VirtualManager.call(this, sceneManager);
    this.spaceManager = spaceManager;
}

mono.extend(it.SpaceSearchVirtualManager, it.VirtualManager, {

    beforeAdd: function (data) {
        if (data) {
            // delete data._userDataMap['dyna_user_data_totalSpace']; //总空间
            // delete data._userDataMap['dyna_user_data_totalOccupation']; //总的占用空间
            delete data._userDataMap['dyna_user_data_maxSerSpace']; //最大的连续空间
            // delete data._userDataMap['dyna_user_data_totalEmpSpace']; //总的剩余空间
            delete data._userDataMap['dyna_user_data_totalCount']; //总共可以放“uNumber”U的个数
            delete data._userDataMap['dyna_user_data_empCount']; //空余的“uNumber”U的个数
        }
    },

    filterMaterial: function (originalMaterial, filterdMaterial, node) {
        var sm = this.sceneManager;
        var sm2 = this.spaceManager;
        var map = this.materialMap;
        if (sm.getNodeData(node)) {
            return filterdMaterial;
        }
        if (sm2.isSpaceNode(node)) {
            var parent = node.getParent();
            if (sm2.isSpaceNode(parent)) {
                parent = parent.getParent();
            }
            var transFlag = false;
            if (parent) {
                var data = this.getDataByNode(parent);
                if (data) {
                    id = this.getBId(data);
                    if (this._global_tmap[id]) { // 对于透明来讲，如果global中是虚化的，那怎么着它就是虚化的
                        transFlag = this._global_tmap[id];
                    } else if (this._tmap[id]) {
                        transFlag = this._tmap[id];
                    }
                }
            }
            if (!transFlag) {
                return filterdMaterial;
            }
            var id = originalMaterial.getUniqueCode();
            var m = this.materialMap[id];
            if (!m) {
                m = originalMaterial.clone();
                this.materialMap[id] = m;
                m.transparent = true;
                m.opacity = 0.05;
            }
            return m;
        }
    }

});

/**
 *  空间可视化搜索的处理
 *  还得提供场景切换时空间可视化需重新计算的接口，空间可视化永远处理的是当前场景下的
 * @param sceneManager
 * @constructor
 */
it.SpaceSearchManager = function (sceneManager, inputPane, mode) {
    it.BaseSearch.call(this, sceneManager, inputPane);
    this.spaceManager = new it.SpaceManager(this.dataManager, this.sceneManager);
    this.diagram = new it.Diagram();
    this.isVirtualFunction = null;
    this.virtualNode = [];
    this.spaceMap = {};
    this.mode = mode || 1;
    this.maxRackUSize = 47;
    var self = this;
    this.spaceManager.spaceNodeColorFunction = function (percent, data, space) {
        // ratio 表示的是已用的百分比
        // if (space) {
        if (data && data.getUserData('dyna_user_data_empCount')) {
            var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
            var num = self.getUNumber() || 1;
            var total_count = Math.floor(self.maxRackUSize/num);
            var unit_count = Math.floor(total_count / 4); //ceil
            if (total_count <= 4) {
                if (occupationCount === total_count) {
                    return '#5DBDE0'; //蓝
                } else if ((total_count - 1) > 0 && occupationCount === (total_count - 1)) {
                    return '#6FD772';
                } else if ((total_count - 2) > 0 && occupationCount === (total_count - 2)) {
                    return '#FFC95A';
                } else {
                    return '#Fd674F';
                }
            } else {
                if (occupationCount <= unit_count) {
                    return '#Fd674F';
                } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
                    return '#FFC95A';
                } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
                    return '#6FD772';
                } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
                    return '#5DBDE0';
                } else {
                    console.log('can not compute the spaceNodeColorFunction color !');
                }
            }
        }
        // }
        if (!percent) { //空间可视化时，计算内部的颜色时
            return '#5DBDE0'; //'#BEEB9F';
        } else if (percent <= 0.25) {
            return '#5DBDE0'; //'#BEEB9F'; 绿
        } else if (percent <= 0.5) {
            return '#6FD772'; // FFFF99 黄
        } else if (percent <= 0.75) {
            return '#FFC95A'; //'#FFBB11'; 橙
        } else {
            return '#Fd674F'; // FF3357 '#FF6138'; //红色，表示已用的很多
        }
    };

    this.spaceManager.spaceNodeFrameColorFunction = function (percent, data, space) {
        // if (space) {
        if (data && data.getUserData('dyna_user_data_empCount')) {
            var occupationCount = parseInt(data.getUserData('dyna_user_data_empCount'));
            var num = self.getUNumber() || 1;
            var total_count = Math.floor(self.maxRackUSize/num);
            var unit_count = Math.floor(total_count / 4); //ceil
            if (total_count <= 4) {
                if (occupationCount === 1) {
                    return '#018ABD';
                } else if (occupationCount === 2) {
                    return '#1A920A';
                } else if (occupationCount === 3) {
                    return '#E68D00';
                } else {
                    return '#CE3118';
                }
            } else {
                if (occupationCount <= unit_count) {
                    return '#CE3118';
                } else if (occupationCount >= (unit_count + 1) && occupationCount <= unit_count * 2) {
                    return '#E68D00';
                } else if (occupationCount >= (unit_count * 2 + 1) && occupationCount <= unit_count * 3) {
                    return '#1A920A';
                } else if (occupationCount >= (unit_count * 3 + 1) && occupationCount <= total_count) {
                    return '#018ABD';
                } else {
                    console.log('can not compute the spaceNodeFrameColorFunction color !');
                }
            }
        }
        // }
        if (!percent) { //空间可视化时，计算内部的颜色时
            return '#018ABD'; //'#BEEB9F';
        } else if (percent <= 0.25) {
            return '#018ABD'; //'#BEEB9F'; 绿
        } else if (percent <= 0.5) {
            return '#1A920A'; // FFFF99 黄
        } else if (percent <= 0.75) {
            return '#E68D00'; //'#FFBB11'; 橙
        } else {
            return '#CE3118'; // FF3357 '#FF6138'; //红色，表示已用的很多
        }
    };

    this.resetTreeLabel();
    this.virtualAllNodes();
    this.clearAllFunction = function () {
        this.clearSpaceNode();
    }
}

mono.extend(it.SpaceSearchManager, it.BaseSearch, {
    beforeDoClick: function () {
        var cn = this.sceneManager._currentRootNode;
        this.sceneManager.viewManager3d.defaultEventHandler.lookAt(cn);
    },
    /**
     * 切换到空间可视化时，一些初始化的一些动作，如添加场景变化的监听，隐藏掉哪些资产
     */
    setupInit: function () {
        if (!this.visOrVirtFilter) { // 以免重复创建
            this.visOrVirtFilter = this.setVisibleOrVirtualData(this.sceneManager);
        }
        if (this.visOrVirtFilter instanceof it.VisibleManager) {
            this.sceneManager.viewManager3d.addVisibleFilter(this.visOrVirtFilter);
        } else if (this.visOrVirtFilter instanceof it.VirtualManager) {
            this.sceneManager.viewManager3d.addMaterialFilter(this.visOrVirtFilter);
        }
        
        this.addVirtualManager();
        this.setupDoOther(this.sceneManager);
    },

    /**
     * 空间可视化卸载。从空间可视化切换到IT可视化时，的去掉那些在空间可视化时的初始化的动作
     * 可是如果我从floor的空间可视化跳到上一层呢？ 那么就不会clear了，
     *         并且使得building中都有彩色（不过可以在sceneChangeListener中判断）
     * */
    clearInit: function () {
        this.sceneManager.removeSceneChangeListener(this.sceneChangeListener);
        if (this.visOrVirtFilter) {
            if (this.visOrVirtFilter instanceof it.VisibleManager) {
                this.sceneManager.viewManager3d.removeVisibleFilter(this.visOrVirtFilter);
            } else if (this.visOrVirtFilter instanceof it.VirtualManager) {
                this.sceneManager.viewManager3d.removeMaterialFilter(this.visOrVirtFilter);
            }
        }
        this.removeVirtualManager();
        this.clearDoOther(this.sceneManager);
    },

    /**
     * 在空间可视化时，哪些资产应该被隐藏掉
     * @param dataTypeId
     * @param data
     * @returns {boolean}
     */
    invisibleOrVirtualData: function (dataTypeId, data) {
        if (!dataTypeId && !data) {
            return false;
        }
        var category = this.sceneManager.dataManager.getCategoryForDataType(dataTypeId);
        if (category && category.getId() && category.getId().toLowerCase().indexOf('channel') >= 0) {
            return true;
        }
        return false;
    },

    /**
     * 设置不可见(或虚化)的data
     * @param visibleFilter或virtualManager
     */
    setVisibleOrVirtualData: function (sceneManager) {
        var visibleFilter = new it.VisibleManager(sceneManager);
        var groupByType = this.dataManager._dataTypeDatas;
        if (groupByType) {
            for (var typeId in groupByType) {
                if (this.invisibleOrVirtualData(typeId)) {
                    var datas = groupByType[typeId];
                    if (datas) {
                        for (var id in datas) {
                            visibleFilter.setVisible(datas[id], false);
                        }
                    }
                }
            }
        }
        return visibleFilter;
    },

    /**
     * 初始化时的其他动作，这里留给用户自己扩展
     * @param sceneManager
     */
    setupDoOther: function (sceneManager) {

    },

    /**
     * 卸载时的其他动作，这里留给用户扩展
     * @param sceneManager
     */
    clearDoOther: function (sceneManager) {

    },

    createInputPane: function () {
        this.inputPane = new it.SpaceSearchPanel();
        return this.inputPane;
    },

    getVirtualManager: function () {
        return new it.SpaceSearchVirtualManager(this.sceneManager, new it.SpaceManager(this.dataManager, this.sceneManager));
    },

    resetTreeLabel: function () {
        var self = this;
        this.orgTreeManager.createLabel = function (treeData) {
            return self.setLabel(treeData);
        }
    },

    getUNumber: function () {
        if (this.inputPane) {
            return parseInt(this.inputPane.getUNumber());
        } else {
            return 1;
        }
    },

    setLabel: function (treeData) {
        if (!treeData || !treeData.getId()) {
            return null;
        }
        var id = treeData.getId();
        var data = this.dataManager.getDataById(id);//获取data，将计算的结果保存进去，以免其他地方重复计算
        // var space = this.spaceMap[id];
        var prex = this.getTreeNodeLabel(treeData);
        if (!prex) {
            prex = id;
        }
        var count = 0;
        if (data) {
            count = parseInt(data.getUserData('dyna_user_data_empCount'));//空余的“uNumber”U的个数
        }
        if (count) {
            prex += '(' + count + '个)';
        }
        return prex;
    },

    /**
     * 搜索树的叶子结点的前缀
     */
    getTreeNodeLabel: function (treeData) {
        if (treeData) {
            return treeData.getId();
        }
        return "";
    },

    /**
     * 重写，先计算每个data，然后再组织tree
     */
    setData: function (conditions) {
        var results = this.dataFinder.find(conditions);
        var treeNodes = null;
        this.setResult(results);
        if (!results || results.length < 1) {
            this.showNoData();
            this.treeView.clearTreeData();
        } else {
            treeNodes = this.orgTreeManager.organizeTree(results);
            this.treeView.setData(treeNodes, false);
        }
    },

    setResult: function (result, treeNodes) {
        this.clearSpaceNode(); // 先清空
        this.virtualManager.addAll();
        if (!result) return;
        var nodes = [];
        for (var i = 0; i < result.length; i++) {
            var data = result[i];
            var node = this.sceneManager.dataNodeMap[data.getId()];
            //根据node获取其color Cube
            //            var spaceNode = this.getSpaceNode(node);
            this.virtualManager.remove(data);
            if (node) {
                this._dealWithOneNode(node);
                nodes.push(node);
            }
        }
        this.showSpaceNode(nodes);
    },

    beforHide: function () {
        this.diagram.hideDiagram();
    },

    /**
     * 点击搜索中的“清除”时，所要处理的就是清除搜索的结果即可，显示所有
      */
    clearSearchData: function () {
        this.initAllNodes();
        this.showSpaceNode();
        this.virtualManager.clearAll();
    },

    clearSpaceNode: function () {
        var nodes = this.getAllNodes();//this.virtualNode;
        this.spaceManager.remove1DSpaceNodeForNodes(nodes);
        this.spaceManager.hideSpaceMode();
        this.showSerialDiagram(1, nodes);
    },

    virtualAllNodes: function () {
        this.initAllNodes();
        this.showSpaceNode();
    },

    /**
     * 显示空间彩色机柜
     * @result 这个是查询结果，例图上的数量是通过该值计算的
     * 注意：create1DSpaceNodeForNodes中应该是传入当前场景下的所有的nodes，而不只是搜索结果
     */
    showSpaceNode: function (result) {
        var nodes = this.getSceneNodes();
        if (!result || result.length < 1) {
            result = nodes;
        }
        if (nodes && nodes.length > 0) {
            this.showSerialDiagram(this.getUNumber(), result);
        } else { //当没有node的时候就隐藏掉
            this.diagram.hideDiagram();
        }
        //        this.spaceManager.remove1DSpaceNodeForNodes(nodes);//要先清除，再create，否则会重复创建
        this.spaceManager.create1DSpaceNodeForNodes(nodes, this.mode); // 创建前，先移除已经放到该创建函数中了。
        this.spaceManager.showSpaceMode();
    },

    /**
     * 重写例图的显示内容
     * @param num 表示连续可用的空间，maxRackUSize
     * 剩余的个数越少，颜色就越接近与红色
     */
    showSerialDiagram: function (num, nodes) {
        var datas = [];
        var serialNumColorMap = {};
        num = parseInt(num);
        if (!num) {
            num = 1;
        }
        this.num = num;
        var total_count = Math.floor(this.maxRackUSize/num);
        var unit_count = Math.floor(total_count / 4); //ceil

        var color = this.getCapacityColor(0.1);
        var data = {
            color: color,
            minCount: (unit_count * 3 + 1),
            maxCount: total_count,
            value: (unit_count * 3 + 1) + '-' + total_count
        };
        if (total_count <= 4) {
            data.value = total_count;
            data.minCount = total_count;
            data.maxCount = total_count;
            serialNumColorMap[total_count] = color;
        } else {
            for (var i = (unit_count * 3 + 1); i <= total_count; i++) {
                serialNumColorMap[i] = color;
            }
        }
        datas.push(data);


        color = this.getCapacityColor(0.3);
        data = {
            color: color,
            minCount: (unit_count * 2 + 1),
            maxCount: unit_count * 3,
            value: (unit_count * 2 + 1) + '-' + (unit_count * 3)
        };
        if (total_count > 1 && total_count <= 4) {
            data.value = total_count - 1;
            data.minCount = total_count - 1;
            data.maxCount = total_count - 1;
            serialNumColorMap[total_count - 1] = color;
        } else {
            for (var i = (unit_count * 2 + 1); i <= (unit_count * 3); i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 1) {
            datas.push(data);
        }

        color = this.getCapacityColor(0.6);
        data = {
            color: color,
            minCount: (unit_count + 1),
            maxCount: unit_count * 2,
            value: (unit_count + 1) + '-' + (unit_count * 2)
        };
        if (total_count > 2 && total_count <= 4) {
            data.value = total_count - 2;
            data.minCount = total_count - 2;
            data.maxCount = total_count - 2;
            serialNumColorMap[total_count - 2] = color;
        } else {
            for (var i = (unit_count + 1); i <= (unit_count * 2); i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 2) {
            datas.push(data);
        }

        color = this.getCapacityColor(0.8);
        data = {
            color: color,
            minCount: 1,
            maxCount: unit_count,
            value: '1-' + unit_count
        };
        if (total_count > 3 && total_count <= 4) {
            data.value = total_count - 3;
            data.minCount = total_count - 3;
            data.maxCount = total_count - 3;
            serialNumColorMap[total_count - 3] = color;
        } else {
            for (var i = 1; i <= unit_count; i++) {
                serialNumColorMap[i] = color;
            }
        }
        if (total_count > 3) {
            datas.push(data);
        }
        var usedP = {};
        var totalMap = {};
        if (nodes && nodes.length > 0) {
            for (var i = 0; i < nodes.length; i++) {
                var data = this.sceneManager.getNodeData(nodes[i]);
                var dColor = serialNumColorMap[data.getUserData('dyna_user_data_empCount')];
                var space = data.getUserData('dyna_user_data_totalSpace');//总空间
                var occupation = data.getUserData('dyna_user_data_totalOccupation');//总的占用空间

                if (dColor) {
                    if (totalMap[dColor]) {
                        totalMap[dColor]++;
                    } else {
                        totalMap[dColor] = 1;
                    }
                    if (usedP[dColor]) {
                        var us = usedP[dColor];
                        var percent = Math.round(occupation / space * 100);
                        if (percent < us.minP) us.minP = percent;
                        if (percent > us.maxP) us.maxP = percent;
                    } else {
                        var percent = Math.round(occupation / space * 100);
                        usedP[dColor] = { 'minP': percent, 'maxP': percent };
                    }
                }
            }
            for (var i = 0; i < datas.length; i++) {
                var itemData = datas[i];
                if (!itemData) {
                    continue;
                }
                if (totalMap[itemData.color]) {
                    var strValue = '';
                    if (itemData.minCount) {
                        strValue = itemData.minCount;
                    }
                    if (itemData.minCount != itemData.maxCount) {
                        strValue += '-' + itemData.maxCount;
                    }
                    strValue += '(' + totalMap[itemData.color] + ')';
                    itemData.value = strValue;
                }

            }
        }
        $.each(datas, function (index, val) {
            var used = usedP[val.color];
            var count = totalMap[val.color] || 0;
            val.tip = '能够放置' + val.minCount + '-' + val.maxCount + '个' + num + 'U设备的机柜有' + count + '个';
            if (used) {
                val.tip += ', 使用率为' + used.minP + '% - ' + used.maxP + '%';
            }
        });

        this.diagram.setData(datas, '连续可用空间图例', function (index, el) {
            var data = datas[index];
            layer.tips(data.tip, el, { tips: [3, data.color], time: 30000 });//'#428BCA'
        }, function (index, el) {
            layer.closeAll();
        });
    },

    getCapacityColor: function (ratio) {
        // ratio 表示的是已用的百分比
        if (!ratio) {
            return '#5DBDE0';//'#BEEB9F';
        } else if (ratio <= 0.25) {
            return '#5DBDE0';//'#BEEB9F'; 绿
        } else if (ratio <= 0.5) {
            return '#6FD772';  // FFFF99 黄
        } else if (ratio <= 0.75) {
            return '#FFC95A';//'#FFBB11'; 橙
        } else {
            return '#Fd674F';// FF3357 '#FF6138'; //红色，表示已用的很多
        }
    },

    isDealwith: function (node) {
        if (!node) return false;
        if (this.isVirtualFunction) {
            return this.isVirtualFunction(node);
        }
        var data = this.sceneManager.getNodeData(node);
        if (!data) return false;
        // var type = this.sceneManager.dataManager.getDataTypeForData(data);
        // if(!type) return false;
        // if(type._model.indexOf('.rack') >0){
        //     return true;
        // }
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId().toLowerCase() == 'rack') {
            return true;
        }
        return false;
    },

    getDataSpace: function (data) {
        if (!data) {
            return null;
        }
        var space = this.spaceMap[data.getId()];
        if (!space) {
            var dataSpace = this.spaceManager.computeSpace(data);
            if (dataSpace && (dataSpace instanceof it.Space1)) {
                this.spaceMap[data.getId()] = dataSpace;
                space = dataSpace;
            }
        }
        return space;
    },

    _dealWithOneNode: function (node) {
        var uNumber = this.getUNumber();
        if (!uNumber) {
            uNumber = 1;
        }
        if (node) {
            if (this.isDealwith(node)) {
                var data = this.sceneManager.getNodeData(node);
                if (!data) return;
                // var space = this.spaceMap[data.getId()]; 
                // if (!space) {
                //     space = this.spaceManager.computeSpace(data);
                //     if(space && (space instanceof it.Space1)){
                //        this.spaceMap[data.getId()] = space;
                //     }
                // }
                var space = this.getDataSpace(data);
                var count = 0;
                // if(space && (space instanceof it.Space1)){
                if (space) {
                    // this.spaceMap[it.SceneManager.getNodeDataId(node)] = space;
                    var maxEmpSerSpace = 0, totalEmpSpace = space.getTotal() - space.getOccupation();
                    var empList = space.getEmptyList();
                    if (empList && empList.length > 0) {
                        for (var i = 0; i < empList.length; i++) {
                            var ep = empList[i];
                            if (ep.total > maxEmpSerSpace) {
                                maxEmpSerSpace = ep.total;
                            }
                            if (ep.total >= uNumber) {
                                count += Math.floor(ep.total / uNumber);
                            }
                        }
                    }
                    data.setUserData('dyna_user_data_totalSpace', space.getTotal());//总空间
                    data.setUserData('dyna_user_data_totalOccupation', space.getOccupation());//总的占用空间
                    data.setUserData('dyna_user_data_maxSerSpace', maxEmpSerSpace);//最大的连续空间
                    data.setUserData('dyna_user_data_totalEmpSpace', totalEmpSpace);//总的剩余空间
                    data.setUserData('dyna_user_data_totalCount', parseInt(space.getTotal() / uNumber));//总共可以放“uNumber”U的个数
                    data.setUserData('dyna_user_data_empCount', count);//空余的“uNumber”U的个数
                    this.virtualNode.push(node);
                }
            }
        }
    },

    /**
     * 获取所有的Node，此方法在这里没什么用
     * @returns {*}
     */
    getAllNodes: function () {
        var nodeMap = this.sceneManager.dataNodeMap;
        if (!nodeMap) return null;
        var allNodes = [];
        for (var id in nodeMap) {
            var node = nodeMap[id];
            if (node && this.isDealwith(node)) {
                var data = this.sceneManager.getNodeData(node);
                if (!data) return;
                // var space = this.spaceManager.computeSpace(data);
                // if (space && (space instanceof it.Space1)) {
                var space = this.getDataSpace(data);
                if (space) {
                    allNodes.push(node);
                }
            }
        }
        return allNodes;
    },

    /**
     * 获取当前场景下的所有的node
     */
    getSceneNodes: function () {
        var sceneNodes = [];
        var sceneDatas = this.sceneManager.getSceneDatas();
        if (sceneDatas) {
            var nodeMaps = this.sceneManager.dataNodeMap;
            for (var id in sceneDatas) {
                var node = nodeMaps[id];
                var data = sceneDatas[id];
                if (node && data && this.isDealwith(node)) {
                    // var space = this.spaceManager.computeSpace(data);
                    var space = this.getDataSpace(data);
                    // if (space && (space instanceof it.Space1)) {
                    if (space) {
                        this._dealWithOneNode(node);
                        sceneNodes.push(node);
                    }
                }
            }
        }
        return sceneNodes;
    },

    initAllNodes: function () {
        var nodeMap = this.sceneManager.dataNodeMap;
        if (!nodeMap) return null;
        this.virtualNode = [];
        for (var id in nodeMap) {
            var node = nodeMap[id];
            var data = this.sceneManager.getNodeData(node);
            if (data) {
                data.setUserData('dyna_user_data_totalCount', null);//计算的时候清空
                data.setUserData('dyna_user_data_empCount', null);
            }
            this._dealWithOneNode(node);
        }
        return this.virtualNode;
    }

});
it.Tab = function () {

};

mono.extend(it.Tab, Object, {

    _getTargetLi: function (element) {
        if (!element) return null;
        if (element.tagName && element.tagName.toUpperCase() == 'LI') {
            return element;
        } else if (element.parentElement) {
            return arguments.callee(element.parentElement);
        }
        return null;
    },

    _onclick: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        }
        var targetLi = this._getTargetLi(event.originalEvent.target);
        var href = targetLi.getAttribute('href'); // 有可能点中的是这个
        if (!href) {
            href = targetLi.childNodes[0].getAttribute('href');
        }

        if (href && href.length > 0) {
            var id = href.substring(1, href.length);

            if ($('#' + id)[0] && $('#' + id)[0].children && $('#' + id)[0].children.length > 0) { //如果类似于只是个按钮，比如点击tab只让旋转，并且该tab根本就没有content
                //清除之前的选中的li的hover,并且放到了这里，当有内容的时候才清除，像旋转就不清除
                this._clearHover();
                targetLi.className = 'hover';
                //隐藏所有的content的item
                $('.contentbox div.tab-pane').hide(); // 这种方式也会隐藏掉contentbox的子孙类的div
                $('#' + id).show();
            }
        }
    },

    _clearHover: function () {
        var menuItems = $('.property-pane-tab .menu ul li');
        if (menuItems && menuItems.length > 0) {
            for (var i = 0; i < menuItems.length; i++) {
                var menuItem = menuItems[i];
                if (menuItem && menuItem.className) {
                    menuItem.className = "";
                }
            }
        }
    },

    initAll: function () {
        var self = this;
        $('.property-pane-tab .menu ul li').click(function (event) {
            self._onclick(event);
        });
    }

});

it.PropertyPane = function (parentDiv) {
    this.propertyPane = $("<div class='property-pane it-shadow'></div>");
    this.propertyTab = $("<div class='property-pane-tab'></div>");
    this.propertyItemsDiv = $("<div class='menu'></div>");//去掉it-shadow
    this.propertyItemsPane = $("<ul></ul>");
    this.propertyTabContent = $('<div class="contentbox scroll-class">'); //tab-content scroll-class 去掉 it-shadow
    this.propertyItemsDiv.append(this.propertyItemsPane);
    this.propertyTab.append(this.propertyItemsDiv);
    this.propertyTab.append(this.propertyTabContent);
    this.propertyPane.append(this.propertyTab);
    if (!parentDiv) {
        parentDiv = document.body;
    }
    parentDiv.appendChild(this.propertyPane[0]);
    this.closeDiv = $('<div class="it-property-title"></div>'); //it-property-title it-shadow 去掉it-shadow
    this.propertyPane.prepend(this.closeDiv);

    this.isvisible;
    this.tab = new it.Tab();
    this.hide();
};

mono.extend(it.PropertyPane, Object, {

    _createTitle: function (titleText) {
        if (!titleText) {
            titleText = '资产属性';
        }
        var titleDiv = $('<span>' + titleText + '</span>');
        var closeIcon = $('<div class="close"></div>');
        var self = this;
        closeIcon.click(function (e) {
            self.hide();
        });
        this.closeDiv.append(titleDiv);
        this.closeDiv.append(closeIcon);
    },

    clear: function () {
        this.propertyItemsPane.empty();
        this.propertyTabContent.empty();
        this.closeDiv.empty();
    },

//{title:title,items:[{icon:icon,onclick:callback,title:t,properties:pro/或者是数组[{key:value},{}]},{icon:icon.....}]}
    /**
     * showIndex表示的是要显示哪一个tab
     */
    setData: function (contents, node, titleText, showIndex) {
        this.clear();
        this._createTitle(titleText);
        if (!contents || !contents.items || contents.items < 1) return;
        var self = this;
        var items = contents.items;
        for (var i = 0; i < items.length; i++) {
            var item = items[i]; //{icon:icon,title:t,propertyObj:pro/或者是数组[{key:value},{}]}
            if (!item) {
                continue;
            }
            if (item.isShow && !item.isShow(node)) {
                continue;
            }
            var href = "tab_" + i;
            var title = item.title;
            //  var icon = item.icon;
            var className = item.className;
            var on_click = item.onclick;
            var propertyObj = item.properties;
            var isGroup = item.isGroup || item.isGrop;
            if (i == 0) {
                //        this.addTab(href,title,propertyObj,icon,true,isGroup,on_click);
                this.addTab(href, title, propertyObj, className, true, isGroup, on_click, node);
            } else {
                //    this.addTab(href,title,propertyObj,icon,false,isGroup,on_click);
                this.addTab(href, title, propertyObj, className, false, isGroup, on_click, node);
            }
        }

        //实现tooltip
        this.showTooltip({
            id: '.menu ul li a',
            parent: this.propertyPane,
            offsetY: 10
        });

        this.tab.initAll();
        this.showTabByIndex(showIndex);
    },

    /**
     *
     * @param href
     * @param title
     * @param contentObj
     * @param icon
     * @param visible
     * @param onclick
     * @param isButton 如果只是button的话，那它只是个button,没有内容，也并不会像tab那样有选中的效果
     * @param data
     */
    addTab: function (href, title, contentObj, className, visible, isGroup, onclick, node) {
        var tabItem = $('<li ><a href="#' + href + '" rel = "' + title + '" class= ' + className + ' ></a></li>');

        if (visible) {
            tabItem.show();
            tabItem.attr('class', 'hover');
        }
        if (onclick) {
            tabItem.click(onclick);
        }

        this.propertyItemsPane.append(tabItem);
        var tabItemContent = $('<div class="tab-pane" id="' + href + '"></div>');
        if (visible) {
            tabItemContent.show();
        }
        tabItemContent.append(this.createTableItemContentByObj(contentObj, isGroup, node));
        this.propertyTabContent.append(tabItemContent);
    },

    showTabByIndex: function (index) {
        // var tab = $('[href="#tab_"'+index+']');
        var id = 'tab_' + parseInt(index || 0);
        // $('[href="#tab_0"]').parent().attr('class','hover')
        if ($('#' + id)[0]
            && $('#' + id)[0].children
            && $('#' + id)[0].children.length > 0
            && $('[href="#' + id + '"]')
            && $('[href="#' + id + '"]').length > 0
        ) {
            this.tab._clearHover();
            // targetLi.className = 'hover';
            $('[href="#' + id + '"]').parent().attr('class', 'hover');
            $('.contentbox div.tab-pane').hide(); // 这种方式也会隐藏掉contentbox的子孙类的div
            $('#' + id).show();
        }
    },

    createTableItemContentByObj: function (contentObj, isGroup, node) {
        if (!contentObj) {
            return;
        }
        var table = $('<form class="form-horizontal" role="form"></form>');
        var src = contentObj.src;
        if (typeof(src) == 'function') {
            src = src(node);
        }
        if (contentObj.isIframe && src) { //如果是iframe，并且url不为空时，则直接嵌进去
            table = $('<form class="form-horizontal" role="form" style="position:relative;height:100%;width:100%"></form>');
            var pane = '<iframe src="' + src + '" style="position: relative;height: 100%;width: 100%"></iframe>';
            table.append(pane);
        } else if (contentObj instanceof Array) {  //[{name:'name',value:'维修信息dddd',callback:callback},{name:'id',value:'ssddfr',callback:callback}]
            if (contentObj.length > 0) {
                if (contentObj.title) {
                    var head = this._createTableRow(contentObj.title);
                    if (head) {
                        table.append(head);
                    }
                }
                for (var i = 0; i < contentObj.length; i++) {
                    var proItem = contentObj[i];
                    if (proItem) {
                        var callback = proItem.callback;
                        var mousemove = proItem.mousemove;
                        if (proItem.values) {
                            var values = proItem.values;
                            var row = this._createTableRow(values, (i + 1), callback, mousemove);
                            if (row) {
                                table.append(row);
                            }
                        } else if (proItem.name) {
                            var name = proItem.name;
                            var value = proItem.value;
                            var row = this._createKeyValueRow(name, value, isGroup, (i + 1), callback, mousemove);//默认的是有head的row需要间隔色
                            if (row) {
                                table.append(row);
                            }
                        }
                    }
                }
            }
        } else { // 对于一个object，就处理它所有的property
            for (var pro in contentObj) {
                if (typeof(contentObj[pro]) != 'function') {
                    var value = contentObj[pro];
                    var valText = value,
                        onclick = null,
                        style = null,
                        classname = null,
                        isButton = false;
                    if (value) {
                        if (value.value != undefined) {
                            valText = value.value;
                        }
                        if (value.onclick) {
                            onclick = value.onclick;
                        }
                        if (value.isButton && value.isButton == true) {
                            isButton = true;
                        }
                        if (value.style) {
                            style = value.style;
                        }
                        classname = value.classname;
                    }
                    var row = this._createKeyValueRow(pro, valText, isGroup, null, onclick, null, isButton, style, classname, node);
                    if (row) {
                        table.append(row);
                    }
                }
            }
        }
        return table;
    },

    _createTableHead: function (titles) {
        if (!titles) return;
        var row = $('<div class="form-group-no-margin"></div>');
        if (titles instanceof Array && titles.length > 0) {
            var count = Math.floor(12 / titles.length);
            if (count > 1) {
                var className = "col-sm-" + count + " table-label-min label-inline-block";
                for (var i = 0; i < titles.length; i++) {
                    var val = titles[i];
                    if (val) {
                        var label_Value = $('<label class="' + className + '">' + val + '</label>');
                        row.append(label_Value);
                    }
                }
                return row;
            }
        }
        else {
            // 暂时不支持
//        for(var pro in titles){
//            if(typeof(titles[pro]) != 'function') {
//                var value = titles[pro];
//                var row = this._createKeyValueRow(pro,value,isGroup);
//                if(row){
//                    table.append(row);
//                }
//            }
//        }
        }
    },

    /**
     *
     * @param label
     * @param value
     * @param isGroup 表示是否分组，分组的话，就将内容区域分成了两部分
     * @param hasHead
     * @param isTableRow
     * @param i
     * @param callback
     * @param mousemove
     * @returns {*}
     * @private
     */
    _createKeyValueRow: function (label, value, isGroup, i, onclick, mousemove, isButton, style, classname, node) {
        if (!label && !value) return null;
        var rowClass = 'form-group-no-margin';
        var row = $('<div class="' + rowClass + '"> </div>');
        var btnClass = '';
        if (isButton) {
            btnClass = 'col-btn';
        }
        var callback = function (e) {
            onclick && onclick(e, node);
        }
        if (value
            && typeof(value) != 'string' //还有可能是int类型
            && !(value instanceof Array)) { // 特别判断，可能不是key-value的那种方式，有可能是分隔符
            if (value.isTitle) {
                var size = 15 - label.length;
                var lbText = '';
                if (size > 0) {
                    for (var i = 0; i < size / 2; i++) {
                        lbText += '—';
                    }
                    ;
                }
                label = lbText + label + lbText;
                var labelNameClass = btnClass + '　col-sm-12 label-min label-inline-block ';
                var label_Name = $('<label style = "text-align:center" class="' + labelNameClass + '">' + label + '</label>');
                row.append(label_Name);
                return row;
            }
        }
        if (label) {
            label += ':';
        }
        var labelNameClass = 'col-sm-4 label-min label-inline-block';
        var label_Name = $('<label class="' + labelNameClass + '">' + label + '</label>');
        if (this.propertyPane.width() > 300) {
            label_Name.css('max-width', '100px');
        }
        row.append(label_Name);

        if (isGroup == undefined || isGroup == null) {
            isGroup = true;
        }
        var labelClass = 'contral-width label-inline-block';
        var label_Value = null;
        if (value instanceof Array && value.length > 0) {
            var div_Value = $('<div class = "col-sm-8 multi-label-value"></div>');
            if (this.propertyPane.width() > 300) {
                // div_Value.css('width',parseInt(this.propertyPane.width())-120);
            }
            if (!isGroup) {
                for (var i = 0; i < value.length; i++) {
                    var val = value[i];
                    if (val) {
                        var label_Value = $('<label class="' + labelClass + '">' + val + '</label>');
                        div_Value.append(label_Value);
                    }
                }
            } else {
                var step = 2;
                for (var i = 0; i < value.length; i += step) {
                    var val = value[i];
                    if (val) {
                        var val_0 = value[i];
                        var val_1 = value[i + 1];

                        var row_group = $('<div class = "row"></div>');
                        var row_div_0 = $('<div class = "col-xs-6 col-sm-6"></div>');
                        var row_div_1 = $('<div class = "col-xs-6 col-sm-6"></div>');
                        val_0 && row_group.append(row_div_0);
                        val_1 && row_group.append(row_div_1);
                        div_Value.append(row_group);

                        var col_v = $('<label class="' + labelClass + '">' + value[i] + '</label>');
                        row_div_0.append(col_v);

                        var col_v = $('<label class="' + labelClass + '">' + value[i + 1] + '</label>');
                        row_div_1.append(col_v);
                    }
                }
            }
            row.append(div_Value);
        } else {
            style = style || '';
            classname = classname || '';
            var hoverClass = '';
            if (!btnClass && callback) {
                // hoverClass = 'label_hover'; //remark 2016-12-29
            }
            ;
            label_Value = $('<label class=" ' + classname + btnClass + hoverClass + ' col-sm-8 label-value label-inline-block " style="' + style + '">' + value + '</label>');
            if (this.propertyPane.width() > 300) {
                // label_Value.css('width',parseInt(this.propertyPane.width())-120);
            }
            row.append(label_Value);
        }
        if (isButton && label_Value) {
            if (callback) {
                label_Value.click(callback);
            }
            if (mousemove) {
                label_Value.mousemove(mousemove);
            }
        } else {
            if (callback) {
                row.click(callback);
            }
            if (mousemove) {
                row.mousemove(mousemove);
            }
        }

        return row;
    },

    _createTableRow: function (values, i, callback, mousemove) {
        if (!values || values.length <= 0) return null;
        if (!(values instanceof Array)) {
            return;
        }
        var rowClass = 'form-group-no-margin';
        var count = Math.floor(12 / (values.length));
        if (count <= 0) return;
        if (i && i % 2 == 1) {
            rowClass = 'form-group-table-margin t-odd';
        } else {
            rowClass = 'form-group-table-margin';
        }

        var row = $('<div class="' + rowClass + '"> </div>');


        for (var j = 0; j < values.length; j++) {
            var val = values[j];
            if (val) {
                var text = val;
                var columnCount = count;
                if (val.c_width && parseInt(val.c_width)) {
                    columnCount = parseInt(val.c_width);
                }
//                if (val.text) { // 有可能确实为空哦
                if (val.text != undefined) {
                    text = val.text;
                }

                var labelNameClass = 'col-sm-' + columnCount + ' table-label-min label-inline-block';
                var label_Value = $('<label class="' + labelNameClass + '">' + text + '</label>');
                row.append(label_Value);
            }
        }

        if (callback) {
            row.click(callback);
        }
        if (mousemove) {
            row.mousemove(mousemove);
        }
        return row;
    },

    show: function (content, node, title, offset, showIndex) {
        if (offset) {
            this.propertyPane.css('left', 'auto');
            this.propertyPane.css('right', 'auto');
            this.propertyPane.css('top', 'auto');
            this.propertyPane.css('bottom', 'auto');
            if (offset.left != null && offset.left != undefined) {
                this.propertyPane.css('left', parseInt(offset.left) + 'px');
            }
            if (offset.right != null && offset.right != undefined) {
                if (this.propertyPane.parent() && this.propertyPane.parent().css('width')) {
                    var left = parseInt(this.propertyPane.parent().css('width')) - parseInt(this.propertyPane.css('width')) - offset.right;
                    this.propertyPane.css('left', left + 'px');
                } else {
                    this.propertyPane.css('right', parseInt(offset.right) + 'px');
                }
            }
            if (offset.bottom != null && offset.bottom != undefined) {
                if (this.propertyPane.parent() && this.propertyPane.parent().css('height')) {
                    var top = parseInt(this.propertyPane.parent().css('height')) - parseInt(this.propertyPane.css('height')) - offset.bottom;
                    this.propertyPane.css('top', top + 'px');
                } else {
                    this.propertyPane.css('bottom', parseInt(offset.bottom) + 'px');
                }
            }
            if (offset.top != null && offset.top != undefined) {
                this.propertyPane.css('top', parseInt(offset.top) + 'px');
            }
        }
        this.setData(content, node, title, showIndex);
        this.propertyPane.show();
        this.isvisible = true;
    },

    hide : function () {
        this.propertyPane.hide();
        this.clear(); //html也都是释放掉，html中可能有click，click中可能会引用node。2017-10-13
        this.isvisible = false;
    },

    /**
     * 显示tooltip
     * @param obj格式如下：
     * {
     * id:选则器的规则，如:'.menu ul li a'、'#maindivId'
     * selector,选择器处理后的item，如$('.menu ul li a')、$('#maindivId')
     * text:,tooltip的text，如果是用id选择器批量处理的话，那得是target上的rel
     * parent:,toolTip所在的panel
     * offsetY:,y方向上的偏移量
     * offsetX:x方向上的偏移量
     * }
     */
    showTooltip: function (obj) {
        if (!obj || !obj.parent) {
            return;
        }
        var offsetY = obj.offsetY ? obj.offsetY : 0, offsetX = obj.offsetX ? obj.offsetX : 0;
        if (obj.id) {
            $(obj.id).mouseover(
                function (e) {
                    var myTitle = e.target.rel;
                    var tooltip = $("<div id='tooltip' class='tap-tooltip-content it-shadow'>" + myTitle + "</div>");
                    obj.parent.append(tooltip);
                    var offsetTop = e.target.offsetTop - e.target.offsetHeight + offsetY;
                    var offsetLeft = e.target.offsetLeft + e.target.offsetWidth + offsetX;
                    tooltip.css('top', offsetTop);
                    tooltip.css('left', offsetLeft);
                }
            ).mouseout(
                function () {
                    $("#tooltip").remove();
                }
            );
        } else if (obj.selector) {
            if (!obj.text) {
                return;
            }
            obj.selector.mouseover(
                function (e) {
                    var tooltip = $("<div id='tooltip' class='tap-tooltip-content it-shadow'>" + obj.text + "</div>");
                    obj.parent.append(tooltip);
                    var offsetTop = e.target.offsetTop - e.target.offsetHeight + offsetY;
                    var offsetLeft = e.target.offsetLeft + e.target.offsetWidth + offsetX;
                    tooltip.css('top', offsetTop);
                    tooltip.css('left', offsetLeft);
                }
            ).mouseout(
                function () {
                    $("#tooltip").remove();
                }
            );
        }
    },

    setWidthForPropertyPane: function (width) { //setPanelWidth
        var width = width || "23%";
        this.propertyPane.css('width', width);
    },

    setHeightForPropertyPane: function (height) { //setPanelWHeight
        var height = height || "30%";
        this.propertyPane.css('height', height);
    }

});


it.PropertyManager = function (sceneManager,mainParentDiv) {
    this.sceneManager = null;
    this.dataManager = null;
    this.mainParentDiv = mainParentDiv;
    //注意：2D中也要用到，因此在切换的时候得切换parent,可是放到rootView上时，dialog的样式会受rootView的style的影响
    var parentDiv = mainParentDiv || (sceneManager != null && sceneManager.network3d !=null ? sceneManager.network3d.getRootView():null);
//    parentDiv.style.position = 'absolute'; // 要想孩子相对与父亲的话，父亲的position一定不能为空
    this.propertyPane = new it.PropertyPane(parentDiv);
    this.setSceneManager(sceneManager);
    this.getContentFunction = null; // 整个属性框的内容全部重新定义，注意格式，返回的是一个数值
    this.nodeDefaultInfoFunction = null; // node默认的基本信息
    this.mouseoverDevFunction = null; //鼠标划过设备时所要
    this.devClickFunction = null; //鼠标点击设备时，默认的是移动camera至设备
//    this.devHeaderFunction = null; //显示设备table的表头，注意格式，是一个数值，[{text:'abc'}]
//    this.devColumnFunciton = null; //设备table的每一行的内容，注意格式，同Header
    this.devListSortFunction = null;//设备table的排序

//    this.devTableRule['rack'] = [{header:'列1',width:'6',property:fun,},{header:'列2',..},..];
    this.devTableRule = {};
    this.dataInfoRule = {};
    this.statInfoRule = {};
    this.otherInfoRule = {}; //扩展的,放在后面的,可以是数组,也可以是一个对象。如：{'rack':[tab1,tab2],'equipment':{tab1}}
    this.preExtInfoRule = {}; //扩展的,但是是放在最前面的,可以是数组,也可以是一个对象
    this.width,this.height;
    this.defaultShowIndexFunction = null;
};

mono.extend(it.PropertyManager, Object, {

    /**
     * 此处的默认实现1，类似于机柜
     * @param rackTypes
     */
    setDefaultRackRule : function(rackTypes){
        if(!rackTypes || rackTypes.length < 1) return;
        if(!(rackTypes instanceof Array)){
            rackTypes = [rackTypes];
        }
        var self = this;
        var dataInfo = [
            {label:'资产编号',property:function(data){
                return data.getId();
            }},
            {label:'用户Id',property:'userId'},//默认的话在userMap中，否则则通过function自己去实现
            {label:'制造商',property:'制造商'}
        ];
        var devTable = [
            {header: '设备编号', width: '5',
                property: function (childData) {
                    return childData.getId();
                }},
            {header: '类型', width: 3,
                property: function (childData) {
                    var dataType = self.dataManager.getDataTypeForData(childData);
                    if(dataType && dataType.getDescription()){
                        return dataType.getDescription();
                    }
                    if (dataType && dataType.getModel()) {
                        return dataType.getModel();
                    }
                }
            },
            {header: '位置', width: 4,
                property: function (childData) {
                    var location = '';
                    var dataType = self.dataManager.getDataTypeForData(childData);
                    var sizeU = 1;
                    if (dataType
                        && dataType.getSize()
                        && dataType.getSize().ySize) {
                        sizeU = dataType.getSize().ySize;
                    }
                    if (childData.getLocation()
                        && childData.getLocation().y) {
                        location = childData.getLocation().y + 'U-' + (childData.getLocation().y + sizeU) + 'U(' + sizeU + 'U)';
                    }
                    return location;
                }}
        ];
        var statInfo = {
            value : function(data){
                var spManager = new it.SpaceManager(self.dataManager,self.sceneManager);
                var spObj = spManager.computeSpace(data);
                if(spObj && spObj instanceof it.Space1){
                    var empty_space_list = [];//['1U-2U(2U)','3U-5U(3U)','10U-12U(2U)'];
                    if(spObj._emptyList && spObj._emptyList.length > 0){
                        for(var i = 0 ;i < spObj._emptyList.length ; i++){
                            var empObj = spObj._emptyList[i];
                            empty_space_list.push(empObj.start+'U-'+empObj.end+'U('+empObj.total+'U)');
                        }
                    }
                    var emp_obj = {};
                    emp_obj.已用U数 =  spObj._occupation + 'U';
                    emp_obj.还剩U数 = (spObj._total - spObj._occupation) + 'U';
                    emp_obj.空余明细 = empty_space_list;
                    return emp_obj;
                }
            }
        };

        for(var i = 0 ; i <rackTypes.length ; i++){
            var type = rackTypes[i];
            if(type){
                this.dataInfoRule[type] = dataInfo;
                this.devTableRule[type] = devTable;
                this.statInfoRule[type] = statInfo;
            }
        }
    },

    /**
     * 这里是默认实现2，类似于设备的那种
     * @param equipTypes
     */
    setDefaultEquipmentRule : function(equipTypes){
        if(!equipTypes || equipTypes.length < 1){
            return;
        }
        if(!(equipTypes instanceof Array)){
            equipTypes = [equipTypes];
        }
        var self = this;
        var infoRule = [
            {label:'资产编号',property:function(data){
                return data.getId();
            }},
            { label:'尺寸',property:function(data){
                var dataType = self.dataManager.getDataTypeForData(data);
                var sizeU = 1;
                if (dataType
                    && dataType.getSize()
                    && dataType.getSize().ySize) {
                    sizeU = dataType.getSize().ySize;
                }
                return sizeU;
            }
            },
            {label:'制造商',property:'制造商'}
        ];
        for(var i = 0 ; i < equipTypes.length; i++){
            var type = equipTypes[i];
            if(type){
                this.dataInfoRule[type] = infoRule;
            }
        }
    },

    /**
     * 是否显示，默认的是返回true的
     */
    isShow : function(dataOrId){
        return true;
    },

    show : function(dataOrId,showIndex){
        if(!this.isShow(dataOrId)){
            return ;
        }
        if(!dataOrId){
            return ;
        }
        var data = null,link = null,dataNode = null;
        if(dataOrId instanceof it.Data){
            data = dataOrId;
        }else if(dataOrId instanceof it.Link){
            dataNode = this.sceneManager.getLinkNodeById(dataOrId);
        }else{
            data = this.dataManager.getDataById(dataOrId);
        }
        if(!dataNode){
            dataNode = this.sceneManager.getNodeByDataOrId(data);
        }
        var contents = this.getContentByNode(dataNode);
        var title = this.getTitleByNode(dataOrId);
        var offset = this.getOffset(dataNode);
        this.propertyPane.show({items:contents},dataNode,title,offset,showIndex);
    },

    showTabByIndex : function(index){
        this.propertyPane.showTabByIndex(index);
    },

    getDefaultShowIndex: function(data,node,content){
        if(this.defaultShowIndexFunction){
            return this.defaultShowIndexFunction(data,node,content);
        }
    },

    setSceneManager : function(sceneManager){
        if(!sceneManager) {
            return;
        }
        this.sceneManager = sceneManager;
        this.dataManager = sceneManager.dataManager;
        var defaultEventHandler = this.defaultEventHandler = sceneManager.viewManager3d.getDefaultEventHandler();
        if(defaultEventHandler){
            var self = this;
            var defaultAfterLookAtFun = defaultEventHandler.afterLookAtFunction;
            defaultEventHandler.afterLookAtFunction = function(node,cNode){
                if (defaultAfterLookAtFun) {
                    defaultAfterLookAtFun(node,cNode);
                }
                var itData = null;
                if (node instanceof it.Data) {
                      itData = node;
                    node = self.sceneManager.getNodeByDataOrId(node);
                }else{
                      itData = self.sceneManager.getNodeData(node);
                }
                var data = self.getContentByNode(node);
                if(data && data.length > 0 && self.isShow(data)){
                    var title = self.getTitleByNode(node);
                    var offset = self.getOffset(node);
                    var index = self.getDefaultShowIndex(itData,node,{items:data});
                    self.propertyPane.show({items:data},node,title,offset,index);
                }else{
                    self.propertyPane.hide();
                }
            }
        }
        // 2D的Network中显示属性框
        var eventHandel = new it.EventHandler();
        eventHandel.shouldHandleDoubleClickElement = function(){
            return true;
        };
        eventHandel.handleDoubleClickElement = function(node,network,data,element){
            var content = self.getContentByNode(node);
            if(content && content.length > 0){
                var title = self.getTitleByNode(data);
                var offset = self.getOffset(node);
                self.propertyPane.show({items:content},title,offset);
            }else{
                self.propertyPane.hide();
            }
        };
        this.sceneManager.addSceneChangeListener(function(e){
            self.propertyPane.hide(); // 场景切换时隐藏已有的。
        });
        if (this.sceneManager.viewManager2d) {
            this.sceneManager.viewManager2d.addEventHandler(eventHandel);
        }
    },
    
    setPropertyPaneSize : function(width,height){
        this.width = width;
        this.height = height;
    },

    getContentByNode : function(node){
        if (this.getContentFunction) {
            var obj = this.getContentFunction(node);
            if (!(obj instanceof Array)) {
                return [obj];
            } else {
                return obj;
            }
        }
        // remark by Kevin 2016-11-24 不用network的rootView了，用传过来的(如果有的话)
        if (!this.mainParentDiv) {
            var parentDiv = null;
            if (node instanceof twaver.Element) { //2D的network中
                parentDiv = this.sceneManager.network2d.getView();
            } else {
                parentDiv = this.sceneManager.network3d.getRootView();
            }
            if (parentDiv) {
                parentDiv.appendChild(this.propertyPane.propertyPane[0]);
            }
        }
        var link = this.sceneManager.getLinkData(node);
        if (link && (link instanceof it.Link)) {
            this.propertyPane.setWidthForPropertyPane('30%');
            return  this.createDefaultLinkContent(node);
        } else {
            if (this.width && parseInt(this.width)){
                this.propertyPane.setWidthForPropertyPane(parseInt(this.width) + 'px');
            }
            if (this.height &&　parseInt(this.height)) {
                this.propertyPane.setHeightForPropertyPane(parseInt(this.height) + 'px');
            }
            // this.propertyPane.setWidthForPropertyPane();
            return this.createDefaultDataContent(node);
        }
    },

    /**
     * 根据node创建属性框的title
     * @param nodeOrData
     * @returns {string}
     */
    getTitleByNode : function(nodeOrData){
        var id = '';
        if(!nodeOrData){
            return '';
        }
        if(nodeOrData instanceof it.Data){
            id = ':' + nodeOrData.getId();
        }else if(this.sceneManager && this.sceneManager.getNodeData(nodeOrData)){
            id = ':' + this.sceneManager.getNodeData(nodeOrData).getId();
        }
        return '资产编号' + id;
    },

    getOffset:function(nodeOrData){
        return {left:100,top:100};
    },

    /**
     * 属性框中内容的默认实现
     * 对于通道和机柜，它们有孩子，还得支持排序
     * tab1：基本信息；
     * tab2：设备信息；
     * tab3：统计
     * @param node
     */
    createDefaultDataContent : function(node){
        var preExtInfo = this.getPreExtInfo(node);
        var generalInfo = this.getGeneralInfo(node);
        var devInfo = this.getDevListInfo(node);
        var statInfo = this.getStatInfo(node);
        var others = this.getOthers(node);
        var content = [];
        if (preExtInfo) {
            if(preExtInfo instanceof Array){
                for(var i = 0 ; i < preExtInfo.length ; i++){
                    content.push(preExtInfo[i]);
                }
            }else{
                content.push(preExtInfo);
            }
        }
        if(generalInfo){
            content.push(generalInfo);
        }
        if(devInfo){
            content.push(devInfo);
        }
        if(statInfo){
            content.push(statInfo);
        }
        if(others){
            if(others instanceof Array){
                for(var i = 0 ; i < others.length ; i++){
                    content.push(others[i]);
                }
            }else{
                content.push(others);
            }
        }
        return content;
    },

    /**
     * 创建Link的属性框的显示内容
     * @param linkOrId
     * @returns {null}
     */
    createDefaultLinkContent : function(linkOrId){
        var link = null;
        if(linkOrId instanceof it.Link){
            link = linkOrId;
        }else if(linkOrId instanceof mono.Element){
            link = this.sceneManager.getLinkData(linkOrId);
        }else{
            link = this.dataManager.getLinkById(linkOrId);
        }
        if(!link){
            return null;
        }
        var fromId = link.getFromId(),toId = link.getToId();
        var fromDataType = this.dataManager.getDataTypeForData(fromId);
        var toDataType = this.dataManager.getDataTypeForData(toId);
        var fTypeDesc = fromDataType?fromDataType.getDescription():'';
        var tTypeDesc = toDataType?toDataType.getDescription():'';
        var content = {};
        content.线袋编号 = link.getName();
        content.线袋类型 = link.getType();
        content.A = fromId || '';
        content.A端口编号 = link.getFromPortId();
        content.B = toId || '';
        content.B端口编号 = link.getToPortId();
        content.连接设备1 = "设备编号:"+(fromId || '')+"  设备类型:"+fTypeDesc + ' 端口编号:' + link.getFromPortId();
        content.连接设备2 = "设备编号:"+(toId || '')+"  设备类型:"+tTypeDesc + ' 端口编号:' + link.getToPortId();
        var baseInfo = {title: '线袋信息',
            properties: content,
            className:'it-property-basic',
            onclick: function (e) {
            }
        };

        var labelInfo = {
            title:'标签',
            properties:null,
            className:'it-property-equip',
        }
        return [baseInfo,labelInfo];
    },

    /**
     * 根据rule创建基本信息
     * @param node
     * @returns {*}
     */
    getGeneralInfo: function(node) {
        if (!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        // if (!data) return null;
        var content = null;
        var dataType = this.dataManager.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId()) {
            var ruleInfo = this.dataInfoRule[dataType.getCategoryId()]; //dataType.getModel() dataType.getId()
            if (ruleInfo && ruleInfo.length > 0) {
                for (var i = 0; i < ruleInfo.length; i++) {
                    var rule = ruleInfo[i];
                    if (rule) {
                        var label = rule.label;
                        var value = '';
                        if (rule.property) {
                            if (typeof(rule.property) == 'function') {
                                value = rule.property(data);
                            } else {
                                value = data.getUserData(rule.property);
                            }
                        }
                        var isButton = false;
                        if (rule.isButton) {
                            if (typeof(rule.isButton) == 'function') {
                                isButton = rule.isButton(data);
                            }else{
                                isButton = rule.isButton;
                            }
                        }
                        var style = '';
                        if (rule.style) {
                            if (typeof(rule.style) == 'function') {
                                style = rule.style(data);
                            }else{
                                style = rule.style;
                            }
                        }
                        var classname = rule.classname;
                        var onclick = rule.onclick;
                        if (!content) {
                            content = {};
                        }
                        // content[label] = value || '';
                         content[label] = {value:value||'',isButton:isButton,style:style,onclick:onclick,classname:classname,origin:rule.origin}; //update 2016-12-29 是更丰富
                    }
                }
            }
        }
        if (!content && this.nodeDefaultInfoFunction && this.nodeDefaultInfoFunction(node)) {
            content = this.nodeDefaultInfoFunction(node);
        }
        if (!content) {
            return null;
        }
        var obj = {
            title: '基本',
            properties: content,
            className: 'it-property-basic',
            onclick: function(e) {}
        };
        return obj;
    },

    /**
     * 孩子列表的默认实现
     * 1、对于机柜的孩子和通道的孩子所显示的信息不太一样；
     * 2、支持排序；
     * 3、支持点击；
     * @param node
     * @returns {null}
     */
    getDevListInfo : function(node){
        if(!node || !this.dataManager) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var children = data.getChildren();//this.dataManager.getChildren(data);
        var devList = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !dataType.getCategoryId()) return null;
        var ruleInfo = this.devTableRule[dataType.getCategoryId()]; //dataType.getModel() dataType.getId()
        if(!ruleInfo) return null;
        devList.title = this.createTableHeaderByRuleInfo(ruleInfo);
        if(children && children.size() > 0){
            var self = this;
            children.forEach(function(child){
                if(!child) return;
                var conlumns = self.createTableRowByRuleInfo(ruleInfo,child);
                var devInfo = {
                    values:conlumns, //列的值
                    callback:function(){
                        if(self.devClickFunction){
                            return self.devClickFunction(child);
                        }
                        if(self.defaultEventHandler && self.sceneManager){
                            var childNode = self.sceneManager.dataNodeMap[child.getId()];
                            if(childNode){
                                self.defaultEventHandler.lookAt(childNode);
                            }
                        }
                    },
                    mousemove:function(){
                        if(self.mouseoverDevFunction){
                            self.mouseoverDevFunction(child);
                        }
                    }
                };
                devList.push(devInfo);
            });
        }
        if(this.devListSortFunction){
            var self = this;
            devList.sort(function(a,b){
                return self.devListSortFunction(a,b);
            });
        }
        var obj = {
            title: '设备列表',
            properties:devList,
            className:'it-property-equip'
        };
        return obj;
    },


    /**
     * 列表的头信息
     * c_width的总和不能大于12
     * @param node
     * @returns {{c_width: number, text: string}[]}
     */
    createTableHeaderByRuleInfo : function(ruleInfo){
        var heads = [];
        if(ruleInfo && ruleInfo instanceof Array){
            for(var i = 0 ; i< ruleInfo.length ; i++){
                var columnInfo = ruleInfo[i];
                if(columnInfo){
                    var obj = {};
                    if(columnInfo.width){
                        obj.c_width = columnInfo.width;
                    }
                    if(columnInfo.header){
                        obj.text = columnInfo.header;
                    }
                    heads.push(obj);
                }
            }
        }
        return heads;
//        return [{c_width:6,text:'设备编号'},{c_width:3,text:'类型'},{c_width:3,text:'位置'}];
    },

    /**
     * 根据childData创建以行数据
     * @param childData
     * @returns {*}
     */
    createTableRowByRuleInfo : function(ruleInfo,childData){
        if(!childData) return null;

        var columns = [];
        if(ruleInfo && ruleInfo instanceof Array){
            for(var i = 0 ; i < ruleInfo.length ; i++){
                var columnInfo = ruleInfo[i];
                if(columnInfo){
                    var col = {};
                    if(columnInfo.width){
                        col.c_width = columnInfo.width;
                    }
                    if(columnInfo.property){
                        if(typeof(columnInfo.property) == 'function'){
                            col.text = columnInfo.property(childData);
                        }
                    }
                    columns.push(col);
                }
            }
        }
        return columns;
    },

    /**
     * 统计信息
     * @param node
     */
    getStatInfo : function(node){
        if(!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var dataType = this.dataManager.getDataTypeForData(data);
        if(!dataType || !dataType.getCategoryId()) return null;
        var ruleInfo = this.statInfoRule[dataType.getCategoryId()]; //dataType.getId() dataType.getModel()
        var emp_obj = null;
        if(ruleInfo && ruleInfo.value){
            if(typeof(ruleInfo.value) == 'function'){
                 emp_obj = ruleInfo.value(data);
            }else{
                emp_obj = ruleInfo.value;
            }
        }
        if(emp_obj){
            var obj = {
                title: '统计',
                properties: emp_obj,
                isGrop: false,
                className: 'it-property-chart'
            };
            return obj;
        }
    },

    getPreExtInfo : function(node){
        // if(this.getPreExtInfoFunction){ //add到标准的tab前
        //     var preExtInfoResult = this.getPreExtInfoFunction(node);
        //     if (preExtInfoResult != undefined) {
        //         return preExtInfoResult;
        //     }
        // }
        if(!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if(!data) return null;
        var result = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if(dataType && dataType.getCategoryId()) {
            var preExtInfoRule = this.preExtInfoRule[dataType.getCategoryId()];
            if (preExtInfoRule) {
                if (preExtInfoRule instanceof Array) {
                    result = preExtInfoRule;
                }else{
                    result.push(preExtInfoRule);
                }
            }
        }
        if(this.getPreExtInfoFunction){ //add到标准的tab前
            var preExtInfoResult = this.getPreExtInfoFunction(node);
            if (preExtInfoResult) {
                if (preExtInfoResult instanceof Array) {
                    for (var i = 0; i < preExtInfoResult.length; i++) {
                        result.push(preExtInfoResult[i]);
                    }
                }else{
                    result.push(preExtInfoResult);
                }
            }
        }
        return result;
    },

    /**
     * 扩展的
     * @param node
     */
    getOthers: function(node) {
        if (!node) return null;
        var data = node.getClient(it.SceneManager.CLIENT_IT_DATA);
        if (!data) return null;
        var result = [];
        var dataType = this.dataManager.getDataTypeForData(data);
        if (dataType && dataType.getCategoryId()) {
            var otherInfoRule = this.otherInfoRule[dataType.getCategoryId()];
            if (otherInfoRule) {
                if (otherInfoRule instanceof Array) {
                    result = otherInfoRule;
                } else {
                    result.push(otherInfoRule);
                }
            }
        }
        if (this.getExtInfoFunction) { // add到标准的tab后面
            var extInfoResult = this.getExtInfoFunction(node);
            if (extInfoResult) {
                if (extInfoResult instanceof Array) {
                    for (var i = 0; i < extInfoResult.length; i++) {
                        result.push(extInfoResult[i]);
                    }
                } else {
                    result.push(extInfoResult);
                }
            }
        }
        return result;
    }


});

//结合it.Size 用父亲的尺寸来规划孩子的位置。
// xSize 表示的是规划的最小的单位的个数，比如U数，比如把地板分成多少多少格子
var $Size = function (parameters) {
   parameters = parameters || {};
   this.xSize = parameters.x ;
   this.ySize = parameters.y ;
   this.zSize = parameters.z ;

   this.xPadding = parameters.xPadding || [0,0];
   this.yPadding = parameters.yPadding || [0,0];
   this.zPadding = parameters.zPadding || [0,0];

   this.xGap = 0;
   this.yGap = 0;
   this.zGap = 0;
};
mono.extend($Size,Object,{
    __accessor : ['xSize','ySize','zSize','xPadding','yPadding','zPadding'],
     
    parse : function(){ //
       
    }, 
});

it.Size =  $Size;
// 位置管理
// x,y,z 分别表示3个方位的布局： 
// x,y,z 支持数字，其中有一些特殊的数字，表示所在位置，而一些特殊的位置，表示对齐，比如设备放在机柜里面，y 按照数字 U数布局；
// x,z 的和父亲对齐，对齐方式 参考 it.Location.Align;
var $Location = function (parameters) {
  this.parse(parameters);

};
it.Location = $Location;

var $Align = it.Location.Align = {};
$Align.pos_neg = -1;
$Align.center_neg = -2;
$Align.neg_neg = -3;
$Align.center = -4;
$Align.pos_pos = -5;
$Align.center_pos = -6;
$Align.neg_pos = -7;

mono.extend($Location,Object,{

    set : function(key,value){
        var result = value;
        if(typeof value === "string"){// pos_neg 之类的
            result = it.Location.Align[value];
            if(!result){
                result = value;
            }
        }
        this[key] = result;
    },

	setX: function(x){
        this.set('x',x);
	},

	setY : function(y){
       this.set('y',y);
	},

	setZ : function(z){
       this.set('z',z);
	},

  getX : function () {
    return this.x;
  },

  getY : function () {
    return this.y;
  },

  getZ : function () {
    return this.z;
  },

  parse : function(parameters){
    if(!parameters){
      return;
    }
    // if(parameters instanceof it.Location){
    //     this.x = parameters.x;
    //     this.y = parameters.y;
    //     this.z = parameters.z;
    //     return;
    // }
    if(it.defaultLocatonParser){
       var loc = it.defaultLocatonParser.parse(parameters);
       if(loc == null || !(loc instanceof it.Location)){
          throw 'it.defaultLocatonParser.parse() does not return a it.Location';
       }else{
          this.location = loc;
       }
       this.x = loc.x;
       this.y = loc.y;
       this.z = loc.z;
    }else{
       throw 'it.defaultLocatonParser is null'; 
    }
  },

});
$Location.getAlignName  = function(value){
   for(var name in $Align){
       if($Align[name] === value){
          return name;
       }
   }
};
// 解析表达式 生成Location
it.LocationParser = function () {
};

mono.extend(it.LocationParser,Object,{
    parse : function(source){ // parse source(maybe json,maybe text) to it.Location
      return null;
    },
});

it.DefaultLocatonParser = function(){
   it.LocationParser.call(this);
};

mono.extend(it.DefaultLocatonParser,it.LocationParser,{
   parse : function(source){
   	  var l = new it.Location();
      if(source instanceof it.Location){
          l.x = source.x;
          l.y = source.y;
          l.z = source.z;
      }else if(source.x !== undefined || source.y !== undefined || source.z !== undefined){
         l.setX(source.x);
         l.setY(source.y);
         l.setZ(source.z);
      }else if(typeof source ==='string'){
        l = this.parseText(source);
      }
      return l;
   },

   parseText : function(source){
       var source = JSON.parse(source);
       if(!source) return null;
       if(source.x !== undefined || source.y !== undefined || source.z !== undefined){
           var l = new it.Location();
           l.setX(source.x);
           l.setY(source.y);
           l.setZ(source.z);
           return l;
       }
       return null;
   },

   charToNum : function(c){ // a == 1,A === 1
	    if(c && c.toUpperCase && c.length){
	    	c = c.toUpperCase();
	    	return c.chartCodeAt(0) - 96;
	    }
	},
});

it.defaultLocatonParser = new it.DefaultLocatonParser;
var $LocationManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    this._positionFunctionMap = {};
    this._rotationFunctionMap = {};
};

mono.extend($LocationManager,Object,{

     registerPositionFunction : function(categoryId,pCategoryId,func){
        var key = pCategoryId + "&" + categoryId;
        this._positionFunctionMap[key] = func;
     },

     registerRotationFunction : function(categoryId,pCategoryId,func){
        var key = pCategoryId + "&" + categoryId;
        this._rotationFunctionMap[key] = func;
     },

     /**
      *  根据相关信息计算dataNode的位置，这里加了pbb，因为考虑到父类对象可能是复杂模型
      */
     _computePosition : function(data,parentData,node,parentNode,pbb){
         var dm = this.dataManager;
         // var category = dm.getCategoryForData(data);
         // var pCategory = dm.getCategoryForData(parentData);
         // var categoryId = category ? category.getId() : "";
         // var pCategoryId = pCategory ? pCategory.getId() : "";
         // var map = this._positionFunctionMap;
          var location = data.getLocation();
             var dataType = dm.getDataTypeForData(data);
             var parentDataType = dm.getDataTypeForData(parentData);
             var parentCategory = this.dataManager.getCategoryForDataType(parentDataType);
             var size = dataType.getSize();
             var pSize = parentDataType.getChildrenSize() || new it.Size();
             var bb = node.getBoundingBox();
             if (!bb.size() || (!bb.size().x && !bb.size().y && !bb.size().z)) {
                bb = it.Util.getBoundingBox(node);
             }
             var pbb = pbb || parentNode.getBoundingBox();
             var positionExp = dataType.getPositionExp()||{};
             var x = location.getX();
             var y = location.getY();
             var z = location.getZ();
                 var datas = {x:x,y:y,z:z,dataType:dataType,
                     parentDataType:parentDataType,
                     parentCategory : parentCategory,
                     data:data,parentData:parentData,
                     bb:bb,pbb:pbb};
                 if(positionExp.x){
//                 x = eval(positionExp.x);
                     var fun = new Function("x","y","z","data","return " + positionExp.x);
                     x = fun.call(this,x,y,z,datas)||x;
                 }
                 if(positionExp.z){
//                 z = eval(positionExp.z);
                     var fun = new Function("x","y","z","data","return " + positionExp.z);
                     z = fun.call(this,x,y,z,datas)||z;
                 }
                 if(positionExp.y){
//                 y = eval(positionExp.y);
                     var fun = new Function("x","y","z","data","return " + positionExp.y);
                     y = fun.call(this,x,y,z,datas)||y;
                 }

             var px = this._computeOneAxisPosition('x',x,size.getXSize(),pSize.getXSize(),pSize.getXPadding(),bb,pbb) || data.getPosition().x;
             var pz = this._computeOneAxisPosition('z',z,size.getZSize(),pSize.getZSize(),pSize.getZPadding(),bb,pbb) || data.getPosition().z;

             var locationY = location.getY();
             var floor = null;
             if(this._isAlignment(locationY)){
                 floor = this._findFloor(parentNode);
                 pbb = floor.getBoundingBox();
             }
             var py = this._computeOneAxisPosition('y',y,size.getYSize(),pSize.getYSize(),pSize.getYPadding(),bb,pbb) || data.getPosition().y;

            //  支持U位从上至下的顺序 2018.2.27 add by lyz 
            var modelParameters = parentDataType.getModelParameters();
            if( modelParameters&&modelParameters.uOrder == 'upToDown'){
               py = -1*py;
            }
            
             var position = new mono.Vec3(px,py,pz);
             node.p(position);
     },

     /**
      * 注意：如果node是billboard的情况，这时没有boundingBox
     **/
     computePosition : function(data,parentData,node,parentNode){
         var dm = this.dataManager;
         var category = dm.getCategoryForData(data);
         var pCategory = dm.getCategoryForData(parentData);
         var categoryId = category ? category.getId() : "";
         var pCategoryId = pCategory ? pCategory.getId() : "";
         var map = this._positionFunctionMap;
         var self = this;
         var func = map[pCategoryId + "&" + categoryId];
         if(func){
            var flag =  func(data,parentData,node,parentNode);
            if(flag !== false){
               return;
            }
         }       
         if(!parentData){
            node.p(data.getPosition());
            return;
         }
         var location = data.getLocation();
         if(!location){
            node.p(data.getPosition());
            return;
         }
         if(node instanceof mono.Billboard){
            node.p(data.getPosition());
            return;
         }
         if (!parentNode) {
            node.p(data.getPosition());
            return;
         }
         if (parentNode) {
            //如果node存在复杂对象的话，那计算该对象的孩子时，则要以复杂对象的信息来计算,注意complexParentNode可能是unload
             var complexParentNode = parentNode.getClient('complexNode'); 
             if (complexParentNode) {
                if (complexParentNode == 'unload') {
                    this.sceneManager.loadComplexNode(parentData,function(comNode){
                        var pbb = comNode.getBoundingBox();
                        if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                            pbb = it.Util.getBoundingBox(comNode);
                        }
                        self._computePosition(data,parentData,node,parentNode,pbb);
                    });
                }else {
                    pbb = complexParentNode.getBoundingBox();
                    if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                       pbb = it.Util.getBoundingBox(complexParentNode);
                    }
                    self._computePosition(data,parentData,node,parentNode,pbb);
                }
             }else{
                var  pbb = parentNode.getBoundingBox();
                if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                   pbb = it.Util.getBoundingBox(parentNode);
                }
                self._computePosition(data,parentData,node,parentNode,pbb);
             }
         }
         /*
         if(parentNode){ // 2D 到 3D时 parentNode为null
             var dataType = dm.getDataTypeForData(data);
             var parentDataType = dm.getDataTypeForData(parentData);
             var parentCategory = this.dataManager.getCategoryForDataType(parentDataType);
             var size = dataType.getSize();
             var pSize = parentDataType.getChildrenSize() || new it.Size();
             var bb = node.getBoundingBox();
             if (!bb.size() || (!bb.size().x && !bb.size().y && !bb.size().z)) {
                bb = it.Util.getBoundingBox(node);
             }
             var pbb = parentNode.getBoundingBox();
             if (!pbb.size() || (!pbb.size().x && !pbb.size().y && !pbb.size().z)) {
                pbb = it.Util.getBoundingBox(parentNode);
             }
             var positionExp = dataType.getPositionExp()||{};
             var x = location.getX();
             var y = location.getY();
             var z = location.getZ();
                 var datas = {x:x,y:y,z:z,dataType:dataType,
                     parentDataType:parentDataType,
                     parentCategory : parentCategory,
                     data:data,parentData:parentData,
                     bb:bb,pbb:pbb};
                 if(positionExp.x){
//                 x = eval(positionExp.x);
                     var fun = new Function("x","y","z","data","return " + positionExp.x);
                     x = fun.call(this,x,y,z,datas)||x;
                 }
                 if(positionExp.z){
//                 z = eval(positionExp.z);
                     var fun = new Function("x","y","z","data","return " + positionExp.z);
                     z = fun.call(this,x,y,z,datas)||z;
                 }
                 if(positionExp.y){
//                 y = eval(positionExp.y);
                     var fun = new Function("x","y","z","data","return " + positionExp.y);
                     y = fun.call(this,x,y,z,datas)||y;
                 }

             var px = this._computeOneAxisPosition('x',x,size.getXSize(),pSize.getXSize(),pSize.getXPadding(),bb,pbb) || data.getPosition().x;
             var pz = this._computeOneAxisPosition('z',z,size.getZSize(),pSize.getZSize(),pSize.getZPadding(),bb,pbb) || data.getPosition().z;

             var locationY = location.getY();
             var floor = null;
             if(this._isAlignment(locationY)){
                 floor = this._findFloor(parentNode);
                 pbb = floor.getBoundingBox();
             }
             var py = this._computeOneAxisPosition('y',y,size.getYSize(),pSize.getYSize(),pSize.getYPadding(),bb,pbb) || data.getPosition().y;
             var position = new mono.Vec3(px,py,pz);
             node.p(position);
        }
        */
     },

     _findFloor : function (node) { //TODO 对于房间，需要计算地板
        return node;
     },

     _computeOneAxisPosition : function(axis,locationAxis,sizeAxis,pSizeAxis,paddingAxis,bb,pbb){
         locationAxis = parseFloat(locationAxis);
         if(Number.isNaN(locationAxis)){
            return null;
         }
         if(pSizeAxis && !this._isAlignment(locationAxis)){
            paddingAxis = paddingAxis || [0,0];
            var totolLength = pbb.max[axis] - pbb.min[axis] - parseFloat(paddingAxis[0]) - parseFloat(paddingAxis[1]);
            var unit = totolLength / pSizeAxis;
            return pbb.min[axis] - bb.min[axis] + unit * (locationAxis - 1) + parseFloat(paddingAxis[0]);// TODO 
         }else {
            if(this._isAlignment(locationAxis)){
               return this._getAlignPosition(bb,pbb,locationAxis,paddingAxis,axis);
            }
         }
     },

     _isAlignment : function (locationAxis) {
         return !!it.Location.getAlignName(locationAxis);
     },

     _getAlignPosition : function(bb,pbb,align,paddingAxis,axis){
        if(align === $Align.pos_neg){
          return pbb.min[axis] - bb.max[axis] + paddingAxis[0];
        }else if(align === $Align.center_neg){
          return pbb.min[axis];
        }else if(align === $Align.neg_neg){
          return pbb.min[axis] - bb.min[axis] + paddingAxis[0];
        }else if(align === $Align.center){
          return pbb.center()[axis];
        }else if(align === $Align.pos_pos){
          return pbb.max[axis] - bb.max[axis] - paddingAxis[1];
        }else if(align === $Align.center_pos){
          return pbb.max[axis];
        }else if(align === $Align.neg_pos){
          return pbb.max[axis] - bb.min[axis] - paddingAxis[1];
        }
     },

    isNull : function(value){
        if(value==undefined){
            return true;
        }
        if(typeof(value) == 'string' && value.trim() == ""){
            return true;
        }
        return false;
    },

    /**
     * 将角度换算成弧度
     * 注意：sdk中认为外面输入的都是角度制
     * @param rotation
     */
    translateRotation : function(rotation){
        if(!rotation){
            return rotation;
        }
        var rot = new mono.Vec3();
        if(rotation.x){
            rot.setX(Math.PI*rotation.x/180);
        }else{
            rot.setX(rotation.x);
        }
        if(rotation.y){
            rot.setY(Math.PI*rotation.y/180);
        }else{
            rot.setY(rotation.y);
        }
        if(rotation.z){
            rot.setZ(Math.PI*rotation.z/180);
        }else{
            rot.setZ(rotation.z);
        }
        return rot;
    },

     computeRotation : function(data,parentData,node,parentNode){
         var dm = this.dataManager;
         var location = data.getLocation();
         var dataType = dm.getDataTypeForData(data);
         var rotationExp = dataType.getRotationExp();
         var rotation = this.translateRotation(data.getRotation());
         node.setRotation(new mono.Vec3());  //先清空 add By Kevin 2017-07-11
         if(rotation && (!this.isNull(rotation.x)
             || !this.isNull(rotation.y)
             || !this.isNull(rotation.z))){
             node.setRotation(rotation);
             return;
         }
         if(!location || !rotationExp){
             return ;
         }
         var x = location.getX(),y = location.getY(),z = location.getZ();
         var scriptData = {x : x ,y : y ,z : z,data:data,dataType:dataType,parentData:parentData,location:location};
         var position = data.getPosition();
         var px = position.x,py = position.y,pz = position.z;
         var rx ,ry ,rz ;
         if(rotationExp.x){
//           rx = eval('witch'rotationExp.x);
             var func = new Function("x","y","z","data","return " + rotationExp.x);
             rx = func.call(this,x,y,z,scriptData)||0;
         }

         if(rotationExp.y){
//            ry = eval(rotationExp.y);
             var func = new Function("x","y","z","data","return " + rotationExp.y);
             ry = func.call(this,x,y,z,scriptData)||0;
         }
         if(rotationExp.z){
//            rz = eval(rotationExp.z);
             var func = new Function("x","y","z","data","return " + rotationExp.z);
             rz = func.call(this,x,y,z,scriptData)||0;
         }
         // node.setRotation(rx,ry,rz);
         if (rx != undefined && rx != null) {
            node.setRotationX(rx);
         }
         if (ry != undefined && ry != null) {
            node.setRotationY(ry);
         }
         if (rz != undefined && rz != null) {
            node.setRotationZ(rz);
         }
     },
});

it.LocationManager = $LocationManager;
it.Space1 = function (spaceArray,axis) {
   this._spaceArray = spaceArray || [];
   this._axis = axis;
   this.init();
   this.compute();
};

mono.extend(it.Space1,Object,{
	setSpaceArray : function(spaceArray){
		this._spaceArray = spaceArray;
		this.init();
		this.compute();
	},
    getSpaceArray : function(){
       return this._spaceArray;
    },

    getTotal : function(){
    	return this._total;
    },

    getPercent : function(){
    	return this._percent;
    },

    getOccupation : function(){
    	return this._occupation;
    },

    getOccupationList : function(){
    	return this._occupationList;
    },

    getEmptyList : function(){
    	return this._emptyList;
    },

    getAxis : function(){
    	return this._axis;
    },

    isAvailableAt : function(location,size){
       if(location < 1 && location > this._total){
         return false;
       }
       size = size || 1;
       var start = location,end = location + size - 1;
       if(end  > this._total){
         return false;
       }
       
       var i = 0,len = this._occupationList.length,occupation;
       for(;i < len;i ++){
           occupation = this._occupationList[i];
           if( (start >= occupation.start && start <= occupation.end) || (end >= occupation.start && end <= occupation.end) ){
             return false;
           }
       }
       return true;
    },

    isValid : function(){
    	return this._total > 0;
    },

    _addStatistic : function(unit,statistic,end){
       if(unit === 1 || unit === 0){
            statistic.end = end;
            if(statistic.occupation){
    	 	this._occupationList.push(statistic);
    	 	}else{
    	 		this._emptyList.push(statistic);
    	 	}
    	 	statistic.total = statistic.end - statistic.start + 1;
    	 	delete statistic.occupation;
        }
    },

    getCountForSize : function(size){
        var count = 0;
        for(var i = 0;i < this._emptyList.length;i ++){
        	var statistic = this._emptyList[i];
        	count += parseInt(statistic.total / size);
        }
        return count;
    },

    init : function(){
       this._total = 0;
	   this._percent = 0;
	   this._occupation = 0;
	   this._occupationList = [];
	   this._emptyList = [];
    },

    compute : function(){
    	var spaceArray = this._spaceArray,len = spaceArray.length,lastUnit = null,statistic;
    	this._total = len;
        for(var i = 0;i < len;i ++){
            var unit = spaceArray[i];
            if(unit == 1){
               this._occupation ++;
            }
            if(i == 0 || lastUnit != unit){
            	 this._addStatistic(lastUnit,statistic,i);
            	 statistic = {start : i + 1,occupation : unit};
            }
            lastUnit = unit;
            if(i == len - 1){
         	   this._addStatistic(lastUnit,statistic,i + 1);  
            }
        }
        if(this._total > 0){
        	this._percent = this._occupation / this._total;
        }
    },
})
it.Space2 = function (spaceArray,axis,mainAxis) {
	this._spaceArray = spaceArray || [[]]; // spaceArray 是一个it.Space1的数组
	this._axis = axis;
	this._mainAxis = mainAxis;

    this.init();
    this.compute();
};

mono.extend(it.Space2,Object,{
    setSpaceArray : function(spaceArray){
		this._spaceArray = spaceArray;
		this.init();
		this.compute();
	},
    getSpaceArray : function(){
       return this._spaceArray;
    },

    getAxis : function(){
    	return this._axis;
    },

    getMainAxis : function(){
    	return this._mainAxis;
    },

    init : function(){
       this._total = 0;
	   this._percent = 0;
	   this._occupation = 0;
	   // this._occupationList = []; 
	   // this._emptyList = [];
    },

    compute : function(){
    	var i = 0,len = this._spaceArray.length,space1;
    	for(;i < len;i ++){
           space1 = this._spaceArray[i];
           this._total += space1.getTotal();
           this._occupation += space1.getOccupation();
    	}

    	if(this._total > 0){
    		this._percent = this._occupation / this._total;
    	}
    },

    getCountForSize : function(size){
        var i = 0,len = this._spaceArray.length,space1,count = 0;
        for(;i < len;i ++){
            space1 = this._spaceArray[i];
        	count += space1.getCountForSize(size);
        }
        return count;
    },
});

// 空间计算
var $SpaceManager = function (dataManager, sceneManager) {
    this.dataManager = dataManager;
    this.sceneManager = sceneManager;
    this.nodeMap = {};
    this.spaceNodeColorFunction = null;
    this.spaceNodeFrameColorFunction = null;
    this.spaceVisibleFilter = new it.SpaceVisibleFilter(sceneManager, this); //用来管理想alarmBillboard这样的对象的隐藏显示
    this.spaceMaterialFilter = new it.SpaceMaterialFilter(sceneManager, this);
    this.spaceAdapter = new $SpaceAdapter(sceneManager, this);
};

mono.extend($SpaceManager, Object, {
    _initArray: function (length, initValue) {
        initValue = initValue || 0;
        var array = [];
        for (var i = 0; i < length; i++) {
            array.push(initValue);
        }
        return array;
    },
    _initArray2: function (length, length2, initValue) {
        initValue = initValue || 0;
        var array = [];
        for (var i = 0; i < length; i++) {
            var subArray = [];
            for (var j = 0; j < length2; j++) {
                subArray.push(0);
            }
            array.push(subArray);
        }
        return array;
    },

    initSpaceArray: function (xSize, ySize, zSize) {

    },

    computeSpace: function (data, mainAxis) {
        var dm = this.dataManager;
        var dataType = dm.getDataTypeForData(data);
        var size = dataType.getChildrenSize();
        var children = data.getChildren(), child;//dm.getChildren(data),child;

        var xSize = size.getXSize();
        var ySize = size.getYSize();
        var zSize = size.getZSize();

        var dimension = 0, sizeArray = [], axis = "", notMainAxis = "";
        if (xSize) {
            dimension++;
            sizeArray.push({ axis: "x", size: xSize });
            axis += "x";
            if (axis !== mainAxis) {
                notMainAxis = "x";
            }
        }
        if (ySize) {
            dimension++;
            sizeArray.push({ axis: "y", size: ySize });
            axis += "y";
            if (axis !== mainAxis) {
                notMainAxis = "y";
            }
        }
        if (zSize) {
            dimension++;
            axis += "z";
            sizeArray.push({ axis: "z", size: zSize });
            if (axis !== mainAxis) {
                notMainAxis = "z";
            }
        }
        if (dimension > 2) {
            console.error("Only support 1 or 2 dimension");
            return;
        } else if (dimension == 2 && !mainAxis) {
            console.error("Main Axis is needed for 2 dimension");
            return;
        }
        var spaceArray = null;
        if (dimension == 1) {
            spaceArray = this._initArray(sizeArray[0].size);
            for (var i = 0; i < children.size(); i++) {
                var child = children.get(i);
                var childType = dm.getDataTypeForData(child);
                var childSize = childType.getSize();
                var locaton = child.getLocation();
                this.computeOneDimesion(spaceArray, childSize['get' + axis.toUpperCase() + 'Size'](), locaton['get' + axis.toUpperCase()]());
            }
            var space = new it.Space1(spaceArray, axis);
            return space
        }
        if (dimension == 2) {
            var notMainAxisSize = size['get' + notMainAxis.toUpperCase() + 'Size']();
            var mainAxisSize = size['get' + mainAxis.toUpperCase() + 'Size']();
            var space1Array = [];
            for (var k = 0; k < notMainAxisSize; k++) {
                var spaceArray = this._initArray(mainAxisSize);
                for (var i = 0; i < children.size(); i++) {
                    var child = children.get(i);
                    var childType = dm.getDataTypeForData(child);
                    var childSize = childType.getSize();
                    var locaton = child.getLocation();
                    if (locaton['get' + notMainAxis.toUpperCase()]() == k + 1) {
                        this.computeOneDimesion(spaceArray, childSize['get' + mainAxis.toUpperCase() + 'Size'](), locaton['get' + mainAxis.toUpperCase()]());
                    }
                }
                var space1 = new it.Space1(spaceArray, mainAxis);
                space1Array.push(space1);
            }
            var space2 = new it.Space2(space1Array, axis, mainAxis);
            return space2;
        }
        return null;
    },

    computeOneDimesion: function (spaceArrayAxis, childSizeAxis, locatonAxis) {
        if (childSizeAxis == null || childSizeAxis == undefined) {
            childSizeAxis = 1;
        }
        if (!spaceArrayAxis || !childSizeAxis || !(locatonAxis > 0)) {
            return;
        }
        for (var i = 0; i < childSizeAxis; i++) {
            spaceArrayAxis[locatonAxis - 1 + i] = 1;
        }
        return spaceArrayAxis;
    },

    getSpaceNodeColor: function (percent, data, space) {
        if (this.spaceNodeColorFunction) {
            var color = this.spaceNodeColorFunction(percent, data, space);

            return color;
        }
        var color = null;
        if (percent <= 0.25) { // TODO

        }
        color = 'orange';
        return color;
    },

    getSpaceNodeFrameColor: function (percent, data, space) {
        if (this.spaceNodeFrameColorFunction) {
            var color = this.spaceNodeFrameColorFunction(percent, data, space);
            return color;
        } else {
            return this.getSpaceNodeColor(percent, data, space);
        }
    },

    showSpaceMode: function () {
        this.sceneManager.viewManager3d.addVisibleFilter(this.spaceVisibleFilter);
        this.sceneManager.viewManager3d.addMaterialFilter(this.spaceMaterialFilter);
        this.sceneManager.adapterManager.register(this.spaceAdapter);
    },

    hideSpaceMode: function () {
        this.sceneManager.viewManager3d.removeVisibleFilter(this.spaceVisibleFilter);
        this.sceneManager.viewManager3d.removeMaterialFilter(this.spaceMaterialFilter);
        this.sceneManager.adapterManager.deregister(this.spaceAdapter);

    },

    getModelParent: function (node) {
        if (node == null) {
            return null;
        }
        var parent = node.getClient('modelParent');
        if (parent == null) {
            return this.getModelParent(node.getParent());
        }
        return parent;
    },

    remove1DSpaceNodeForNodes: function (nodes) {
        if (nodes instanceof mono.List) {
            nodes = nodes.toArray();
        }
        var box = this.sceneManager.network3d.getDataBox();
        var i = 0, j = 0, node, child;
        for (; i < nodes.length; i++) {
            node = nodes[i];
            var spaceNode = null;
            var children = node.getChildren().toArray();
            for (j = 0; j < children.length; j++) {
                child = children[j];
                if (this.isSpaceNode(child) || this.isSpaceChildrenNode(child)) {
                    box.removeByDescendant(child);
                    child.setParent(null);
                    if (this.isSpaceNode(child)) {
                        spaceNode = child;
                    }
                }
            }
            if (spaceNode) {
                var removedNode = spaceNode.getClient("modelRemovedNode");
                if (removedNode) {
                    //有可能当前空间可视化的模式下正focus某个机柜，此时应该判断node的当前是的到底是真是假，
                    // 直接setParent可能会导致真假都在
                    // removedNode.setParent(node); 
                    // if (box.getDataById(node.getId())) {
                    //     box.addByDescendant(removedNode);
                    // }
                    var complexNode = node.getClient('complexNode');
                    var simpleNode = node.getClient('simpleNode');
                    if (complexNode != 'unload'
                        && complexNode && node.getChildren().contains(complexNode)) { //在空间可视化模式下聚焦的机柜
                        // 如果机柜没满时，那就要去掉中间的色块
                        var children = node.getChildren();
                        for (var k = 0; k < children.size(); k++) {
                            var child = children.get(k);
                            if (this.isSpaceChildrenNode(child)) {
                                child.setParent(null);
                                box.removeByDescendant(child);
                            }
                        }
                    } else { //当前显示的假机柜，此时就可以直接将假的移走
                        removedNode.setParent(node);
                        if (box.getDataById(node.getId())) {
                            box.addByDescendant(removedNode);
                        }
                    }
                }
            }
        }
    },

    create1DSpaceNodeForNodes: function (nodes, mode) {
        // this.nodeMap = {};
        mode = mode || 1;
        if (nodes instanceof mono.List) {
            nodes = nodes.toArray();
        }
        var box = this.sceneManager.network3d.getDataBox();
        box.startBatch();
        var focusNode = this.sceneManager.viewManager3d._focusNode;
        var i = 0, j = 0, node, data, spaceNode, spaceChildrenNodes, spaceChildNode;
        for (; i < nodes.length; i++) {
            node = nodes[i];
            /**
             * 空间资源利用率场景下，查看一个具体机柜时候，点击搜索面板清除按钮的时候，不再显示色块的样式
             * Author: alex
             */
            if (node === focusNode) continue;
            // 创建SpaceNode时，有可能之前创建过，为了避免重复，这里的先清除掉
            var children = node.getChildren().toArray();
            for (j = 0; j < children.length; j++) {
                var child = children[j];
                if (this.isSpaceNode(child) || this.isSpaceChildrenNode(child)) {
                    box.removeByDescendant(child);
                    child.setParent(null);
                    if (this.isSpaceNode(child)
                        && child.getClient("modelRemovedNode")) {
                        var removedNode = child.getClient("modelRemovedNode");
                        removedNode.setParent(node);
                        box.addByDescendant(removedNode);
                    }
                }
            }
            data = this.sceneManager.getNodeData(node);
            if (data) {
                spaceNode = mode == 1 ? this.create1DSpaceNode(data) : this.create1DSpaceNode2(data);
                if (!spaceNode) {
                    continue;
                }
                //将它从box中移除掉，而不是隐藏，但是父子关系依然保留着 --add By Kevin 2016-12-01
                var complexNode = node.getClient('complexNode');
                var simpleNode = node.getClient('simpleNode');
                if (simpleNode && node.getChildren().contains(simpleNode)) {
                    simpleNode.setParent(null);
                    box.removeByDescendant(simpleNode);
                    spaceNode.setClient("modelRemovedNode", simpleNode);
                } else if (complexNode != 'unload' && complexNode && node.getChildren().contains(complexNode)) {
                    complexNode.setParent(null);
                    box.removeByDescendant(complexNode);
                    spaceNode.setClient("modelRemovedNode", complexNode);
                }
                //add 2017-11-18 如果设备在中途被加进来了，也应该移除掉
                //2018-1-17 下面代码移除了一半的node导致移除的node父亲为null 不知道瞎下面代码的意思 --徐
                //   var cNodes = node.getChildren();
                //   if (cNodes && cNodes.size()){
                //     for(var k = 0 ; k < cNodes.size() ; k++){
                //         var childNode = cNodes.get(k);
                //         var childData = this.sceneManager.getNodeData(childNode);
                //         if (childData && childData.getParentId() == data.getId()) {
                //            childNode.setParent(null);
                //            box.removeByDescendant(childNode);
                //         }
                //     }
                //   }

                // this.nodeMap[data.getId()] = spaceNode;
                spaceNode.setClient("modelParent", node);
                spaceNode.setParent(node);
                box.addByDescendant(spaceNode);
            }
        }
        box.endBatch();
    },

    isSpaceNode: function (node) {
        return node.getClient("spaceNode");
    },

    hasSpaceNode: function (node) {
        if (!node) {
            return false;
        }
        var children = node.getChildren();
        if (children && children.size() > 0) {
            for (var i = 0; i < children._as.length; i++) {
                var child = children._as[i];
                if (this.isSpaceNode(child)) {
                    return true;
                }
            }
        }
        return false;
    },

    hasSpaceChildrenNode: function (node) {
        if (!node) {
            return false;
        }
        var children = node.getChildren();
        if (children && children.size() > 0) {
            for (var i = 0; i < children._as.length; i++) {
                var child = children._as[i];
                if (this.isSpaceChildrenNode(child)) {
                    return true;
                }
            }
        }
        return false;
    },

    isSpaceChildrenNode: function (node) {
        return node.getClient('spaceChildrenNode');
    },

    /**
     * 一维的布局，可以支持计算出一个SpaceNode来呈现
     */
    create1DSpaceNode: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!(space instanceof it.Space1)) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var dataType = dm.getDataTypeForData(data);
        var childSize = dataType.getChildrenSize();
        var node = sm.getNodeForDataOrId(data);
        if (!node) {
            return;
        }

        var percent = space.getPercent();
        if (percent == 0) {
            percent = 0.01;
        }
        var color = this.getSpaceNodeColor(percent, data, space);
        var frameColor = this.getSpaceNodeFrameColor(percent, data, space) || color;
        var boundingBox = node.getBoundingBox();
        var width = boundingBox.max.x - boundingBox.min.x;
        var height = boundingBox.max.y - boundingBox.min.y;
        var depth = boundingBox.max.z - boundingBox.min.z;
        var offset = 1;
        width = width - 4;
        height = height - 4;
        var cube = new mono.Cube(width + offset, height + offset, depth + offset);
        // var cube = this.createColorCube(width + offset,height + offset,depth + offset);
        cube.setClient('spaceNode', true);
        cube.s({
            'm.wireframe': true,
            'm.transparent': true,
            // 'm.opacity': 0.1,
            'm.wireframeLineopacity': 0.1,
            //   'm.wireframeLinewidth': 2,
            //   'm.wireframeLinecolor': frameColor,
            //   'm.wireframeLineopacity': 0.5,
        });
        var axis = space.getAxis();
        if (axis === 'x') width = width * percent;
        if (axis === 'y') height = height * percent;
        if (axis === 'z') depth = depth * percent;
        // if(axis === 'x') width = width * percent*cube.getScaleX();
        // if(axis === 'y') height = height * percent*cube.getScaleY();
        // if(axis === 'z') depth = depth * percent * cube.getScaleZ();
        // var cube2 = new mono.Cube(width,height,depth);
        var cube2 = this.createColorCube(width, height, depth);
        cube2.setClient('spaceNode', true);
        cube2.setY(10);
        cube2.setParent(cube);
        var cbb = cube2.getBoundingBox();
        if (axis === 'x') {
            // cube2.setX(boundingBox.min.x - cbb.min.x);
            cube2.setX(boundingBox.min.x - cbb.min.x * cube2.getScaleX());
        } else if (axis === 'y') {
            // cube2.setY(boundingBox.min.y - cbb.min.y);
            cube2.setY(boundingBox.min.y - cbb.min.y * cube2.getScaleY() + 1); //老是钻到floor里面去了，所以+1
        } else {
            // cube2.setZ(boundingBox.min.z - cbb.min.z);
            cube2.setZ(boundingBox.min.z - cbb.min.z * cube2.getScaleZ());
        }
        var lightmap = 'data:image/jpeg;base64,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';
        //   var mColor = new mono.Color(color);
        //   mColor.lerp(mColor,0.5);
        var randomColor = -(Math.random() * 10 + 5);
        color = this.shadeColor(color, randomColor);
        cube2.s({
            'm.type': 'phong',
            'm.color': color,
            'm.ambient': color,
            'm.specularStrength': 20,
            'left.m.lightmap.image': lightmap,
            'right.m.lightmap.image': lightmap,
            'back.m.lightmap.image': lightmap,
            'front.m.lightmap.image': lightmap,
        });
        return cube;
    },
    shadeColor: function (color, percent) {
        var R = parseInt(color.substring(1, 3), 16);
        var G = parseInt(color.substring(3, 5), 16);
        var B = parseInt(color.substring(5, 7), 16);

        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);

        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;

        var RR = ((R.toString(16).length == 1) ? "0" + R.toString(16) : R.toString(16));
        var GG = ((G.toString(16).length == 1) ? "0" + G.toString(16) : G.toString(16));
        var BB = ((B.toString(16).length == 1) ? "0" + B.toString(16) : B.toString(16));

        return "#" + RR + GG + BB;
    },

    /**
     * 创建彩色色块
     * 为了提高效率，我们只用创建一个原型，其他的都用原型的克隆
     */
    createColorCube: function (width, height, depth) {
        if (!this.colorCube) {
            this.colorCube = new mono.Cube(1, 1, 1);
        }
        var cloneCube = this.colorCube.clonePrefab();
        cloneCube.setScale(width, height, depth);
        return cloneCube;
    },

    removeSpaceNode: function (dataOrNodeOrId) {
        var sm = this.sceneManager;
        sm.removeNodeChildren(dataOrNodeOrId, function (child) {
            return child.getClient('spaceNode');
        });
    },

    create1DSpaceNode2: function (data, parameters) {
        var node = this.create1DChildrenSpaceNodes2(data, parameters);
        return node;
    },

    removeSpaceChildrenNode: function (dataOrNodeOrId) {
        var sm = this.sceneManager;
        sm.removeNodeChildren(dataOrNodeOrId, function (child) {
            return child.getClient('spaceChildrenNode');
        });
    },

    /**
     * 创建SpaceNode 用实体表示
     */
    create1DChildrenSpaceNodes2: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!space instanceof it.Space1) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var node = sm.getNodeForDataOrId(data);
        var dataType = dm.getDataTypeForData(data);
        var childSize = dataType.getChildrenSize();
        if (!node) {
            return;
        }
        var axis = space.getAxis();
        if (!axis) {
            return;
        }
        var boundingBox = node.getBoundingBox();
        var size = boundingBox.size();
        var emptyList = space.getEmptyList();
        var occupationList = space.getOccupationList();
        var wrapNode = new mono.Cube(size.x - 2, size.y, size.z - 2);
        wrapNode.setClient('spaceNode', true);
        wrapNode.setParent(node);
        var nodes = [], total, start, end, object;
        for (var i = 0; i < emptyList.length; i++) {
            object = emptyList[i];
            // total = object.total,start = object.start,end = object.end;
            var spaceNode = this.create1DChildrenSpaceNode2(boundingBox, childSize, object, axis, true);
            spaceNode.setParent(wrapNode);
            nodes.push(spaceNode);
        }
        for (var i = 0; i < occupationList.length; i++) {
            object = occupationList[i];
            var spaceNode = this.create1DChildrenSpaceNode2(boundingBox, childSize, object, axis, false);
            spaceNode.setParent(wrapNode);
            nodes.push(spaceNode);
        }
        wrapNode.s({
            'm.transparent': true,
            'm.opacity': 0.1,
        });
        return wrapNode;
    },

    create1DChildrenSpaceNode2: function (boundingBox, childSize, object, axis, empty) {
        var total = object.total, start = object.start, end = object.end;
        var size = boundingBox.size();
        var width = size.x, height = size.y, depth = size.z;
        var xPadding = childSize.getXPadding() || [0, 0],
            yPadding = childSize.getYPadding() || [0, 0],
            zPadding = childSize.getZPadding() || [0, 0];
        var percent = 0, offset = 1;
        if (axis === 'x') {
            width = total * width / childSize.getXSize();
            width -= offset;
            percent = total / childSize.getXSize();
        } else if (axis === 'y') {
            height = total * height / childSize.getYSize();
            height -= offset;
            percent = total / childSize.getYSize();
        } else if (axis === 'z') {
            depth = total * depth / childSize.getZSize();
            depth -= offset;
            percent = total / childSize.getZSize();
        }
        var cube = new mono.Cube(width - 2, height - 2, depth - 2);
        var cbb = cube.getBoundingBox();
        var x = 0, y = 0, z = 0;
        if (axis === 'x') {
            x = boundingBox.min.x - cbb.min.x + size.x / childSize.getXSize() * (start - 1) + offset / 2;
        } else if (axis === 'y') {
            y = boundingBox.min.y - cbb.min.y + size.y / childSize.getYSize() * (start - 1) + offset / 2;
        } else if (axis === 'z') {
            z = boundingBox.min.z - cbb.min.z + size.z / childSize.getZSize() + offset / 2;
        }
        cube.p(x, y, z);
        //TODO 设置颜色，透明度 根据percent empty（空还是占用）
        var color = emtpy ? this.getSpaceNodeColor(percent) : '#A4A4A4';
        cube.s({
            'm.type': 'phong',
            'm.specularStrength': 50,
            'm.color': color,
            'm.ambient': color
        });
        if (empty) {
            cube.s({
                'm.transparent': true,
                'm.opacity': 0.6,
            });
        }
        cube.setClient('spaceNode', true);
        return cube;
    },

    create1DChildrenSpaceNodes: function (data, parameters) {
        var space = this.computeSpace(data);
        if (!(space instanceof it.Space1)) {
            return;
        }
        var dm = this.dataManager;
        var sm = this.sceneManager;
        var dataType = dm.getDataTypeForData(data);
        var uOrder = dataType._modelParameters.uOrder;
        var childSize = dataType.getChildrenSize();
        var node = sm.getNodeForDataOrId(data);
        if (!node) {
            return;
        }
        var axis = space.getAxis();
        if (!axis) {
            return;
        }
        var boundingBox = node.getBoundingBox();
        var complexNode = node.getClient('complexNode');
        if (complexNode && complexNode != 'unload') {
            boundingBox = complexNode.getBoundingBox();
            if (!boundingBox.size() || (!boundingBox.size().x && !boundingBox.size().y && !boundingBox.size().z)) {
                boundingBox = it.Util.getBoundingBox(complexNode);
            }
        }
        var bSize = boundingBox.size();
        var width = bSize.x,height = bSize.y,depth = bSize.z;
        var xPadding = childSize.getXPadding() || [0,0],
            yPadding = childSize.getYPadding() || [0,0],
            zPadding = childSize.getZPadding() || [0,0];
        width -= (xPadding[0] + xPadding[1]);
        height -= (yPadding[0] + yPadding[1]);
        depth -= (zPadding[0] + zPadding[1]);
       
        var emptyList = space.getEmptyList();
        var nodes = [],i = 0,object,percent = space.getPercent();
        for(;i < emptyList.length;i ++){
            object = emptyList[i];
            var color = this.getSpaceNodeColor(percent,data);
            var bgColor = this.shadeColor(color, -30);
            var params = {
                object: object,
                width: width,
                height: height,
                depth:  depth,
                childSize: childSize,
                bgColor: bgColor,
                borderColor: color,
                lineColor: color,  
                lineWidth: 4, 
                textSize: '60px', 
                uOrder: uOrder,
                customPro: {
                    spaceChildrenNode: true,
                }
            }
            //nodes.push(this.createEmptyNode(object,width,height,depth,axis,childSize,boundingBox,data,percent));
            nodes.push(it.util.createOccupyPop(params, node));
        }
        return nodes;
    },

    // createEmptyNode : function(object,width,height,depth,axis,childSize,boundingBox,data,percent){
    //     var total = object.total,start = object.start,end = object.end;
    //     var xPadding = childSize.getXPadding() || [0,0],
    //         yPadding = childSize.getYPadding() || [0,0],
    //         zPadding = childSize.getZPadding() || [0,0];
    //     width -= (xPadding[0] + xPadding[1]);
    //     height -= (yPadding[0] + yPadding[1]);
    //     depth -= (zPadding[0] + zPadding[1]);
    //     var offset = 1;
    //     var text = "";
    //     if(axis === 'x'){
    //        width = total * width / childSize.getXSize();
    //        text = total + '('+start+'-' + (start+total-1) + ')';
    //     }else if(axis === 'y'){
    //        height = total * height / childSize.getYSize();
    //        text = total + 'U('+start+'-' + (start+total-1) + ')';//y的单位为U
    //     }else if(axis === 'z'){
    //       depth = total * depth / childSize.getZSize();
    //       text = total + '('+start+'-' + (start+total-1) + ')';
    //     }
    //     var cube = new mono.Cube(width - offset,height - offset,depth - offset);
    //     var cbb = cube.getBoundingBox();
    //     var x = 0,y = 0,z = 0
    //     if(axis === 'x'){
    //        x = boundingBox.min.x - cbb.min.x + xPadding[0] + width / total * (start - 1) + offset/2;
    //     }else if(axis === 'y'){
    //        y = boundingBox.min.y - cbb.min.y + yPadding[0] + height / total * (start - 1) + offset/2;
    //     }else if(axis === 'z'){
    //        z = boundingBox.min.z - cbb.min.z + zPadding[0] + depth / total * (start - 1) + offset/2;
    //     }
    //     cube.p(x,y,z);
    //     var color = this.getSpaceNodeColor(percent,data);
    //     cube.setClient('spaceChildrenNode',true);
  
        
    //     var ratio = cube.width / cube.height;
    //     // if(ratio && ratio > 6){ //当height太小可能显示会被遮挡
    //     //     ratio = 6;
    //     // }
    //     //   针对1U设备，即height太小的时候，使用上述方法，会使得字变得很窄，变形了，且某些情况下，字不符合2的幂规格，因此进行修改
    //     //   此处为修改1  2017.12.15 add by lyz 
    //     var image = this.createTextImage(text,{
    //           color : '#000000',//fontColor,
    //           font : '180px "Microsoft YaHei"',//20150420 设置组织节点字体 去掉bold 180px "Microsoft YaHei
    //           ratio : ratio,
    //           background : color,
    //           powerOfTwo : true,
    //     });
    //     var repeat = new mono.Vec3(image.drawRect.width/image.width,image.drawRect.height/image.height);
  
    //      // s_cube.setStyle('front.m.type','basic');
    //      //          s_cube.setStyle('front.m.texture.image',image);
    //      //          s_cube.setStyle('front.m.texture.repeat',repeat);
  
    //     cube.s({
    //         'm.color' : color,
    //         //设置为透明的话，生成的颜色块效果不好
    //         // 'm.transparent' : true,
    //         // 'm.opacity' : 1, //0.2
    //         'front.m.type':'basic',
    //         'front.m.texture.image':image,
    //         'front.m.texture.repeat':repeat
    //     });
    //     return cube;
    //   },

    createTextImage: function (text, parameters) {
        text = text || '';
        text += '';
        var font = parameters.font, color = parameters.color;
        var background = parameters.background, powerOfTwo = parameters.powerOfTwo, canvas = parameters.canvas;
        var drawFunction = parameters.drawFunction;
        canvas = canvas || document.createElement('canvas');
        font = font || '20px "Dialog"';
        color = color || 'white';
        background = background === undefined ? '#0F90C4' : background;
        powerOfTwo = powerOfTwo || false;
        var lines = text.split('\n');
        var size = mono.Utils.getMaxTextSize(lines, font);
        // 长度固定，如果不这样的话，当text字数少时，比如就一个字，但是cube的width正好也小，这会显示不下，
        // 可是这么固定后就无法居中了,所以就采用上面的左右补空格法，不齐到10个字符
        //        var size = {width:2048,height:256};
        var ratio = parameters.ratio || size.width / size.height;
        var realSize = canvas.realSize = {
            width: size.width,
            height: size.height,
        };

        // if (powerOfTwo) {
        //     size.width = mono.Utils.nextPowerOfTwo(size.width);
        //     size.height = mono.Utils.nextPowerOfTwo(size.height);
        // }
        var drawRect = canvas.drawRect = {
            width: realSize.width / realSize.height > ratio ? realSize.width : realSize.height * ratio,
            height: realSize.width / realSize.height > ratio ? realSize.width / ratio : realSize.height,
        }
        if (Number.isNaN(drawRect.width)) {
            console.log('debug -- b', realSize.width, realSize.height, ratio);
        }
        // drawRect.width = Math.min(drawRect.width, size.width);
        // drawRect.height = Math.min(drawRect.height, size.height);
        if (powerOfTwo) {
            size.width = mono.Utils.nextPowerOfTwo(drawRect.width);
            size.height = mono.Utils.nextPowerOfTwo(drawRect.height);
        }
        canvas.width = size.width;
        canvas.height = size.height;
        //   针对1U设备，即height太小的时候，使用上述方法，会使得字变得很窄，变形了，且某些情况下，字不符合2的幂规格，因此进行修改
        //   此处为修改2  2017.12.15 add by lyz 
        // if (ratio) {
        //     canvas.height = size.width / ratio;
        //     drawRect.height = drawRect.width / ratio;
        // }
        if (Number.isNaN(drawRect.width)) {
            console.log('debug -- a');
        }

        var ctx = canvas.getContext("2d");
        background && (ctx.fillStyle = background);
        if (drawFunction) {
            drawFunction(ctx, canvas.width, canvas.height);
        } else {
            background && (ctx.fillRect(0, 0, canvas.width, canvas.height));
            // drawText(ctx, text, font, color, can;vas, 'center');
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.strokeStyle = 'gray';
            ctx.textBaseline = 'middle';
            // ctx.textAlign = 'center';
            var lineCount = lines.length, averageHeight = realSize.height / lineCount
            for (var i = 0; i < lineCount; i++) {
                var width = mono.Utils.getTextSize(font, lines[i]).width;
                var height = canvas.height;
                var x = (drawRect.width - realSize.width) / 2;
                var y = (drawRect.height - realSize.height) / 2 + averageHeight / 2 + i * averageHeight + (canvas.height - drawRect.height);

                ctx.strokeText(lines[i], x, y);
                ctx.fillText(lines[i], x, y);
            }
        }
        return canvas;
    },

});

it.SpaceManager = $SpaceManager;

var $SpaceVisibleFilter = function(sceneManager,spaceManager){
   this.sceneManager = sceneManager;
   this.spaceManager = spaceManager;
   this.visibleMap = {};
   var self = this;
   this.sceneManager.viewManager3d.addPropertyChangeListener(function(event){
       if(event.property == "focusNode"){
         self.visibleMap = {};
       }
   });
};

mono.extend($SpaceVisibleFilter,$VisibleFilter,{
  
    isVisible: function(node,data,network){
        var id = node.getId();
        // if(this.visibleMap[id] != undefined){
        //      return this.visibleMap[id];
        // }
        // var sm = this.sceneManager;
        // var sm2 = this.spaceManager;
        // var dm = sm.dataManager;
        // var focusNode = sm.viewManager3d.getFocusNode();
        // var root = node.getClient("modelParent") || node;
        // if(sm2.isSpaceNode(node) && root == node){
        //     root = node.getParent().getClient("modelParent") || root;
        // }
        if(node instanceof mono.Billboard){
            this.visibleMap[id] = false;
        	return false;
        }
        // if(focusNode === node){
        //     this.visibleMap[id] = true;
        // 	return true;
        // }
        // if(sm2.isSpaceNode(node)){
        // 	if(focusNode == root){
        //         this.visibleMap[id] = false;
        // 		return false;
        // 	}else{
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}
        // }
        // if(sm2.isSpaceChildrenNode(node)){
        // 	if(focusNode == node.getParent()){
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}
        //     this.visibleMap[id] = false;
        // 	return false;
        // }
        // if((node === root || sm.getMainNode(node) === root) && sm2.hasSpaceNode(root)){
        // 	if(focusNode == root){
        //         this.visibleMap[id] = true;
        // 		return true;
        // 	}else{
        //         this.visibleMap[id] = false;
        // 		return false;
        // 	}
        // }
        // if(data){
        //   var parent = sm.getParentNode(data);
        //   var parentData = dm.getParent(data);
        //   if(parent && parentData){
        //   	  var flag = this.isVisible(parent,parentData,network);
	       //    if(!flag){
        //         this.visibleMap[id] = false;
	       //    	return false;
	       //    }
        //   }
        // }
        // this.visibleMap[id] = true;
        return true;
    }
});

it.SpaceVisibleFilter = $SpaceVisibleFilter;

var $SpaceMaterialFilter = function (sceneManager,spaceManager) {
	this.sceneManager = sceneManager;
  this.spaceManager = spaceManager;
	this.materialMap = {};
};

mono.extend($SpaceMaterialFilter,$MaterialFilter,{
    filterMaterial : function(originalMaterial,filterdMaterial,node){
      var sm = this.sceneManager;
      var vm = sm.viewManager3d;
      var sm2 = this.spaceManager;
      var focusNode = vm.getFocusNode();
      var map = this.materialMap;

      if(sm.getNodeData(node)){
         return filterdMaterial;
      }
      if(sm2.isSpaceNode(node)){
         if(focusNode){
            if(node.isDescendantOf(focusNode)){
               return filterdMaterial;
            }else{
              var id = originalMaterial.getUniqueCode();
              var m = this.materialMap[id];
              if(!m){
                 m = originalMaterial.clone();
                 this.materialMap[id] = m;
                 m.transparent = true;
                 m.opacity = 0.05;
              }
              return m;
            }
         }
      }

	},

});

it.SpaceMaterialFilter = $SpaceMaterialFilter;
/**
 * create by Kevin
 * 综合布线管理
 *  Link在add至DataManagement中时其实就已经创建，只不过都隐藏掉了
 *  这里主要处理:
 *  1.什么时候显示哪些对象(包括it.Link本身，以及与其相关的it.Data);
 *  2.重新计算link的走向，虽一开始添加至datamanager中就计算好了走向，但是有可能没有考虑到同时显示多条link的问题(或者是没有考虑到其他的link的情况);
 *  3.当显示link时，如果其对应的fromNode或toNode没有加载则要将其加载；
 *
 * //如果fromNode和toNode(没加载)，则连到它的parent.
 * //可是当node加载后又应该自动连接到node本身,也就是每生成一个3D对象就得判断是不是有它的连线联到了其他的对象
 *
 * 或者点击父设备看详细时，查看该父设备上是不是有link，然后再判断该link本身是要连到哪里
 *
 * @constructor
 */

var $GCSManager = function(obj) {
    var obj = obj || {};
    this.sceneManager = obj.sceneManager;
    this.viewManager3d = this.sceneManager.viewManager3d;
    this.box3D = this.sceneManager.network3d.getDataBox();
    this.defaultMaterialFilter = this.viewManager3d.getDefaultVirtualMaterialFilter();
    this.defaultEventHandler = this.viewManager3d.getDefaultEventHandler();
    this._flagLink = null; // 用于存放动态变化了的Link，如：鼠标滑过link时link变粗，鼠标移走就又变回去，此时得把它保存至着
    this.animates = {};
    this.linkBillboard = {};
    this.linkManager = new $LinkManager(this.sceneManager);
    this.defaultSetFocusNode = this.viewManager3d.setFocusNode;
    this.undoSetFocusNode = function(node) {};
    this.mdfMap = {};
    this.lightBillboardMap = {};
    this.init();
};

mono.extend($GCSManager, $EventHandler, {

    init: function() {
        this.viewManager3d.addEventHandler(this);
        var self = this;
        this.gcsManagerInterval = setInterval(function() {
            var billboards = self.linkBillboard;
            if (billboards) {
                for (var id in billboards) {
                    var link = self.sceneManager.dataManager.getLinkById(id);
                    if (!link) {
                        continue;
                    }
                    var billboard = billboards[id];
                    var bg = '#5B8505';
                    var value = link._userDataMap['flow'] || 1;
                    var canvas = billboard.getStyle('m.texture.image');
                    if (!(canvas instanceof HTMLCanvasElement)) {
                        canvas = null;
                    }
                    billboard.setStyle('m.texture.image', it.Util.getSpecialTextBillboard(value.toFixed(2), it.util.i18n("LinkSearch_Flow") +':', 'M/s', bg, false, canvas));
                    billboard.invalidateTexture();
                }
            }
        }, 10000);

        this.sceneManager.addSceneChangeListener(function(eve){
            self.clearAllLink();
        });
    },

    /**
     * 隐藏所有的link
    */
    clearAllLink: function(withoutAfterClearCall, lookAtData) {
        for (var linkId in this.sceneManager.linkMap) {
            this.clearLinkById(linkId, lookAtData);
        }
        this.unlock();
        if(this.gcsManagerInterval){
            clearInterval(this.gcsManagerInterval);
        }
        if (!withoutAfterClearCall) {
            this.afterClearAllLinkFunction && this.afterClearAllLinkFunction();
        }
    },

    /**
     *
     * 锁定，就是锁定LookAt时的真假切换和lookAt时的虚幻管理
     * 若是点击背景回到上一层时，该如何处理，是否阻止？
     */
    lock: function() {
        this.sceneManager.doubleClickBackgroundGotoUpLevelScene = false;
        this.viewManager3d.setFocusNode = this.undoSetFocusNode;
        this.viewManager3d.setCameraDistanceForAfterPlayCamere(this.sceneManager.getCurrentRootNode());//每次锁定的时候，镜头的缩放范围根据rootNode来
    },

    /**
     * 解锁，就是解开LookAt时的真假切换和lookAt时的虚幻管理
     */
    unlock: function() {
        this.sceneManager.doubleClickBackgroundGotoUpLevelScene = true;
        this.viewManager3d.setFocusNode = this.defaultSetFocusNode;
    },

    stopAllAnimates: function() {
        if (!this.animates) {
            return;
        }
        for (var id in this.animates) {
            var animate = this.animates[id];
            if (animate instanceof Array) {
                for (var i = 0; i < animate.length; i++) {
                    animate[i] && animate[i].stop();
                }
            } else {
                this.animates[id].stop();
            }
            delete this.animates[id];
        }
    },

    clearAllAnimateBillboard: function() {
        if (!this.lightBillboardMap) {
            return;
        }
        for (var id in this.lightBillboardMap) {
            if (this.lightBillboardMap[id]) {
                this.box3D.remove(this.lightBillboardMap[id]);
            }
        }
    },

    /**
     * 清除Link
     * 注意：清除link时也得处理fromNode和toNode，如果from或to不在当前场景时得把from或to从box中remove掉，甚至包括from或to的parent
     *
     * @param linkOrId
     * @param lookAtData lookAt的对象，在怎么清空也不能把当前正(或马上准备)lookAt的对象给清空掉
     */
    clearLinkById: function(linkOrId, lookAtData) {
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var sm = this.sceneManager;
        var link = sm.dataManager.getLinkById(id);
        if (!link) return;
        var linkNode = sm.linkMap[id];
        if (!linkNode) { //有可能还没有创建
            return;
        }
        if (this.animates && this.animates[id]) {
            var animate = this.animates[id];
            if (animate instanceof Array) {
                for (var i = 0; i < animate.length; i++) {
                    animate[i] && animate[i].stop();
                }
            } else {
                this.animates[id].stop();
            }
            delete this.animates[id];
        }
        if (this.lightBillboardMap && this.lightBillboardMap[id]) {
            this.box3D.remove(this.lightBillboardMap[id]);
        }
        ///一开始link要是显示着的，并且要在box中,因为在其他的场景中也会调到该方法，因此有可能什么都不会显示
        if (linkNode && linkNode.isVisible() && this.box3D.getDataById(linkNode.getId())) {
            var fromId = link.getFromId();
            var toId = link.getToId();
            var fromData = sm.dataManager.getDataById(fromId);
            var toData = sm.dataManager.getDataById(toId);
            if (fromData && toData) {
                var fromSceneAndRoot = sm.getSceneAndRootByData(fromData);
                var toSceneAndRoot = sm.getSceneAndRootByData(toData);
                var isSameScene = true;
                var targetSceneAndRoot = sm.getSceneAndRootByData(lookAtData);
                if (fromSceneAndRoot && !toSceneAndRoot) {
                    isSameScene = false;
                } else if (!fromSceneAndRoot && toSceneAndRoot) {
                    isSameScene = false;
                } else if (fromSceneAndRoot && toSceneAndRoot && (fromSceneAndRoot.scene != toSceneAndRoot.scene || fromSceneAndRoot.rootData != toSceneAndRoot.rootData)) {
                    isSameScene = false;
                } else if (fromSceneAndRoot && targetSceneAndRoot && (fromSceneAndRoot.scene != targetSceneAndRoot.scene || fromSceneAndRoot.rootData != targetSceneAndRoot.rootData)) {
                    isSameScene = false;
                }
                if (!isSameScene) {
                    var fromRootNode = sm.getNodeByDataOrId(fromSceneAndRoot.rootData);
                    var toRootNode = sm.getNodeByDataOrId(toSceneAndRoot.rootData);
                    if (lookAtData && (lookAtData == fromData || lookAtData == toData)) {
                        if (lookAtData == fromData) {
                            this.box3D.removeByDescendant(toRootNode);
                            if (sm._currentScene != fromSceneAndRoot.scene || sm._currentRootNode != fromRootNode) {
                                sm._currentScene = fromSceneAndRoot.scene;
                                sm._currentRootNode = fromRootNode;
                                //还需要派发sceneChange的事件
                                sm._sceneChangeDispather.fire({
                                    kind: 'changeScene',
                                    data: fromSceneAndRoot.scene
                                });
                                this.defaultEventHandler.lookAt(sm.getNodeByDataOrId(lookAtData));
                            }
                        } else { //if(lookAtData == toData){
                            this.box3D.removeByDescendant(fromRootNode);
                            if (sm._currentScene != toSceneAndRoot.scene || sm._currentRootNode != toRootNode) {
                                sm._currentScene = toSceneAndRoot.scene;
                                sm._currentRootNode = toRootNode;
                                //还需要派发sceneChange的事件
                                sm._sceneChangeDispather.fire({
                                    kind: 'changeScene',
                                    data: toSceneAndRoot.scene
                                });
                                this.defaultEventHandler.lookAt(sm.getNodeByDataOrId(lookAtData));
                            }
                        }
                    } else {
                        if (fromSceneAndRoot && fromSceneAndRoot.rootData) {
                            if (fromRootNode != sm.getCurrentRootNode()) {
                                this.box3D.removeByDescendant(fromRootNode);
                            }
                        }
                        if (toSceneAndRoot && toSceneAndRoot.rootData) {
                            if (toRootNode != sm.getCurrentRootNode()) {
                                this.box3D.removeByDescendant(toRootNode);
                            }
                        }
                    }
                }
            }
            // 移除掉配线架
            var fromRackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(fromId));
            var fromRackData = this.sceneManager.getNodeData(fromRackNode);
            var fromMdfNode = this.mdfMap[fromRackData.getId()];
            if (fromMdfNode) {
                fromMdfNode.setParent(null);
                this.sceneManager.network3d.dataBox.remove(fromMdfNode);
            }
            var toRackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(toId));
            var toRackData = this.sceneManager.getNodeData(toRackNode);
            var toMdfNode = this.mdfMap[toRackData.getId()];
            if (toMdfNode) {
                toMdfNode.setParent(null);
                this.sceneManager.network3d.dataBox.remove(toMdfNode);
            }
        }
        linkNode.setVisible(false);
        var billboard = this.linkBillboard[id];
        if (billboard) {
            billboard.setVisible(false);
        }
    },

    /**
     * 根据data或dataId隐藏其对应的link
     * @param dataOrId
     */
    clearLinksByData: function(dataOrId, lookAtData) {
        var data = null;
        var sm = this.sceneManager;
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var rackNode = this.getRackNodeByNode(this.sceneManager.getNodeByDataOrId(data));
        var rackData = this.sceneManager.getNodeData(rackNode);
        var mdfNode = this.mdfMap[rackData.getId()];
        if (mdfNode) {
            mdfNode.setParent(null);
            this.sceneManager.network3d.dataBox.remove(mdfNode);
        }
        var links = data.getAllLinks();
        if (links) { //这是个对象不是数组
            var linkCount = 0;
            for (var linkId in links) {
                this.clearLinkById(linkId);
                linkCount++;
            }
            if (linkCount < 1) {
                return;
            }
            if (lookAtData) {
                var lookAtSceneAndRoot = this.sceneManager.getSceneAndRootByData(lookAtData);
                var isSameScene = true;
                var lookAtNode = sm.getNodeByDataOrId(lookAtData);
                var lookAtRootNode = null;
                if (lookAtSceneAndRoot && lookAtSceneAndRoot.rootData) {
                    lookAtRootNode = sm.getNodeByDataOrId(lookAtSceneAndRoot.rootData);
                }
                if (lookAtSceneAndRoot && !sm._currentScene) {
                    isSameScene = false;
                } else if (!lookAtSceneAndRoot && sm._currentScene) {
                    isSameScene = false;
                } else if (lookAtSceneAndRoot.scene != sm._currentScene || sm._currentRootNode != lookAtRootNode) {
                    isSameScene = false;
                }
                if (!isSameScene) {
                    this.box3D.removeByDescendant(sm._currentRootNode);
                    this.box3D.addByDescendant(lookAtRootNode);
                    this.box3D.addByDescendant(lookAtNode); //万一lookAt和lookAtRoot脱离了关系(如：中间的filter过滤掉了)
                    sm._currentScene = lookAtSceneAndRoot.scene;
                    sm._currentRootNode = lookAtRootNode;
                    //还需要派发sceneChange的事件
                    sm._sceneChangeDispather.fire({
                        kind: 'changeScene',
                        data: lookAtSceneAndRoot.scene
                    });
                    this.defaultEventHandler.lookAt(lookAtNode);
                }
            }
        }

    },

    /**
     * 根据data显示其上面的所有link
     * 如果link的数量大于1时，则需要实现自动排开（由于没有端口这个实体，电线估计就不需要排开了，如果是网线的话估计是应该排开的）
     * 排开基本算法：
     *  根据Node的boundbox的x来平均分？？？
     * @param dataOrId

     ** 此方法可以去掉。。。 
     */
    showLinksByData: function(dataOrId, resetControls) {
        var data = null;
        this.clearAllLink();
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var links = data.getAllLinks();
        var maxLink = null;
        var nodes = [];
        if (links) {
            var linkNodes = [];
            for (var linkId in links) {
                this._createLinkByLinkId(linkId, resetControls, false);
                var linkNode = this.sceneManager.linkMap[linkId];
                linkNodes.push(linkNode);
                var link = links[linkId];
                if (link) {
                    var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                    var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                    nodes.push(fromNode);
                    nodes.push(toNode);
                }
            }
            if (linkNodes.length === 1) {
                this.defaultEventHandler.lookAt(linkNodes[0]);
                return;
            } else {
                this.defaultEventHandler.lookAtElements(nodes);
            }
            this.lock();
        } else {
            var dataNode = this.sceneManager.getNodeByDataOrId(data);
            if (dataNode) {
                this.defaultEventHandler.lookAt(dataNode);
            }
        }
    },

    afterShowLink: function(link) {

    },

    /**
     * 显示了到某个node的多条链路后
     */
    afterShowNetLinks: function(objects) {
        // if (!links || links.length > 0) {
        //     for (var i = 0; i < links.length; i++) {
        //         var link = links[i];
        //         this.afterShowLink(link);
        //     }
        // }
    },
    
    /**
     * 根据dataOrId显示连到到data上的所有的链路
     */
    showMulLinkByData: function(dataOrId, resetControls) {
        var data = null;
        this.clearAllLink();
        if (dataOrId instanceof it.Data) {
            data = dataOrId;
        } else {
            data = this.sceneManager.dataManager.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        if (!this.linkManager.linkMap) {
            this.linkManager.computeLinkTree();
        }
        var objects = this.linkManager.getMulLinksByDataId(dataOrId);
        var nodes = [];
        if (objects && objects.length > 0) {
            this.lock();
            var linkNodes = [];
            this.viewManager3d.defaultMaterialFilter.addAll(); //处理虚化，自己管理
            // 当link都在同一层显示时，floor可以不虚化；当link跨楼层时，floor应该都虚化掉 
            this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager._currentRootData);
            for (var j = 0; j < objects.length; j++) {
                var links = objects[j];
                if (!links || links.length < 1) {
                    console.log("link's length is 0 ,please to check!!!");
                    continue;
                }
                for (var i = 0; i < links.length; i++) {
                    var link = links[i];
                    if (link) {
                        this._createLinkByLinkId(link.getId(), resetControls, false);
                        var linkNode = this.sceneManager.linkMap[link.getId()];
                        linkNodes.push(linkNode);
                        var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                        var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                        nodes.push(fromNode);
                        nodes.push(toNode);
                        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager.getNodeData(fromNode)); //处理虚化，自己管理
                        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager.getNodeData(toNode)); //处理虚化，自己管理
                    }
                }
            }
            if (nodes && nodes.length > 0) {
                for(var i = 0 ; i < nodes.length ; i++){
                    if (!this.sceneManager.isCurrentSceneInstance(this.sceneManager.getNodeData(nodes[i]))) {
                        this.viewManager3d.defaultMaterialFilter.add(this.sceneManager._currentRootData);
                        break;
                    }
                }
            }
            if (linkNodes.length === 1) {
                this.defaultEventHandler.lookAt(linkNodes[0]);
            } else {
                this.defaultEventHandler.lookAtElements(nodes);
            }
            this.afterShowNetLinks(objects);
            this.playAnimateByLinks(objects[0]);
        } else {
            var dataNode = this.sceneManager.getNodeByDataOrId(data);
            if (dataNode) {
                this.defaultEventHandler.lookAt(dataNode);
            }
        }
        // 2017-10-30 由于lookAtLink时，setFouce锁定了，如果当前focus的不是Floor时，
        //  不管怎么点击背景都总数看到一个地方，而现在的逻辑则是点击背景会清空link回退到上一层
        this.sceneManager.viewManager3d._focusNode = this.sceneManager.getCurrentRootNode();
    },

    /**
     * lookAt一整条链路
     */
    lookAtLinks: function(links) {
        if (!links) {
            return;
        }
        if (!(links instanceof Array)) {
            var linkNode = this.sceneManager.linkMap[links.getId()];
            this.defaultEventHandler.lookAt(linkNode);
            return;
        }
        if (links.length == 1) {
            var linkNode = this.sceneManager.linkMap[links[0].getId()];
            this.defaultEventHandler.lookAt(linkNode);
            return;
        }
        var nodes = [];
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            if (link) {
                var fromNode = this.sceneManager.getNodeByDataOrId(link.getFromId());
                var toNode = this.sceneManager.getNodeByDataOrId(link.getToId());
                nodes.push(fromNode);
                nodes.push(toNode);
            }
        }
        this.defaultEventHandler.lookAtElements(nodes);
    },

    /**
     * 显示所有的link，太多的话一般不需要全部显示，貌似没有什么意义
     * 注意：对于没有加载的link这里需要将fromNode和toNode加载好后，再重新加载Link
     * @param resetControls
     */
    showAllLinks: function(resetControls) {
        var linkMap = this.sceneManager.dataManager.getLinkMap();
        if (!linkMap) return;
        for (var id in linkMap) {
            this.showLinkByLinkId(id, resetControls, false);
        }
    },

    showBillboard: function(link) {
        return true;
    },

     //这里重写，把同步的程序给逆转为异步 -- add by azhuang 2018-1-10 

        /*
        * 连线搜索树的点击事件
        * 在点击的时候加载node
        * node的加载是异步的
        * 所以所有依赖node的操作都要放在加载完的callback里
        * node加载完是在loadlazydata的回调里
        * 先加载from->后加载to->加载link->Link的处理事件
        */
    _createLinkByLinkId: function(linkOrId, resetControls, removeOthers, withOutHeight, callback, scop) {
        var id = linkOrId;
        var isClear = true;
        if (removeOthers != undefined && removeOthers != null) {
            isClear = removeOthers;
        }
        if (isClear) {
            this.clearAllLink();
        }
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        if (id) {
            this.originLinkId = id;
            var contralPoints = null;
            var linkRes = this.createlinkRelationById(id);
            var link = linkRes.link;
            var fromId = linkRes.fromId;
            var toId = linkRes.toId;
            var fromPortId = linkRes.fromPortId;
            var toPortId = linkRes.toPortId;
            var fromSide = linkRes.fromSide;
            var toSide = linkRes.toSide;
            var fromNode = linkRes.fromNode;
            var toNode = linkRes.toNode;
            var linkNode = linkRes.linkNode;

            //这里重写，把同步的程序给逆转为异步 -- add by azhuang 2018-1-10 
            //思路：linkNode的加载依赖于fromNode和toNode，而这两个node的加载是异步的
            //问题1：两个设备还好，如果有多个node的加载状态需要监测怎么办
            // if (!linkNode) { // 如果没有，可能是因为之前from和to没有加载，这里得需要处理，并重新load
            //     if (this.reloadLink(id)) {
            //         linkNode = this.sceneManager.linkMap[id];
            //         fromNode = this.sceneManager.dataNodeMap[fromId];
            //         toNode = this.sceneManager.dataNodeMap[toId];
            //     }
            // }
            
            if (fromNode && toNode) {
                this.showFromAndToNode(fromNode,toNode);
                if(!linkNode){
                    this.sceneManager.loadLink(link);
                }
                this.afterLoadLinkNode(id, resetControls, withOutHeight, callback, scop);
            }else{
                var self = this;
                var afterLoadFromNode = function(fromNode){
                    var afterLoadToNode = function(toNode){
                        var link = self.createlinkRelationById(id).link;
                        var fromNode = self.createlinkRelationById(id).fromNode;
                        var toNode = self.createlinkRelationById(id).toNode;
                        self.showFromAndToNode(fromNode,toNode);
                        self.sceneManager.loadLink(link);
                        self.afterLoadLinkNode(id, resetControls, withOutHeight, callback, scop);
                        //连线这里是同步的
                    };
                    self.sceneManager.loadLazyData(toId,afterLoadToNode);
                }
                this.sceneManager.loadLazyData(fromId,afterLoadFromNode);
            }
        }
    },
    createlinkRelationById: function(id){
        var link = this.sceneManager.dataManager.getLinkById(id);
        var fromId = link.getFromId();
        var toId = link.getToId();
        var fromPortId = link.getFromPortId();
        var toPortId = link.getToPortId();
        var fromSide = link.getFromSide();
        var toSide = link.getToSide();
        //fromNode和toNode这么早弄出来，有可能为null，所以确保一定拿得到，下面reload后重取一次
        var fromNode = this.sceneManager.dataNodeMap[fromId];
        var toNode = this.sceneManager.dataNodeMap[toId];
        var linkNode = this.sceneManager.linkMap[id];
        return {
            link: link,
            fromId: fromId,
            toId: toId,
            fromPortId: fromPortId,
            toPortId: toPortId,
            fromSide: fromSide,
            toSide: toSide,
            fromNode: fromNode,
            toNode: toNode,
            linkNode: linkNode
        }
    },
    showLinkNode: function(id,resetControls,withOutHeight){
        var linkRes = this.createlinkRelationById(id);
        var link = linkRes.link;
        var fromId = linkRes.fromId;
        var toId = linkRes.toId;
        var fromPortId = linkRes.fromPortId;
        var toPortId = linkRes.toPortId;
        var fromSide = linkRes.fromSide;
        var toSide = linkRes.toSide;
        var fromNode = linkRes.fromNode;
        var toNode = linkRes.toNode;
        var linkNode = linkRes.linkNode;
        // 对于mono.Link，当fromNode或toNode从box中移除后，它会将link的from和to置为null
        if (!linkNode.getFromNode()) {
            var linkFromNode = fromNode;
            if (fromPortId) { // add by 2016-12-06 端对端
                var fromPortNode = this.sceneManager.postManager.loadPortByPortId(fromId, fromPortId, fromSide);
                if (fromPortNode) {
                    linkFromNode = fromPortNode;
                }
            }
            linkNode.setFromNode(linkFromNode);
        }
        if (!linkNode.getToNode()) {
            var linkToNode = toNode;
            if (toPortId) { // add by 2016-12-06 端对端
                var toPortNode = this.sceneManager.postManager.loadPortByPortId(toId, toPortId, toSide);
                if (toPortNode) {
                    linkToNode = toPortNode;
                }
            }
            linkNode.setToNode(toNode);
        }
        linkNode.setVisible(true);
        if (!this.box3D.getDataById(linkNode.getId())) { // 有可能中途被移除掉了，当from或to被移出时，link也会被移除
            this.box3D.add(linkNode);
        }
        if (resetControls) {
            contralPoints = this.resetPathByLink(id, withOutHeight);
        }
    },
    showFromAndToNode: function(fromNode,toNode){
        //去掉其透明
        this.defaultMaterialFilter.removeByDescendant(fromNode);
        this.defaultMaterialFilter.removeByDescendant(toNode);

        //如果不在box中也需要弄进去
        if (!this.box3D.getDataById(fromNode.getId())) {
            this.box3D.addByDescendant(fromNode);
        }
        if (!this.box3D.getDataById(toNode.getId())) {
            this.box3D.addByDescendant(toNode);
        }
        var fromRootNode = this.getNodeRootNodeByNode(fromNode);
        var fromRootData = this.sceneManager.getNodeData(fromRootNode);
        var self = this;
        if (fromRootNode && !this.box3D.getDataById(fromRootNode.getId())) {
            this.box3D.addByDescendant(fromRootNode, function(childNode) {
                var childNodeData = self.sceneManager.getNodeData(childNode);
                if (childNodeData && childNodeData == fromRootData) {
                    return true;
                } else {
                    return false;
                }
            });
        }
        var toRootNode = this.getNodeRootNodeByNode(toNode);
        var toRootData = this.sceneManager.getNodeData(toRootNode);
        if (toRootNode && !this.box3D.getDataById(toRootNode.getId())) {
            this.box3D.addByDescendant(toRootNode, function(childNode) {
                var childNodeData = self.sceneManager.getNodeData(childNode);
                if (childNodeData && childNodeData == toRootData) {
                    return true;
                } else {
                    return false;
                }
            });
        }
    },
    afterLoadLinkNode: function(id, resetControls, withOutHeight, callback, scop){
        var link = this.createlinkRelationById(id).link;
        this.lock();
        var fromId = link.getFromId();
        var toId = link.getToId();
        if (!this.sceneManager.isCurrentSceneInstance(fromId) 
            || !this.sceneManager.isCurrentSceneInstance(toId)) {
            this.viewManager3d.defaultMaterialFilter.add(this.sceneManager._currentRootData);
        }
        this.showLinkNode(id,resetControls,withOutHeight);
        if (this.showBillboard(link)) {
            var billboard = this.createBillboard(link);
        }
        this.afterShowLink(link);
        callback && callback(scop);
    },
    /**
     * 根据linkId显示link
     * 创建后，以及后续的是否创建billboard，是否调用afteer
     * @param linkOrId
     * @param resetControls
     * @param removeOthers
     *
     */
    showLinkByLinkId: function(linkOrId, resetControls, removeOthers, withOutHeight ,callback, scop) {
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var link = this.sceneManager.dataManager.getLinkById(id);
        if (!link) {
            return ;
        }
        this.viewManager3d.defaultMaterialFilter.addAll(); //2017-10-20 处理虚化 _createLinkByLinkId中会将link上的node的虚化清掉
        // 当link都在同一层显示时，floor可以不虚化；当link跨楼层时，floor应该都虚化掉 
        this.viewManager3d.defaultMaterialFilter.remove(this.sceneManager._currentRootData);
        this._createLinkByLinkId(link, resetControls, removeOthers, withOutHeight ,callback, scop);
    },

    /**
     * 获取node的根
     * @param node
     * @returns {*}
     */
    getNodeRootNodeByNode: function(node) {
        if (!node) {
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        var sceneAndRoot = this.sceneManager.getSceneAndRootByData(data);
        if (sceneAndRoot && sceneAndRoot.rootData) {
            return this.sceneManager.getNodeByDataOrId(sceneAndRoot.rootData);
        }
        return null;
    },

    createBillboard: function(link) {
        if (!link) {
            return;
        }
        var linkNode = this.sceneManager.linkMap[link.getId()];
        if (!linkNode) {
            return;
        }
        var contralPoints = linkNode.getControls();
        var px, py, pz;
        if (contralPoints && contralPoints.length > 4) {
            var p4 = contralPoints[3];
            px = p4.x;
            py = p4.y + 60;
            pz = p4.z;
        }
        var billboard = this.linkBillboard[link.getId()];
        if (!billboard) {
            var billboard = it.Util.createSpecailTextBillboard("text");
            billboard.setPosition(px || 0, py || 0, pz || 0);
            var bg = '#5B8505';
            var value = link._userDataMap['flow'] || 0;
            billboard.setStyle('m.texture.image', it.Util.getSpecialTextBillboard(value.toFixed(2), it.util.i18n("LinkSearch_Flow") +':', 'M/s', bg));
            billboard.invalidateTexture();
            billboard.s({
            	'm.fixedSize': 5000,
            })
            this.box3D.add(billboard);
            this.linkBillboard[link.getId()] = billboard;
        } else {
            billboard.setVisible(true);
            if (!this.box3D.getDataById(billboard.getId())) {
                this.box3D.add(billboard);
            }
        }
    },

    /**
     * 重新加载Link
     * @param linkOrId
     * @returns {boolean} 返回的为true时，表示的是重新加载了，否则则没有重新加载
     */
    reloadLink: function(linkOrId) {
        if (!linkOrId) {
            return false;
        }
        var link = null;
        if (linkOrId instanceof it.Link) {
            link = linkOrId;
        } else {
            link = this.sceneManager.dataManager.getLinkById(linkOrId);
        }
        if (!link) {
            return false;
        }
        var linkNode = this.sceneManager.linkMap[link.getId()];
        if (linkNode) {
            return false;
        }
        var fromId = link.getFromId();
        var toId = link.getToId();
        //如果from和to不是在同一个场景中，该怎么处理？将两个场景的数据都加载出来？可是lookAt到from或to时在回到上一级又该怎么处理
        var fromNode = this.sceneManager.dataNodeMap[fromId];
        if (!fromNode) {
            if (!this.sceneManager.dataManager.getDataById(fromId)) {
                return false;
            }
            this.sceneManager.loadLazyData(fromId);
        }
        var toNode = this.sceneManager.dataNodeMap[toId];
        if (!toNode) {
            if (!this.sceneManager.dataManager.getDataById(toId)) {
                return false;
            }
            this.sceneManager.loadLazyData(toId);
        }
        this.sceneManager.loadLink(link);
        return true;
    },

    resetPathByLink: function(linkOrId, withOutHeight) {
        if (!linkOrId) {
            return null;
        }
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var linkNode = this.sceneManager.linkMap[id];
        if (!linkNode) return null;
        var controls = null;
        if (withOutHeight) {
            controls = this.generateControlsWithOutHeight(linkNode);
        } else {
            // controls = this.generateControls(linkNode,200);
            controls = this.generateControlsWithMDF(linkNode);
        }
        if (controls) {
            linkNode.setControls(controls);
        }
        return controls;
    },

    resetPathByData: function(dataOrId) {

    },

    /**
     * 计算世界坐标上的点worldPosition相对于当前场景的rootNode的相对位置
     */
    getRelatePosition: function(worldPosition) {
        var rootNode = this.sceneManager.getCurrentRootNode();
        if (!rootNode || !worldPosition) {
            return null;
        }
        var wm = new mono.Mat4(); //new出来就是一个单位矩阵
        wm.setPosition(worldPosition);
        var m1, m2;
        m1 = new mono.Mat4().getInverse(rootNode.worldMatrix.clone());
        m2 = new mono.Mat4().multiplyMatrices(m1, wm);
        var position = new mono.Vec3().getPositionFromMatrix(m2);
        return position;
    },

    /**
     * 根据fromNode或toNode获取其对应的rack
     */
    getRackNodeByNode: function(node) {
        if (!node) {
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (category && category.getId() == 'rack') {
            return node;
        } else if (category && category.getId() == 'equipment') {
            var parentNode = this.sceneManager.getNodeByDataOrId(data.getParentId());
            var resuleNode = this.getRackNodeByNode.call(this, parentNode);
            return resuleNode || node;
        }
        if (node.getClient('parentId')) {
            var equipmentNode = this.sceneManager.getNodeByDataOrId(node.getClient('parentId'));
            var resultNode = this.getRackNodeByNode.call(this, equipmentNode);
            return resultNode || equipmentNode || node;
        }
        return node;
    },

    /**
     * 计算中间的控制点
     * 注意：考虑世界坐标是一方面，还得考虑floor旋转的问题； 
     *
     */
    /*
    generateControls : function(linkNode,height){
        if(!linkNode){
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if(!fromNode || !toNode){
            return null;
        }
        var bb1 = fromNode.getBoundingBox(),bb2 = toNode.getBoundingBox();
        var w_from = fromNode.getWorldPosition();
        var w_to = toNode.getWorldPosition();
        var w_r_from = null,w_r_to = null; // 机柜的世界坐标
        var frNode = this.getRackNodeByNode(fromNode);
        var trNode = this.getRackNodeByNode(toNode);
        if (frNode && frNode.getBoundingBox) {
            bb1 = frNode.getBoundingBox();
            w_r_from = frNode.getWorldPosition();
        }
        if (trNode && trNode.getBoundingBox) {
            bb2 = trNode.getBoundingBox();
            w_r_to = trNode.getWorldPosition();
        }
        var maxZ = 20, maxY = Math.max(bb1.max.y,bb2.max.y) + 20 ;
        if (maxY < 50) {
            maxY = 50;
        }
        var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ),pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ);

        // if(frNode){
        //      w_from = frNode.getWorldPosition();
        // }
        // if (trNode){
        //      w_to = trNode.getWorldPosition();
        // }
        var controls = [];
        controls.push(pos1);
        var f_pos = pos1.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_from) {
            f_pos.setY(w_r_from.y + maxY);
        }
        controls.push(f_pos);
        f_pos = w_from.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_from) {
            // f_pos.setX(w_r_from.x);
            f_pos.setY(w_r_from.y + maxY);
        }
        controls.push(f_pos); //顶

        var w_max_y = Math.max(w_from.y,w_to.y);
        if (w_r_from) {
            w_max_y = Math.max(w_max_y,w_r_from.y);
        }
        if (w_r_to) {
            w_max_y = Math.max(w_max_y,w_r_to.y);
        }
        controls.push(new mono.Vec3(w_from.x, w_max_y + height, w_from.z));
        controls.push(new mono.Vec3(w_from.x, w_max_y + height, w_to.z));
        controls.push(new mono.Vec3(w_to.x, w_max_y + height, w_to.z));

        var t_pos = pos2.clone().add(new mono.Vec3(0,maxY,0));
        if (w_r_to) {
            // t_pos.setX(w_r_to.x);
            t_pos.setY(w_r_to.y + maxY);
             var toTop = w_to.clone().add(new mono.Vec3(0,maxY,0));
             toTop.setY(w_r_to.y + maxY)
             controls.push(toTop); //顶
        }else{
            controls.push(w_to.clone().add(new mono.Vec3(0,maxY,0))); //顶
        }
        controls.push(t_pos);
        controls.push(pos2);
        return controls;
    },
    */

    /**
     *
     * 设备（或设备端口）——机柜上的配电架 —— —— 到配线架——设备（设备端口）
     * 设备——设备正面——设备正面的上方（机柜上方）——机柜上方的背后——左或右——上——配线架——穿过配线架置——到其他的机柜的配线架
     * 备注：如果不是连到设备而是连到的是机柜的话(网络设备一般不会这么连)，那就直接从机柜的顶端连下去
     *
     */
    generateControlsWithMDF: function(linkNode, height) {
        if (!linkNode) {
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if (!fromNode || !toNode) {
            return null;
        }
        var controls = [];
        var f2MdfPoints = this.getNodeToMDFControls(fromNode);
        var t2MdfPoints = this.getNodeToMDFControls(toNode);
        if (f2MdfPoints && t2MdfPoints && f2MdfPoints.length > 0 && t2MdfPoints.length > 0) {
            for (var i = 0; i < f2MdfPoints.length; i++) {
                controls.push(f2MdfPoints[i]);
            }
            var fp = f2MdfPoints[f2MdfPoints.length - 1];
            var tp = t2MdfPoints[t2MdfPoints.length - 1];
            var fMdf2TMdfPoints = this.getInflectionPoints(fp, tp);
            if (fMdf2TMdfPoints && fMdf2TMdfPoints.length > 0) {
                for (var i = 0; i < fMdf2TMdfPoints.length; i++) {
                    controls.push(fMdf2TMdfPoints[i]);
                }
            }
            for (var i = t2MdfPoints.length - 1; i >= 0; i--) {
                controls.push(t2MdfPoints[i]);
            }
        }
        return controls;
    },

    /**
     * 根据机柜创建配线架
     * 按理说，这个配线架应该是一个单独的资产，一般放在机柜中
     * 如果是资产的话，处理起来就比较方便了
     */
    getMdfByRack: function(node) {
        if (!node) {
            return null;
        }
        var nodeData = this.sceneManager.getNodeData(node);
        if (!nodeData) {
            return null;
        }
        var mdfNode = this.mdfMap[nodeData.getId()];
        if (!mdfNode) {
            var bb = node.getBoundingBox();
            var size = bb.size() || {
                x: 60
            };
            var width = 55;
            var z = 0;
            var y = 0
            var mdfNode = new mono.Cube(width, 20, 3);
            if (bb) {
                width = bb.size().x;
                z = bb.max.z - 5;
                z = z + 5 //让配线架往前突一点
                    // y = bb.max.y + 40; //放在机柜顶上
                y = bb.max.y - 12; //放在机柜里
            }
            mdfNode.setPosition(0, y, z);
            mdfNode.setClient(it.SceneManager.CLIENT_EXT_VITUAL, true);
            // mdfNode.setStyle('m.type', 'phong');
            // mdfNode.setStyle('m.color', '#3D3D3D');
            // mdfNode.setStyle('m.ambient', '#3D3D3D');
            mdfNode.setStyle('front.m.texture.image', './images/mdf_front.jpg');
            mdfNode.setStyle('back.m.texture.image', './images/mdf_front.jpg');
            mdfNode.setClient('itv_mdf', true);
            mdfNode.setClient('itv_mdf_rack_data', nodeData);
            this.mdfMap[nodeData.getId()] = mdfNode;
        }
        mdfNode.setParent(node);
        this.sceneManager.network3d.dataBox.add(mdfNode);
        return mdfNode;
    },

    /**
     * 计算两个点之间的拐点
     * 标准的计算如下：
     * 如果pos1和pos2相同或只有一个分量不同时，那可以直接返回
     * 如果有两个分量不同时，只有两个分量不同时，那返回一个中间的点即可
     * 如果三个分量不同时，那返回两个拐点
     * 否则算出的controls会有重复的点
     */
    getInflectionPoints: function(pos1, pos2) {
        if (!pos1 || !pos2) {
            return null;
        }
        var p1 = pos1.clone();
        var p2 = pos2.clone();
        var differentCount = 0;
        var points = [];
        if (p1.x != p2.x) {
            differentCount++;
            // points.push(new mono.Vec3(p2.x,p1.y,p1.z));
        }
        if (p1.y != p2.y) {
            differentCount++;
            // points.push(new mono.Vec3(p2.x,p2.y,p1.z));
        }
        if (p1.z != p2.z) {
            differentCount++;
        }
        if (differentCount <= 1) {
            return null;
        }
        if (p1.x != p2.x && differentCount > 1) {
            differentCount--;
            points.push(new mono.Vec3(p2.x, p1.y, p1.z));
        }
        if (p1.y != p2.y && differentCount > 1) {
            differentCount--;
            points.push(new mono.Vec3(p2.x, p2.y, p1.z));
        }
        // 最后z不管一不一样都没有必要计算了
        return points;
    },

    getNodeToMDFControls: function(node) {
        if (!node) {
            return null;
        }
        var controls = [];
        var rackNode = this.getRackNodeByNode(node);
        var nodeBb = node.getBoundingBox();
        var nodeWorldPosition = node.getWorldPosition();
        var frontDistance = 20;
        var backDistance = 10;
        var aboveRackDistance = 50;
        var belowRackDistance = -23;
        if (rackNode && rackNode != node) {
            var mdfNode = this.getMdfByRack(rackNode);
            var rackbb = rackNode.getBoundingBox();
            var w_r_from = rackNode.getWorldPosition();
            var pos1 = node.frontWorldPosition(nodeBb.max.z + frontDistance);
            var nodePos = node.getWorldPosition();
            controls.push(pos1); //设备前方
            var f_pos = pos1.clone();
            // f_pos.setY(w_r_from.y + rackbb.max.y + topDistance);// 机柜的前上方
            f_pos.setY(w_r_from.y + rackbb.max.y + belowRackDistance); // 机柜的前上方。现在topDistance是负的，变成机柜里
            controls.push(f_pos);
            var topOffset = new mono.Vec3(0, rackbb.max.y + belowRackDistance, 0);
            if (pos1.x != nodePos.x) {
                if (pos1.x > nodePos.x) {
                    topOffset.x = -backDistance - 10;
                } else {
                    topOffset.x = backDistance + 10;
                }
            }
            if (pos1.z != nodePos.z) {
                if (pos1.z > nodePos.z) {
                    topOffset.z = -backDistance - 10;
                } else {
                    topOffset.z = backDistance + 10;
                }
            }
            f_pos = nodeWorldPosition.clone().add(topOffset);
            f_pos.setY(w_r_from.y + rackbb.max.y + belowRackDistance);

            controls.push(f_pos); //顶
            // 连到配线架上：
            if (mdfNode) {
                var mdfAbsoluteRotationY = mdfNode.getParent().getRotationY() * 180 / Math.PI;
                var offX = 20 * Math.random(),
                    offZ = 0;
                if (mdfAbsoluteRotationY % 90 == 0) {
                    offZ = 20 * Math.random();
                    offX = 0;
                }
                var mdfOffsetPos = new mono.Vec3(offX, 5, offZ); // 连到配线架上的偏移，为了今后连到配线架上的具体位置做准备
                var mdfPos = mdfNode.getWorldPosition().clone().add(mdfOffsetPos);
                var mdfFrontPos = mdfNode.frontWorldPosition(frontDistance); //配线架出到前方的位置
                var backPos = f_pos.clone();
                if (mdfFrontPos.x != mdfPos.x && mdfPos.z != backPos.z) {
                    backPos.setZ(mdfPos.z);
                    controls.push(backPos);
                } else if (mdfFrontPos.z != mdfPos.z && mdfPos.x != backPos.x) {
                    backPos.setX(mdfPos.x);
                    controls.push(backPos);
                }
                var backTopPos = backPos.clone();
                backTopPos.setY(mdfPos.y);
                controls.push(backTopPos); //顶上往上拐一点，拐到配线架的高度

                mdfFrontPos = mdfFrontPos.clone().add(mdfOffsetPos);

                var top2MdfPoints = this.getInflectionPoints(backTopPos, mdfPos);
                if (top2MdfPoints && top2MdfPoints.length > 0) {
                    for (var i = 0; i < top2MdfPoints.length; i++) {
                        controls.push(top2MdfPoints[i]);
                    }
                }
                controls.push(mdfFrontPos);
                mdfFrontPos = mdfFrontPos.clone().add(new mono.Vec3(0, aboveRackDistance, 0)); //连到配线架的上方
                controls.push(mdfFrontPos);
            } else {
                f_pos = f_pos.clone().add(new mono.Vec3(0, 43, 0)); //如果没有配线架的话，那就再往机柜上方走100
                controls.push(f_pos);
            }
        } else {
            var tPos = rackNode.getWorldPosition().clone().add(new mono.Vec3(0, nodeBb.max.y + 43, 0)); //如果没有配线架的话，那就再往机柜上方走100
            controls.push(tPos);
        }
        return controls;
    },


    /**
     * 计算中间的控制点
     * 注意：考虑世界坐标是一方面，还得考虑floor旋转的问题； 
     *
     */
    generateControlsWithOutHeight: function(linkNode, height) {
        if (!linkNode) {
            return null;
        }
        var fromNode = linkNode.getFromNode();
        var toNode = linkNode.getToNode();
        if (!fromNode || !toNode) {
            return null;
        }
        var bb1 = fromNode.getBoundingBox(),
            bb2 = toNode.getBoundingBox();
        var w_from = fromNode.getWorldPosition();
        var w_to = toNode.getWorldPosition();
        var w_r_from = null,
            w_r_to = null; // 机柜的世界坐标
        var frNode = this.getRackNodeByNode(fromNode);
        var trNode = this.getRackNodeByNode(toNode);
        if (frNode && frNode.getBoundingBox) {
            bb1 = frNode.getBoundingBox();
            w_r_from = frNode.getWorldPosition();
        }
        if (trNode && trNode.getBoundingBox) {
            bb2 = trNode.getBoundingBox();
            w_r_to = trNode.getWorldPosition();
        }
        var maxZ = 20,
            maxY = Math.max(bb1.max.y, bb2.max.y) + 20;
        if (maxY < 50) {
            maxY = 50;
        }
        // var pos1 = fromNode.frontWorldPosition(bb1.max.z + maxZ);
        var pos1 = fromNode.worldPosition(new mono.Vec3(0, 0, -1), bb1.max.z + maxZ); //背面出
        var pos2 = toNode.frontWorldPosition(bb2.max.z + maxZ); //正面进
        // var pos2 = toNode.worldPosition(new mono.Vec3(0,0,-1),bb2.max.z + maxZ);

        var controls = [];
        controls.push(pos1);
        // var f_pos = pos1.clone().add(new mono.Vec3(0,maxY,0));
        // if (w_r_from) {
        //     f_pos.setY(w_r_from.y + maxY);
        // }
        // controls.push(f_pos);
        // f_pos = w_from.clone().add(new mono.Vec3(0,maxY,0)); 
        // if (w_r_from) {
        // f_pos.setX(w_r_from.x);
        // f_pos.setY(w_r_from.y + maxY);
        // }
        // controls.push(f_pos); //顶

        var w_max_y = Math.max(w_from.y, w_to.y);
        if (w_r_from) {
            w_max_y = Math.max(w_max_y, w_r_from.y);
        }
        if (w_r_to) {
            w_max_y = Math.max(w_max_y, w_r_to.y);
        }
        if (w_max_y != pos1.y) {
            controls.push(new mono.Vec3(pos1.x, w_max_y, pos1.z));
        }
        controls.push(new mono.Vec3(pos1.x, w_max_y, pos2.z));
        if (w_max_y != pos2.y) {
            controls.push(new mono.Vec3(pos2.x, w_max_y, pos2.z));
        }

        // var t_pos = pos2.clone().add(new mono.Vec3(0,maxY,0));
        // if (w_r_to) {
        //     // t_pos.setX(w_r_to.x);
        //     t_pos.setY(w_r_to.y + maxY);
        //      var toTop = w_to.clone().add(new mono.Vec3(0,maxY,0));
        //      toTop.setY(w_r_to.y + maxY)
        //      controls.push(toTop); //顶
        // }else{
        //     controls.push(w_to.clone().add(new mono.Vec3(0,maxY,0))); //顶
        // }
        // controls.push(t_pos);
        controls.push(pos2);
        return controls;
    },

    /**
     * 鼠标滑过Link时变粗(高亮)
     * @param node
     * @param network
     * @param data
     * @param element
     * @param event
     */
    handleMouseMoveElement: function(node, network, data, element, event) {
        var link = this.sceneManager.getLinkData(node);
        if (!link) {
            return;
        }
        if (!node.org_radius && node.setRadius) { // 注意已经划过加粗后，没有去掉之前再划
            var radius = node.getRadius() || 1;
            node.org_radius = node.getRadius();
            node.setRadius(radius + 1);
        }
        this._flagLink = node;
    },

    handleMouseMoveBackground: function(network, event) {
        if (this._flagLink && this._flagLink.org_radius) {
            this._flagLink.setRadius(this._flagLink.org_radius);
            delete this._flagLink.org_radius;
            this._flagLink = null;
        }
    },

    /**
     * 让link流动起来
     * @param link link的3D对象，id或者it.Link
     * @param neg 流动的方向
     */
    doFlow: function(link, neg) {
        if (!link) {
            return;
        }
        var linkNode = null;
        var id = link;
        if (link instanceof mono.Element) {
            linkNode = link;
            var linkData = this.sceneManager.getLinkData(linkNode);
            id = linkData.getId();
        } else {
            if (link instanceof it.Link) {
                id = link.getId();
            }
            linkNode = this.sceneManager.linkMap[id];
        }
        if (linkNode) {
            var flipx = true;
            if (neg == false) {
                flipx = false;
            }
            // linkNode.setStyle('m.texture.image','./images/link_flow.jpg');
            // linkNode.setStyle('m.texture.repeat',new mono.Vec2(100, 1));
            if (!linkNode.styleMap['m.texture.image']) {
                return;
            }
            linkNode.setStyle('m.texture.flipX', flipx);
            var animate = this.animates[id];
            if (!animate) {
                animate = new mono.Animate({
                    from: 0,
                    to: 1,
                    type: 'number',
                    dur: 500,
                    repeat: Number.POSITIVE_INFINITY,
                    reverse: false,
                    onUpdate: function(value) {
                        linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                    }
                });
                this.animates[id] = animate;
            }
            animate.play();
        }
    },

    /**
     * 清除流动效果
     * @param linkOrId
     */
    clearFlow: function(linkOrId) {
        if (!linkOrId) {
            return;
        }
        var id = linkOrId;
        if (linkOrId instanceof it.Link) {
            id = linkOrId.getId();
        }
        var animate = this.animates[id];
        if (animate) {
            if (animate instanceof Array) {

            } else {
                animate.stop();
            }
            delete this.animates[id];
        }
    },

    /**
     * 清除所有的流动效果
     */
    clearAllFlow: function() {
        // if (!this.animates) {
        //     return;
        // }
        // for (var id in this.animates) {
        //     var animate = this.animates[id];
        //     if (animate) {
        //         if (animate instanceof Array) {
        //         } else {
        //             animate.stop();
        //         }
        //         delete this.animates[id];
        //     }
        // }
        this.stopAllAnimates();
    },
    // animate, 连线上的动画：

    /**
     * 流动的billboard的图片
     */
    getImage: function() {
        return 'data:image/png;base64,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';
    },

    /**
     * 创建光点的billboard
     */
    createLightBillboard: function() {
        var billboard = new mono.Billboard();
        billboard.s({
            // 'm.texture.image': '../theme/models/light.png',
            'm.texture.image': this.getImage(),
            'm.transparent': true,
            'm.opacity': 1.0,
        });
        billboard.setScale(35, 35, 35);
        return billboard;
    },

    getAnimateDur: function() {
        return 2500;
    },

    /**
     * 创建一段动画
     */
    createLinkAnimate: function(lightBillboard, linkNode) {
        if (!lightBillboard || !linkNode) {
            return null;
        }
        if (!(linkNode instanceof mono.PathLink)) {
            return null;
        }
        var self = this;
        var animate = new mono.Animate({
            from: 0,
            to: 1,
            type: 'number',
            dur: self.getAnimateDur(),
            // repeat:Number.POSITIVE_INFINITY,
            // reverse: false,
            onUpdate: function(value) {
                // linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                var position = linkNode.getPointAt(value);
                lightBillboard.p(position.x, position.y, position.z);
            }
        });
        return animate;
    },

    /**
     * 播放一系列连线的动画
     *  @links 这是连线的数组，并且需要有先后顺序，link的顺序是倒过来的
     *  需要根据links来创建一个动画链，链从起始开始
     */
    playAnimateByLinks: function(links) {
        if (!links) {
            return;
        }
        if (!(links instanceof Array)) {
            return this.playAnimate(links);
        }
        if (links.length < 1) {
            return;
        }
        var bid = links[0].getId(); //用终点的id来创建lightBillboard
        var lightBillboard = this.lightBillboardMap[bid];
        if (!lightBillboard) {
            lightBillboard = this.createLightBillboard();
            this.lightBillboardMap[bid] = lightBillboard;
        }
        var startAnimate = null,
            preAnimate = null,
            animates = [];
        for (var i = links.length - 1; i >= 0; i--) {
            var linkNode = this.sceneManager.linkMap[links[i].getId()];
            var animate = this.createLinkAnimate(lightBillboard, linkNode);
            if (!animate) {
                continue;
            }
            if (!startAnimate) {
                startAnimate = animate;
            }
            if (!preAnimate) {
                preAnimate = animate;
            } else {
                preAnimate.chain(animate);
                preAnimate = animate;
            }
            animates.push(animate);
        }
        if (preAnimate != startAnimate) {
            preAnimate.chain(startAnimate);
        }else{ // 表示就一条线
            if(!startAnimate){
                return;
            }
            startAnimate.repeat = Number.POSITIVE_INFINITY;
            startAnimate.reverse = false;
        }
        if (startAnimate) {
            this.box3D.add(lightBillboard);
            this.animates[bid] = animates;
            startAnimate.play();
        }
    },

    /**
     * 播放一条线上的动画
     */
    playAnimate: function(link) {
        if (!link) {
            return;
        }
        if (link instanceof Array) {
            return this.playAnimateByLinks(link);
        }
        var bid = link.getId();
        var lightBillboard = this.lightBillboardMap[bid];
        if (!lightBillboard) {
            lightBillboard = this.createLightBillboard();
            this.lightBillboardMap[bid] = lightBillboard;
        }
        var self = this;
        var linkNode = this.sceneManager.linkMap[bid];
        if (!linkNode || !(linkNode instanceof mono.PathLink)) {
            return;
        }
        this.box3D.add(lightBillboard);
        var animate = new mono.Animate({
            from: 0,
            to: 1,
            type: 'number',
            dur: self.getAnimateDur(),
            repeat: Number.POSITIVE_INFINITY,
            reverse: false,
            onUpdate: function(value) {
                // linkNode.setStyle('m.texture.offset', new mono.Vec2(value, 0));
                var position = linkNode.getPointAt(value);
                lightBillboard.p(position.x, position.y, position.z);
            }
        });
        animate.play();
        this.animates[bid] = animate;
    }

});

it.GCSManager = $GCSManager;

/**
 *
 * 节点信息的数据结构
 *   注意：有可能一个节点有多个父亲，据说对于网络设备，可能存在多个对外的网络端口
 *
 */
var $LNode = function(dataId) {
    this.id = dataId || ''; // 资产ID
    this.parent = null; //LNode
    this.parents = [];
    this.children = new mono.List(); // 
    this.toParentLink = null;
    this.toParentLinks = [];
};

mono.extend($LNode, Object, {

    setParent: function(parent) {
        this.parent = parent;
    },

    addChildren: function(datas) {
        if (!datas || datas.length < 1) {
            return;
        }
        for (var i = 0; i < datas.length; i++) {
            var data = datas[i];
            this.addChild(data);
        }
    },

    addChildren: function(child) {
        if (child && !this.children.contains(child)) {
            this.children.add(data); //这个list竟然不去重，
        }
    },

});

var $LinkManager = function(sceneManager) {
    this.sceneManager = sceneManager;
    this.linkMap = null;
};

mono.extend($LinkManager, Object, {

    /**
     *
     * 计算link树，否则找一个完整的链路要遍历所有的links数遍（也就是n遍，n=链路上的节点数，并且查任何链路都是这样，每次也是这么多）
     *
     */
    computeLinkTree: function() {
        this.linkMap = {}; //链路的节点信息，跟链路的对应关系
        var links = this.sceneManager.dataManager.getLinks();
        if (!links || links.length < 1) {
            return;
        }
        for (var i = 0; i < links.length; i++) {
            var link = links[i];
            if (!link) {
                continue;
            }
            var fId = link.getFromId();
            var tId = link.getToId();
            var fTreeData = this.linkMap[fId];
            var tTreeData = this.linkMap[tId];
            if (!fTreeData) {
                fTreeData = new $LNode(fId);
                fTreeData.parent = null;
                this.linkMap[fId] = fTreeData;
            }
            if (!tTreeData) {
                tTreeData = new $LNode(tId);
                tTreeData.toParentLink = link;
                tTreeData.parent = fTreeData;
                this.linkMap[tId] = tTreeData;
            }
             // 处理多个from连到一个to上的情况
            if (!tTreeData.parents.includes(fTreeData)) {
                tTreeData.parents.push(fTreeData);
            }
            tTreeData.toParentLinks.push(link);
        }
    },

    /**
     * 组织父子关系
     */
    setParentAndChildren: function(lNode) {
        if (!lNode) {
            return null;
        }
        var parentId = lNode.parent && lNode.parent.id;
        if (parentId) {
            var parentLNode = this.linkMap[parentId];
            if (parentLNode) {
                parentLNode.addChild(lNode);
            }
        }
        var children = this.getChildren(lNode.id);
        data.addChildren(children);
    },

    getChildren: function(pId) {
        var childArray = [];
        if (!pId) {
            return childArray;
        }
        for (var id in this.linkMap) {
            var lNode = this.linkMap[id];
            if (lNode.parent && lNode.parent.id === pId) {
                childArray.push(lNode);
            }
        }
        return childArray;
    },

    cloneArray : function(array){
        if (!array) {
            return [];
        }
        var newArray = [];
        for(var i = 0 ; i < array.length ; i++){
            newArray.push(array[i]);
        }
        return newArray;
    },

    /**
     * 根据dataId找连到它的所有的连线
     * 注意：1、有环路的情况，免得接下来的地方出现死循环的问题
     *      2、需要考虑多条链路的情况。到了某条节点时可能会存在分列的情况，此时又会分列
     */
    getMulLinksByDataId: function(dataOrId, objs, childLink, scope) {
        scope = scope || this;
        if (!dataOrId || !this.linkMap) {
            return null;
        }
        var dataId = dataOrId;
        if (dataOrId instanceof it.Data) {
            dataId = dataId.getId();
        }
        var lNode = this.linkMap[dataId];
        if (!lNode) {
            return null;
        }
        objs = objs || [];
        if (!childLink) {
           childLink = [];
           objs.push(childLink);
        }
        if (!lNode.toParentLinks || lNode.toParentLinks.length < 1) {
            return null;
        }
        if (lNode.toParentLinks.length > 1) {
            for (var i = 1; i < lNode.toParentLinks.length; i++) { //从1开始哦，第一个继续用来扩展第一个分支
                var newChildLink = scope.cloneArray(childLink);
                var cLink = lNode.toParentLinks[i];
                if(newChildLink.includes(cLink)){ // 避免死循环
                    continue;
                }
                objs.push(newChildLink);
                newChildLink.push(cLink);
                scope.getMulLinksByDataId(cLink.getFromId(), objs, newChildLink, scope);
            }
        }
        var cLink0 = lNode.toParentLinks[0];
        if(childLink.includes(cLink0)){ // 避免死循环
            return objs;
        }
        // 不管有多少个，第0个总是要加进去的，放到最后是因为放到前面copy的会包含不必要的links[0]
        childLink.push(cLink0);
        var parentId = cLink0.getFromId();
        if (parentId) {
            scope.getMulLinksByDataId(parentId, objs, childLink,scope);
        }
        return objs;
    },

    /**
     * 根据dataId找连到它的一根连线
     * 注意：1、有环路的情况，免得接下来的地方出现死循环的问题
     */
    getLinksByDataId: function(dataOrId, scope) {
        scope = scope || this;
        if (!dataOrId || !this.linkMap) {
            return null;
        }
        var dataId = dataOrId;
        if (dataOrId instanceof it.Data) {
            dataId = dataId.getId();
        }
        var lNode = this.linkMap[dataId];
        if (!lNode) {
            return null;
        }
        var result = [];
        if (lNode.toParentLink) {
            result.push(lNode.toParentLink);
        }
        var ancestorLinks = scope.getLinksByDataId(lNode.parent && lNode.parent.id);
        if (ancestorLinks && ancestorLinks.length > 0) {
            for (var i = 0; i < ancestorLinks.length; i++) {
                result.push(ancestorLinks[i]);
            }
        }
        return result;
    },

});
/**
 * 管理Data显示Tooltip的规则
 * sceneId 保留字段，用于多场景呈现的管理，目前先不用。
 */
it.TooltipRule = function(parameters){
	parameters = parameters || {};
	this._id = parameters.id || this.randomId();
    this._customerId = parameters.customerId || ""; //用户扩展
	this._categoryId = parameters.categoryId || "";
	this._dataTypeId = parameters.dataTypeId || "";
    this._sceneId = parameters.sceneId || ""; 
	this._propertiesDesc = parameters.propertiesDesc || "";
	this._extInfo = parameters.extInfo || {};
    this._mul = parameters.mul||false;
    this._withCloseDiv = parameters.withCloseDiv||false;//是否在上面加上一个关闭按钮
};

mono.extend(it.TooltipRule,it.Base,{
    ___accessor:['customerId','categoryId','mul',"dataTypeId","sceneId","propertiesDesc",'extInfo','withCloseDiv'],
    getId : function(){
    	return this._id;
    },

    randomId : function(){
    	return mono.id("tooltipRule");
    },
});
it.TooltipManager = function (sceneManager) {
    this.sceneManager = sceneManager;
    this.dataManager = sceneManager.dataManager;
    this._tooltipRules = [];
    this._tooltipRuleMap = {};
    this._lastData = null;
    this._tooltipDivCreator = new it.TooltipDivCreator();
    this.tooltipContentFunction = null;
    this.toolTipMap = {}; //用于存放“多例”(也就是同时可以显示那些tooltip)
    this.network3d = this.sceneManager.network3d;
    this.box3D = this.network3d.getDataBox();
    this.enableMulforTooltip = false; //如果开启的话，则多例(如：显示所有floors)时是显示的tooltip，默认是flase，配置后字体贴在墙上
    this.textNodeMap = {};
    this.init();
};

mono.extend(it.TooltipManager, it.EventHandler, {

    init: function () {
        var self = this;

        //创建textNode
        this.sceneManager.addSceneManagerChangeListener(function (eve) {
            if (eve.kind == 'add' && (eve.data instanceof mono.Element)) {
                if (self.enableMulforTooltip) {
                    self.createToolTipForNode(eve.data);
                } else {
                    self.createTextNodeForFloor(eve.data);
                }
            }
        });

        //当场景发生变化时，决定哪些TestNode隐藏，哪些显示
        // this.sceneManager.addSceneChangeListener(function (ele) {
        //     self.sceneChangeListener();
        // });
        this.sceneManager.cameraManager.addAfterPlayCameraListener(function (ele) {
            self.sceneChangeListener();
        });

    },
    /**
     * 这块工作后面要交给一个TooltipDivCreator.js来处理，本类应该只处理数据部分，
     * 数据和视图分离，可以实现用户对于样式的定制。
     */
    _createTooltipDiv: function (id) {
        var tooltipDiv = this._tooltipDivCreator.createTooltipDiv(id);
        tooltipDiv.style.position = "absolute";
        tooltipDiv.style.display = "none";
        return tooltipDiv;
    },

    setTooltipDivCreator: function (value) {
        if (value == null) {
            return;
        }
        if (this._tooltipDivCreator !== value) {
            this._tooltipDivCreator = value;
            this.destoryTooltipDiv();
        }
    },

    getTooltipDivCreator: function () {
        return this._tooltipDivCreator;
    },

    destoryTooltipDiv: function () {
        this._tooltipDiv = null;
    },

    getTooltipDiv: function () {
        if (this._tooltipDiv == null) {
            this._tooltipDiv = this._createTooltipDiv();
            var network = this.sceneManager.network3d;
            this._tooltipDivCreator.addToNetwork(network, this._tooltipDiv);
        }
        return this._tooltipDiv;
    },

    hideToolTipDiv: function () {
        var tooltip = this.getTooltipDiv();
        tooltip.style.display = "none";
    },

    showTooltipDiv: function (content, data, node) {
        // this.hideToolTipDiv(); //显示前先隐藏，add by Kevin 2017-06-14
        var tooltip = this.getTooltipDiv();
        tooltip.style.display = "";
        var withCloseDiv = false;
        if (content.tooltipRule && content.tooltipRule.getWithCloseDiv()) {
            withCloseDiv = content.tooltipRule.getWithCloseDiv();
        }
        this._tooltipDivCreator.setTooltipData(content, tooltip);
        if (withCloseDiv) {
            this.addCloseDivForTooltip(tooltip);
        }
        this.computeTooltipDivPosition(data,null, node);
    },

    addCloseDivForTooltip: function(tooltipDiv) {
        if (!tooltipDiv) {
            return;
        }
        var closeDiv = document.createElement('DIV');
        closeDiv.className = 'close';
        closeDiv.style = "float: right;";//position: static;
        var self = this;
        closeDiv.onclick = function(e) {
            tooltipDiv.style.display = "none";
            self._lastData = null;
        }
        tooltipDiv.appendChild(closeDiv);
        return closeDiv;
    },

    onRenderCallback: function (network) {
        this.computeTooltipDivPosition();
        if (this.enableMulforTooltip) {
            this.cameraChangeListener();
        }
    },

    /**
     * 根据node重新计算billboard的位置，像楼层的billboard。也可以给客户扩充用
     * @param node
     * @param x
     * @param y
     * @param z
     * @returns {TGL.Vec3}
     */
    generateTooltipPosition: function (node, x, y, z) {
        if (!node) {
            return new mono.Vec3(x, y, z);
        }
        var data = this.sceneManager.getNodeData(node);
        if (!data) {
            return new mono.Vec3(x, y, z);
        }
        var type = this.dataManager.getDataTypeForData(data);
        var category = this.dataManager.getCategoryForDataType(type);
        var position = node.getPosition();
        if (category && category.getId().indexOf('floor') >= 0) { //如果是楼层的话才这么计算
            if (!data.getPosition()) return new mono.Vec3(x, y, z);
            var dataHeight = data.getPosition().y;
            var parent = this.dataManager.getDataById(data.getParentId());
            if (parent) {
                var children = parent.getChildren();
                if (children && children.size() > 0) {
                    var minY = 0, maxY = 0;
                    children.forEach(function (child) {
                        var y = child.getPosition().y;
                        if (y < minY) {
                            minY = y;
                        }
                        if (y > maxY) {
                            maxY = y;
                        }
                    });
                    if (minY != maxY) {
                        var x1, y1, z1;
                        var bb = node.getBoundingBox();
                        var dz = (bb.max.z - bb.min.z) / 2; //对于floor的billboard往前移
                        z1 = position.z + dz;
                        var width = bb.max.x - bb.min.x;
                        var dw = width / (children.size() + 1);
                        x1 = parseInt((dataHeight - minY) / ((maxY - minY) / children.size())) * dw + dw / 2 - width / 2;
                        // y1 = position.y - 250;
                        y1 = position.y + (bb.max.y + bb.min.y) / 2 + bb.size().y / 2;
                        return new mono.Vec3(x1, y1, z1);
                    }
                }
            }
        }
        return new mono.Vec3(x, y, z);
    },

    computeTooltipDivPosition: function (data, tooltipDiv, targetNode) {
        var tooltip = tooltipDiv || this.getTooltipDiv();
        data = data || this._lastData;
        targetNode = targetNode || this._lastNode;
        if (!tooltip || !data) {
            return;
        }
        var sm = this.sceneManager;
        var node = sm.getNodeForDataOrId(data);
        node = this.getTooltipDivPositionNode(data, node, targetNode);
        var boundingBox = node.getBoundingBox?node.getBoundingBox():null;
        var position = node.getWorldPosition();
        // var x = position.x + boundingBox.center().x, y = position.y + boundingBox.max.y, z = position.z + boundingBox.center().z;
        var x = position.x,y = position.y , z = position.z;
        if (boundingBox) {
            x = x +  boundingBox.center().x;
            y = y +  boundingBox.max.y;
            z = z + boundingBox.center().z;
        };
        var newPos = this.generateTooltipPosition(node, x, y, z);
        if (newPos) {
            x = newPos.x || x;
            y = newPos.y || y;
            z = newPos.z || z;
        }
        var position2d = this.sceneManager.network3d.getViewPosition(new mono.Vec3(x, y, z)),
            offsetLeft = position2d.x,
            offsetTop = position2d.y;
        var style = $Util.getComputedStyle(tooltip);
        // 不应该是绝对于浏览器，若是Network的div有top和left的话就有问题
        offsetLeft = offsetLeft - parseInt(style.width) / 2;
        offsetTop = offsetTop - parseInt(style.height) - 10;

        //获取tooltip内层的包裹元素，并将其设置滚动条
        //如果tip高度大于最大高度300,则设置滚动条
        //获取滚动条宽度
        var scrollBarWidth = getScrollBarWidth();
        var tooltipInnerWrapper = tooltip.children[0];
        if(parseInt(style.height) > 300){
            tooltipInnerWrapper.style.overflowY = 'auto';
            tooltipInnerWrapper.style.height = 300+'px';
            tooltip.style.top = position2d.y - 330 + "px";
            tooltip.style.left = offsetLeft - scrollBarWidth/2 + "px";
        }else{
            tooltip.style.top = offsetTop + "px";
            tooltip.style.left = offsetLeft + "px";
        }
        
        //获取滚动条宽度
        function getScrollBarWidth(){
            var oP = document.createElement('p'),
            styles = {
                width: '100px',
                height: '100px',
            },
            cWidth1,cWidth2,sWidth;
            for(var i in styles){
                oP.style[i] = styles[i]
            };
            document.body.appendChild(oP);
            cWidth1 = oP.clientWidth;
            oP.style.overflowY = 'scroll';
            cWidth2 = oP.clientWidth;
            sWidth = cWidth1 - cWidth2;
            oP.remove();
            return sWidth;
        }

    },

    /**
     * 返回需要显示 tooltip 的 node 节点
     * @param data 选中的 data
     * @param node 选中的 data 对应的 node
     * @param targetNode 鼠标当前指向的 node
     * @returns {*}
     */
    getTooltipDivPositionNode:function(data, node, targetNode){
        // return node||targetNode;
        // update by Kevin 2017-06-14 如果是地球targetNode是billboard，进入园区退回后node是dc的复杂对象
        return targetNode || node;
    },

    getCustomerIdByNode: function (node) { //给用户自己扩展
        return '';
    },

    /**
     * 根据node创建tooltip的内容
     * @param node
     * @param isMul 只判断"多例"（表示同时可以显示多个，每个div只属于其自己的，不共享）的规则
     * @returns {*}
     *
     * 备注：node有可能是临时创建的，如空间可视化时的彩色方块，如果想通过这种配置的方式在这些对象上加上tooltip比较难搞，让用户
     *    重写tooltipContentFunction那还不如让重新写一套，因此这里做一下改进：
     *    在获取data时加了一层getDataFromNode，甚至是一下子直接获取"categoryId"(加上引号是因为可以不是真正的categoryId)，
     *    用户可以重写这个方法，返回的值和注册的id对应上即可
     */
    getTooltipContent: function (node, isMul) {
        if (this.tooltipContentFunction) {
            return this.tooltipContentFunction(node);
        }
        if (!node) {
            return;
        }
        if (node instanceof mono.Billboard && node.getStyle('m.opacity') && node.getStyle('m.opacity') < 0.3) {
            return;
        }
        var customerId = '', categoryId = '', dataTypeId = '';
        if (this.getCustomerIdByNode) {
            customerId = this.getCustomerIdByNode(node);
        }
        var currentScene = this.sceneManager._currentScene;
        var sm = this.sceneManager;
        var dm = this.dataManager;
        var data = sm.getNodeData(node);
        if (data) {
            var category = dm.getCategoryForData(data);
            var dataType = dm.getDataTypeForData(data);
            if (dataType) {
                categoryId = category ? category.getId() : "";
                dataTypeId = dataType.getId();
            }
        }
        var matchCustomer, matchDataType, matchCategory, matchAll, i = 0, tooltipRule;
        for (; i < this._tooltipRules.length; i++) {
            tooltipRule = this._tooltipRules[i];
            if (isMul && !tooltipRule.getMul()) {
                continue;
            }
            if (!isMul && tooltipRule.getMul()) {
                continue;
            }
            if (currentScene 
                && tooltipRule.getSceneId() 
                && currentScene.getId() != tooltipRule.getSceneId()) { // rule上有sceneId，也需要判断的
                continue;
            }
            if (tooltipRule.getCustomerId()
                && tooltipRule.getCustomerId() === customerId && !matchCustomer) {
                matchCustomer = tooltipRule;
            }
            if (tooltipRule.getDataTypeId()
                && tooltipRule.getDataTypeId() === dataTypeId && !matchDataType) {
                matchDataType = tooltipRule;
            }
            if (tooltipRule.getCategoryId()
                && tooltipRule.getCategoryId() === categoryId
                && !matchCategory) {
                matchCategory = tooltipRule;
            }
            if (!tooltipRule.getDataTypeId()
                && !tooltipRule.getCategoryId()
                && !tooltipRule.getCustomerId()) {
                matchAll = tooltipRule;
            }
        }
        if (matchCustomer) {
            return this._getTooltipContent(node, data, matchCustomer);
        } else if (matchDataType) {
            return this._getTooltipContent(node, data, matchDataType);
        } else if (matchCategory) {
            return this._getTooltipContent(node, data, matchCategory);
        } else if (matchAll) {
            return this._getTooltipContent(node, data, matchAll);
        }
    },

    _getDataFieldValue: function (node, data, field) {
        if (!data) {
            return "";
        }
        return data.getValue(field);
    },

    _getTooltipContent: function (node, data, tooltipRule) {
        var result = {};
        var propertiesDesc = tooltipRule.getPropertiesDesc();
        var propertiesDescArray = propertiesDesc.split("@@");
        if (propertiesDescArray.length) {
            for (var i = 0; i < propertiesDescArray.length; i++) {
                var propertyDesc = propertiesDescArray[i];
                var propertyDescArray = propertyDesc.split(":");
                if (propertyDescArray.length === 2) {
                    var label = propertyDescArray[0];
                    var field = propertyDescArray[1];
                    var value = this._getDataFieldValue(node, data, field);
                    result[label] = value || '';
                }
            }
        }
        var extInfo = tooltipRule.getExtInfo();
        if (typeof(extInfo) == 'function') {
            extInfo = extInfo(node, data);
        } else {
            extInfo = $Util.translateJson(extInfo);
        }
        if (extInfo instanceof Array) {
            // 其实这个array中的col也可能是个function
            extInfo.tooltipRule = tooltipRule;
            return extInfo;
        }else{
            if (extInfo) {
            for (var p in extInfo) {
                var info = extInfo[p];
                if (typeof(info) == 'function') {
                    result[p] = info(node, data);
                } else {
                    result[p] = info;
                }
            }
           }
           result.tooltipRule = tooltipRule;
           return result;
        }
    },

    addTooltipRule: function (tooltipRule) {
        var id = tooltipRule.getId();
        if (!this._tooltipRuleMap[id]) {
            this._tooltipRules.push(tooltipRule);
            this._tooltipRuleMap[id] = tooltipRule;
        }
    },

    removeTooltipRule: function (tooltipRule) {
        var id = tooltipRule.getId();
        if (this._tooltipRuleMap[id]) {
            var index = this._tooltipRules.indexOf(tooltipRule);
            if (index) {
                this._tooltipRules.splice(index, 1);
            }
            delete this._tooltipRuleMap[id];
        }
    },

    handleMouseMoveElement: function (node, network, data, element, event) {
        if (event._mousedown) {
            return;
        }
        var content = this.getTooltipContent(node);
        if (content == null) {
            this._lastData = null;
            this._lastNode = node;
            this.hideToolTipDiv();
            return;
        }
        var self = this;
        if (this._lastNode == node) {
            return;
        } else {
            clearTimeout(this._tooltipTimer);
            self._lastData = data;
            self._lastNode = node;
            this._tooltipTimer = setTimeout(function () {
               // self._lastData = data;
                self.showTooltipDiv(content, data, node);
            }, 200); //TODO 500 改成可以配置
        }
    },

    handleMouseMoveBackground: function (network, event) {
        this.hideToolTipDiv();
        this._lastData = null;
    },

    /**
     * 清除多例的tooltip
     */
    clearToolTipMap: function () {
        if (!this.toolTipMap) {
            return;
        }
        for (var id in this.toolTipMap) {
            var toolObj = this.toolTipMap[id];
            if (!toolObj) {
                continue;
            }
            $('#' + toolObj.id).remove();
        }
    },

    /**
     * 根据Element创建一个新的Tooltip，该tooltip不是单例，它只归element所有
     * 注意：由于该tip和Element绑定，所以element的显示隐藏也应该对改tip做处理
     * @param element
     */
    createToolTipForNode: function (element) {
        if (!element) {
            return;
        }
        var data = null;
        if (element instanceof it.Data) {
            data = element;
        } else {
            data = this.sceneManager.getNodeData(element);
        }
        if (!data) {
            return;
        }
        var content = this.getTooltipContent(element, true);
        if (!content) {
            return;
        }
        var id = "tooltip" + data.getId();
        var tipPane = null;
        if (this.toolTipMap[data.getId()]) {
            tipPane = document.getElementById(id);
        }else{
            this.toolTipMap[data.getId()] = {id: id, rule: content.tooltipRule,element:element};
            tipPane = this._createTooltipDiv(id);
            this._tooltipDivCreator.addToNetwork(this.sceneManager.network3d, tipPane);
        }
        if (tipPane) {
            tipPane.style.display = "block";
            var withCloseDiv = false;
            if (content.tooltipRule) { //setTooltipData 可能会将content的rule给删掉
                withCloseDiv = content.tooltipRule.getWithCloseDiv();
            }
            this._tooltipDivCreator.setTooltipData(content, tipPane);
            if (withCloseDiv) {
                this.addCloseDivForTooltip(tooltip);
            }
            this.computeTooltipDivPosition(data, tipPane);
        }
    },

    //对于楼层来讲创建div的tooltip的效果不是很好
    cameraChangeListener: function () {
        if (!this.toolTipMap) {
            return;
        }
        for (var id in this.toolTipMap) {
            var toolObj = this.toolTipMap[id];
            var element = toolObj.element;
            if (!toolObj) {
                continue;
            }
            var tooltipId = toolObj.id;
            var rule = toolObj.rule;
            if (tooltipId.startsWith('tooltip')) {
                var id = tooltipId.substring(7, tooltipId.length);
                var data = this.dataManager.getDataById(id);
                var node = this.sceneManager.getNodeByDataOrId(data);
                if (!data || !node) {
                    continue;
                }
                var tipPane = document.getElementById(tooltipId);
                if (!tipPane) {
                    continue;
                }
                var currentScene = this.sceneManager.getCurrentScene();
                if (rule.getSceneId()
                    && currentScene
                    && rule.getSceneId() != currentScene.getId()) {
                    tipPane.style.display = "none";
                    continue;
                }
                // 判断是否可见，这样(node.isVisible())不太准确，因为存在许多的visibleFilter，所以的判断每个visibleFilter,
                // 得在viewManager中封装一把
                if (!node
//                    || !node.isVisible()
                    || !this.sceneManager.viewManager3d.isVisible(node)
                    || !this.box3D.getDataById(node.getId())) { //当node不可见时，其对应的tooltip也要隐藏掉
                    tipPane.style.display = "none";
                    continue;
                }
                tipPane.style.display = "";
                if (element) {
                    var content = this.getTooltipContent(element, true);
                    if (content) {
                        var withCloseDiv = rule.getWithCloseDiv();
                        this._tooltipDivCreator.setTooltipData(content, tipPane);
                        if (withCloseDiv) {
                            this.addCloseDivForTooltip(tooltip);
                        }
                    }
                }
                this.computeTooltipDivPosition(data, tipPane);
            }
        }
    },

    getRuleByData : function(dataOrId,isMul){
        if (!dataOrId) {
            return;
        }
        var sm = this.sceneManager;
        var dm = this.dataManager;
        var data = null;
        if(dataOrId instanceof it.Data){
            data = dataOrId
        }else if(dataOrId instanceof it.Link){
            data = dataOrId
        }else {
            data = dm.getDataById(dataOrId);
        }
        if (!data) {
            return;
        }
        var category = dm.getCategoryForData(data);
        var dataType = dm.getDataTypeForData(data);
        if (dataType == null) {
            return;
        }
        var categoryId = category ? category.getId() : "";
        var dataTypeId = dataType.getId();
        var matchDataType, matchCategory, matchAll, i = 0, tooltipRule;
        for (; i < this._tooltipRules.length; i++) {
            tooltipRule = this._tooltipRules[i];
            if (isMul && !tooltipRule.getMul()) {
                continue;
            }
            if (!isMul && tooltipRule.getMul()) {
                continue;
            }
            if (tooltipRule.getDataTypeId() === dataTypeId && !matchDataType) {
                matchDataType = tooltipRule
            }
            if (categoryId && tooltipRule.getCategoryId() === categoryId && !matchCategory) {
                matchCategory = tooltipRule;
            }
            if (!tooltipRule.getDataTypeId() && !tooltipRule.getCategoryId()) {
                matchAll = tooltipRule;
            }
        }
        if (matchDataType) {
            return matchDataType;
        } else if (matchCategory) {
            return matchCategory;
        } else if (matchAll) {
            return matchAll;
        }
        return null;
    },

    computeTextNodePosition : function(node,fontLength){
        if(!node){
            return null;
        }
        var data = this.sceneManager.getNodeData(node);
        this.sceneManager.setParentRelationShip(data); // 因为派发_sceneManagerChangeDispatcher时并没有设置其位置等信息
        this.sceneManager.translatePosition(data);
        var fontLength = fontLength || 0;
        var boundingBox = node.getBoundingBox();
        var nodeWorldPos = it.Util.getNodeCenterPosition(node);
        var x = nodeWorldPos.x;
        var y = nodeWorldPos.y;
        var z = nodeWorldPos.z;

        if(boundingBox){
            x = x + (boundingBox.max.x-boundingBox.min.x)/2 - fontLength;
            z = z + (boundingBox.max.z -boundingBox.min.z)/2+5;
        }
        var height = boundingBox.max.y - boundingBox.min.y;
        y = height/2;

        var pz = z+50; //先加上50，以免z已经贴到了墙上
        //这里面的x,y,z不能是相对的(如果对象的中心点不是放在世界坐标的中心的话)，应该要弄成绝对的位置
        var obj = this.getElementsByPosition(x,y,pz);
        if(obj && obj.length > 0){
            var minDis = null;
            for (var i = 0; i < obj.length; i++) {
                var ele = obj[i];
                if (ele
//                    && this.sceneManager.getNodeData(ele) == data //应该还要判断node的data==ele的data
                    && ele.distance) {
                    if (!minDis || minDis > ele.distance) {
                        minDis = ele.distance;
                    }
                }
            }
            if (minDis) {
                z = pz - minDis;
            }
        }
        return {x: x, y: y, z: z};

    },

    // 若是该点在某物体内部最终判断的结果也是没有相交(1会出现这个问题),如果采用direction.sub(origin)减了一把后此问题就不存在了
    getElementsByPosition: function (x, y, z) {
        var origin = new mono.Vec3(x, y, z);
        var up = new mono.Vec3(0, 1, 0);
        var direction = new mono.Vec3(x, y, -1);
        var camera = this.network3d.getCamera();
//            var picking = new mono.Picking(origin,direction.normalize(), up);// 1.it is ok if origin is (0,0,0)
        var picking = new mono.Picking(origin, direction.sub(origin).normalize(), up, camera.getNear(), camera.getFar(), this.network3d);
        var intersects = new mono.List();
        intersects.addAll(this.box3D.getNodes());
//        intersects.addAll(network3d.getDataBox().getBillboards());
        var elements = picking.intersectObjects(intersects.toArray(), true, false);
        return elements;
    },


    /**
     * textNode的偏移量
     * @param node
     * @returns {null}
     */
    getTextNodeOffset: function (node) {
        return null;
    },

    /**
     * 给楼层创建label
     * @param element
     */
    createTextNodeForFloor: function (element) {
        if (!element) {
            return;
        }
        var data = null;
        if (element instanceof it.Data) {
            data = element;
        } else {
            data = this.sceneManager.getNodeData(element);
        }
        if (!data) {
            return;
        }
        var category = this.sceneManager.dataManager.getCategoryForData(data);
        if (!category || category.getId().toLowerCase().indexOf('floor') < 0) {
            return;
        }
        var rule = this.getRuleByData(data, true);
        if (!rule) {
            return;
        }
        var label = data.getId();
        var textNode = this.textNodeMap[label];
        if (!textNode) {
            if (label) {
                var textNode = new mono.TextNode(label, null, 100, 'helvetiker', 'bold');
                textNode.setStyle('m.texture.image', '../images/yellow.png');
                textNode.setStyle('m.type', 'phong');
                var scale = 1;
                textNode.setScale(scale, scale, scale * 0.1);
                textNode.setSelectable(false);
                textNode.setParent(element);
                var boundingBox = element.getBoundingBox();
                var x = element.getPositionX();
                var z = element.getPositionZ();
                var y = element.getPositionY();
                var fontLength = 0;
                var fontHeight = 0;
                var tnBoundingBox = textNode.getBoundingBox();
                if (tnBoundingBox) {
                    fontLength = tnBoundingBox.max.x - tnBoundingBox.min.x;
                    fontHeight = tnBoundingBox.max.y - tnBoundingBox.min.y;
                }
//                var txtPos = this.computeTextNodePosition(element,fontLength);
                if (boundingBox) {
                    x = boundingBox.max.x - fontLength;
//                    z = boundingBox.max.z+10;
                    z = boundingBox.max.z + 5;
                }
                var height = boundingBox.max.y - boundingBox.min.y;
//                if(fontHeight){
//                    y = height+fontHeight-30;
//                }
                y = height / 2;

                var offset = this.getTextNodeOffset(data);
                if (offset) {
                    if (offset.x) {
                        x = x + offset.x;
                    }
                    if (offset.y) {
                        y = y + offset.y;
                    }
                }

                var pz = z + 50; //先加上50，以免z已经贴到了墙上
                //这里面的x,y,z不能是相对的(如果对象的中心点不是放在世界坐标的中心的话)，应该要弄成绝对的位置
                var obj = this.getElementsByPosition(x, y, pz);
                if (obj && obj.length > 0) {
                    var minDis = null;
                    for (var i = 0; i < obj.length; i++) {
                        var ele = obj[i];
                        if (ele && ele.distance) {
                            if (!minDis || minDis > ele.distance) {
                                minDis = ele.distance;
                            }
                        }
                    }
                    if (minDis) {
                        z = pz - minDis;
                    }
                }

                if (offset && offset.z) {
                    if (offset.z) {
                        z = z + offset.z;
                    }
                }

                textNode.setPosition(x, y, z);
                this.textNodeMap[label] = textNode;
                textNode.setVisible(false);
                this.box3D.add(textNode);
                textNode.rule = rule;
            }
        }
    },

    sceneChangeListener: function () {
        if (this.textNodeMap) {
            for (var id in this.textNodeMap) {
                var textNode = this.textNodeMap[id];
                //在什么场景下才显示出来呢？也通过rule来控制，可是显示的内容也通过配置方式么，不过至少是否显示，并显示在哪里可以这么来控制
                var rule = textNode.rule;
                var currentScene = this.sceneManager.getCurrentScene();
                if (rule.getSceneId()
                    && currentScene
                    && rule.getSceneId() != currentScene.getId()) {
                    textNode.setVisible(false);
                    continue;
                }
                var node = this.sceneManager.getNodeByDataOrId(id);
                if (!node
//                    || !node.isVisible()
                    || !this.sceneManager.viewManager3d.isVisible(node)
                    || !this.box3D.getDataById(node.getId())) { //当node不可见时，其对应的tooltip也要隐藏掉
                    textNode.setVisible(false);
                    continue;
                }
                if (!this.box3D.getDataById(textNode.getId())) {
                    this.box3D.add(textNode);
                }
                textNode.setVisible(true);
            }
        }

        //切换场景时，先要要将之前场景中的tooltip隐藏掉。有个问题，tooltip的显示也是有延时的，有可能scene已经Change了，但是tooltip还没有显示出来
        if (this._tooltipTimer) {
            clearTimeout(this._tooltipTimer);
        }
        this.hideToolTipDiv();
    }


});
/**
 * 创建TooltipDiv的类,本类需要引用tooltip.css.
 */
it.TooltipDivCreator = function (argument) {
};

mono.extend(it.TooltipDivCreator, Object, {
    createTooltipDiv: function (id) {
        var tooltipDiv = document.createElement('DIV');
        tooltipDiv.className = "tooltip-panel";
        if (id) {
            tooltipDiv.id = id;
        }
        return tooltipDiv
    },

    addToNetwork: function (network, tooltipDiv) {
        network.getRootView().appendChild(tooltipDiv);
    },

    setTooltipData: function(content, tooltipDiv) {

        //清除tootip的默认style行间样式
        tooltipDiv.style = '';

        this._removeAllChildren(tooltipDiv);
        if (!content) return;
        delete content.tooltipRule;

        //创建一个tableWrapper，并将该div设置滚动条
        var tableWrapper = document.createElement('div');
        tooltipDiv.appendChild(tableWrapper);

        var table = document.createElement('table');
        var tbody = document.createElement('tbody');
        tableWrapper.appendChild(table);
        table.appendChild(tbody);
        if (content instanceof Array) { //以表格的方式显示
            var headerList = content.header;
            if (headerList) {
                var headerRow = this._createTableRow(headerList,true);
                tbody.appendChild(headerRow);
            }
            for(var i = 0 ; i < content.length ; i++){
                var rowData = content[i];
                var row = this._createTableRow(rowData);
                tbody.appendChild(row);
            }
        } else {
            for (var p in content) {
                if (typeof content[p] == 'object') {
                    var v = content[p].value;
                    var onclick = content[p].onclick;
                    var row = this._createRow(p, v, onclick);
                    tbody.appendChild(row);
                } else {
                    var row = this._createRow(p, content[p]);
                    tbody.appendChild(row);
                }
            }
        }
    },

    _createTableRow : function(rowData,isHeader){
        var row = document.createElement('tr');
        if (rowData instanceof Array) {
            for(var i = 0 ; i < rowData.length ; i++){
                var data = rowData[i];
                var col = this._createColumn(data,isHeader);
                row.appendChild(col);
            }
        }else {
            for(var p in rowData){
                var data = rowData[p];
                var col = this._createColumn(data,isHeader);
                row.appendChild(col);
            }
        }
        return row;
    },

    _createColumn : function(data,isHeader){
        var column = document.createElement('td');
        if (isHeader) {
            // column.className = "tooltip-key";
            column.style = "width: 60px;text-align:center;";
        }else{
            column.className = "tooltip-value";
            column.style = "text-align:center;";
        }
        if (data.className) {
            column.className = data.className;
        }
        if (data.style) {
            column.style = data.style;
        }
        var text = data;
        if (data.hasOwnProperty('value')) {
            text = data.value;
        }else if(data.hasOwnProperty('text')){
            text = data.text;
        }
        if (data.onclick) {
            column.onclick = data.onclick;
        }
        column.innerHTML = text;
        return column;
    },

    _createRow: function (key, value, onclick) {
        var row = document.createElement('tr');
        var columnKey = document.createElement('td');
        columnKey.className = "tooltip-key";
        columnKey.innerHTML = key + ":";
        var columnValue = document.createElement('td');
        var cn = "tooltip-value";
        if(onclick){
            cn += ' tooltip-value-btn'
        }
        columnValue.className = cn;
        columnValue.innerHTML = value;
        row.appendChild(columnKey);
        row.appendChild(columnValue);
        columnValue.onclick = onclick;
        return row;
    },

    _removeAllChildren: function (node) {
        while (node.hasChildNodes()) {
            node.removeChild(node.lastChild);
        }
    },
});

(function(window){
    var Framebuffer, Heights, Node, Shader, Texture, WebGLHeatmap, fragmentShaderBlit, nukeVendorPrefix, textureFloatShims, vertexShaderBlit,
        __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };

    nukeVendorPrefix = function () {
        var getExtension, getSupportedExtensions, vendorRe, vendors;
        if (window.WebGLRenderingContext != null) {
            vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];
            vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj, match, vendor, _i, _len;
                match = name.match(vendorRe);
                if (match !== null) {
                    name = match[1];
                }
                extobj = getExtension.call(this, name);
                if (extobj === null) {
                    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
                        vendor = vendors[_i];
                        extobj = getExtension.call(this, vendor + '_' + name);
                        if (extobj !== null) {
                            return extobj;
                        }
                    }
                    return null;
                } else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            return WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, match, result, supported, _i, _len;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_i = 0, _len = supported.length; _i < _len; _i++) {
                    extension = supported[_i];
                    match = extension.match(vendorRe);
                    if (match !== null) {
                        extension = match[1];
                    }
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
        }
    };

    textureFloatShims = function () {
        var checkColorBuffer, checkFloatLinear, checkSupport, checkTexture, createSourceCanvas, getExtension, getSupportedExtensions, name, shimExtensions, shimLookup, unshimExtensions, unshimLookup, _i, _len;
        createSourceCanvas = function () {
            var canvas, ctx, imageData;
            canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            ctx = canvas.getContext('2d');
            imageData = ctx.getImageData(0, 0, 2, 2);
            imageData.data.set(new Uint8ClampedArray([0, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]));
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };
        createSourceCanvas();
        checkFloatLinear = function (gl, sourceType) {
            var buffer, cleanup, fragmentShader, framebuffer, positionLoc, program, readBuffer, result, source, sourceCanvas, sourceLoc, target, vertexShader, vertices;
            program = gl.createProgram();
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.attachShader(program, vertexShader);
            gl.shaderSource(vertexShader, 'attribute vec2 position;\nvoid main(){\n    gl_Position = vec4(position, 0.0, 1.0);\n}');
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(vertexShader);
            }
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.attachShader(program, fragmentShader);
            gl.shaderSource(fragmentShader, 'uniform sampler2D source;\nvoid main(){\n    gl_FragColor = texture2D(source, vec2(1.0, 1.0));\n}');
            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw gl.getShaderInfoLog(fragmentShader);
            }
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw gl.getProgramInfoLog(program);
            }
            gl.useProgram(program);
            cleanup = function () {
                gl.deleteShader(fragmentShader);
                gl.deleteShader(vertexShader);
                gl.deleteProgram(program);
                gl.deleteBuffer(buffer);
                gl.deleteTexture(source);
                gl.deleteTexture(target);
                gl.deleteFramebuffer(framebuffer);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            };
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            sourceCanvas = createSourceCanvas();
            source = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, source);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, sourceType, sourceCanvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            positionLoc = gl.getAttribLocation(program, 'position');
            sourceLoc = gl.getUniformLocation(program, 'source');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform1i(sourceLoc, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            readBuffer = new Uint8Array(4 * 4);
            gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, readBuffer);
            result = Math.abs(readBuffer[0] - 127) < 10;
            cleanup();
            return result;
        };
        checkTexture = function (gl, targetType) {
            var target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            if (gl.getError() === 0) {
                gl.deleteTexture(target);
                return true;
            } else {
                gl.deleteTexture(target);
                return false;
            }
        };
        checkColorBuffer = function (gl, targetType) {
            var check, framebuffer, target;
            target = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, target);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, targetType, null);
            framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, target, 0);
            check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            gl.deleteTexture(target);
            gl.deleteFramebuffer(framebuffer);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            if (check === gl.FRAMEBUFFER_COMPLETE) {
                return true;
            } else {
                return false;
            }
        };
        shimExtensions = [];
        shimLookup = {};
        unshimExtensions = [];
        checkSupport = function () {
            var canvas, extobj, gl, halfFloatExt, halfFloatTexturing, singleFloatExt, singleFloatTexturing;
            canvas = document.createElement('canvas');
            gl = null;
            try {
                gl = canvas.getContext('experimental-webgl');
                if (gl === null) {
                    gl = canvas.getContext('webgl');
                }
            } catch (_error) {
            }
            if (gl != null) {
                singleFloatExt = gl.getExtension('OES_texture_float');
                if (singleFloatExt === null) {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                        shimLookup.OES_texture_float = {
                            shim: true
                        };
                    } else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                } else {
                    if (checkTexture(gl, gl.FLOAT)) {
                        singleFloatTexturing = true;
                        shimExtensions.push('OES_texture_float');
                    } else {
                        singleFloatTexturing = false;
                        unshimExtensions.push('OES_texture_float');
                    }
                }
                if (singleFloatTexturing) {
                    extobj = gl.getExtension('WEBGL_color_buffer_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                            shimLookup.WEBGL_color_buffer_float = {
                                shim: true,
                                RGBA32F_EXT: 0x8814,
                                RGB32F_EXT: 0x8815,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        } else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    } else {
                        if (checkColorBuffer(gl, gl.FLOAT)) {
                            shimExtensions.push('WEBGL_color_buffer_float');
                        } else {
                            unshimExtensions.push('WEBGL_color_buffer_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                            shimLookup.OES_texture_float_linear = {
                                shim: true
                            };
                        } else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    } else {
                        if (checkFloatLinear(gl, gl.FLOAT)) {
                            shimExtensions.push('OES_texture_float_linear');
                        } else {
                            unshimExtensions.push('OES_texture_float_linear');
                        }
                    }
                }
                halfFloatExt = gl.getExtension('OES_texture_half_float');
                if (halfFloatExt === null) {
                    if (checkTexture(gl, 0x8D61)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                        halfFloatExt = shimLookup.OES_texture_half_float = {
                            HALF_FLOAT_OES: 0x8D61,
                            shim: true
                        };
                    } else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                } else {
                    if (checkTexture(gl, halfFloatExt.HALF_FLOAT_OES)) {
                        halfFloatTexturing = true;
                        shimExtensions.push('OES_texture_half_float');
                    } else {
                        halfFloatTexturing = false;
                        unshimExtensions.push('OES_texture_half_float');
                    }
                }
                if (halfFloatTexturing) {
                    extobj = gl.getExtension('EXT_color_buffer_half_float');
                    if (extobj === null) {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                            shimLookup.EXT_color_buffer_half_float = {
                                shim: true,
                                RGBA16F_EXT: 0x881A,
                                RGB16F_EXT: 0x881B,
                                FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
                                UNSIGNED_NORMALIZED_EXT: 0x8C17
                            };
                        } else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    } else {
                        if (checkColorBuffer(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('EXT_color_buffer_half_float');
                        } else {
                            unshimExtensions.push('EXT_color_buffer_half_float');
                        }
                    }
                    extobj = gl.getExtension('OES_texture_half_float_linear');
                    if (extobj === null) {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            shimExtensions.push('OES_texture_half_float_linear');
                            return shimLookup.OES_texture_half_float_linear = {
                                shim: true
                            };
                        } else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    } else {
                        if (checkFloatLinear(gl, halfFloatExt.HALF_FLOAT_OES)) {
                            return shimExtensions.push('OES_texture_half_float_linear');
                        } else {
                            return unshimExtensions.push('OES_texture_half_float_linear');
                        }
                    }
                }
            }
        };
        if (window.WebGLRenderingContext != null) {
            checkSupport();
            unshimLookup = {};
            for (_i = 0, _len = unshimExtensions.length; _i < _len; _i++) {
                name = unshimExtensions[_i];
                unshimLookup[name] = true;
            }
            getExtension = WebGLRenderingContext.prototype.getExtension;
            WebGLRenderingContext.prototype.getExtension = function (name) {
                var extobj;
                extobj = shimLookup[name];
                if (extobj === void 0) {
                    if (unshimLookup[name]) {
                        return null;
                    } else {
                        return getExtension.call(this, name);
                    }
                } else {
                    return extobj;
                }
            };
            getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;
            WebGLRenderingContext.prototype.getSupportedExtensions = function () {
                var extension, result, supported, _j, _k, _len1, _len2;
                supported = getSupportedExtensions.call(this);
                result = [];
                for (_j = 0, _len1 = supported.length; _j < _len1; _j++) {
                    extension = supported[_j];
                    if (unshimLookup[extension] === void 0) {
                        result.push(extension);
                    }
                }
                for (_k = 0, _len2 = shimExtensions.length; _k < _len2; _k++) {
                    extension = shimExtensions[_k];
                    if (__indexOf.call(result, extension) < 0) {
                        result.push(extension);
                    }
                }
                return result;
            };
            return WebGLRenderingContext.prototype.getFloatExtension = function (spec) {
                var candidate, candidates, half, halfFramebuffer, halfLinear, halfTexture, i, importance, preference, result, single, singleFramebuffer, singleLinear, singleTexture, use, _j, _k, _l, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
                if (spec.prefer == null) {
                    spec.prefer = ['half'];
                }
                if (spec.require == null) {
                    spec.require = [];
                }
                if (spec.throws == null) {
                    spec.throws = true;
                }
                singleTexture = this.getExtension('OES_texture_float');
                halfTexture = this.getExtension('OES_texture_half_float');
                singleFramebuffer = this.getExtension('WEBGL_color_buffer_float');
                halfFramebuffer = this.getExtension('EXT_color_buffer_half_float');
                singleLinear = this.getExtension('OES_texture_float_linear');
                halfLinear = this.getExtension('OES_texture_half_float_linear');
                single = {
                    texture: singleTexture !== null,
                    filterable: singleLinear !== null,
                    renderable: singleFramebuffer !== null,
                    score: 0,
                    precision: 'single',
                    half: false,
                    single: true,
                    type: this.FLOAT
                };
                half = {
                    texture: halfTexture !== null,
                    filterable: halfLinear !== null,
                    renderable: halfFramebuffer !== null,
                    score: 0,
                    precision: 'half',
                    half: true,
                    single: false,
                    type: (_ref = halfTexture != null ? halfTexture.HALF_FLOAT_OES : void 0) != null ? _ref : null
                };
                candidates = [];
                if (single.texture) {
                    candidates.push(single);
                }
                if (half.texture) {
                    candidates.push(half);
                }
                result = [];
                for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
                    candidate = candidates[_j];
                    use = true;
                    _ref1 = spec.require;
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                        name = _ref1[_k];
                        if (candidate[name] === false) {
                            use = false;
                        }
                    }
                    if (use) {
                        result.push(candidate);
                    }
                }
                for (_l = 0, _len3 = result.length; _l < _len3; _l++) {
                    candidate = result[_l];
                    _ref2 = spec.prefer;
                    for (i = _m = 0, _len4 = _ref2.length; _m < _len4; i = ++_m) {
                        preference = _ref2[i];
                        importance = Math.pow(2, spec.prefer.length - i - 1);
                        if (candidate[preference]) {
                            candidate.score += importance;
                        }
                    }
                }
                result.sort(function (a, b) {
                    if (a.score === b.score) {
                        return 0;
                    } else if (a.score < b.score) {
                        return 1;
                    } else if (a.score > b.score) {
                        return -1;
                    }
                });
                if (result.length === 0) {
                    if (spec.throws) {
                        throw 'No floating point texture support that is ' + spec.require.join(', ');
                    } else {
                        return null;
                    }
                } else {
                    result = result[0];
                    return {
                        filterable: result.filterable,
                        renderable: result.renderable,
                        type: result.type,
                        precision: result.precision
                    };
                }
            };
        }
    };

    nukeVendorPrefix();

    textureFloatShims();

    Shader = (function () {
        function Shader(gl, _arg) {
            var fragment, vertex;
            this.gl = gl;
            vertex = _arg.vertex, fragment = _arg.fragment;
            this.program = this.gl.createProgram();
            this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);
            this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
            this.gl.attachShader(this.program, this.vs);
            this.gl.attachShader(this.program, this.fs);
            this.compileShader(this.vs, vertex);
            this.compileShader(this.fs, fragment);
            this.link();
            this.value_cache = {};
            this.uniform_cache = {};
            this.attribCache = {};
        }

        Shader.prototype.attribLocation = function (name) {
            var location;
            location = this.attribCache[name];
            if (location === void 0) {
                location = this.attribCache[name] = this.gl.getAttribLocation(this.program, name);
            }
            return location;
        };

        Shader.prototype.compileShader = function (shader, source) {
            this.gl.shaderSource(shader, source);
            this.gl.compileShader(shader);
            if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                throw "Shader Compile Error: " + (this.gl.getShaderInfoLog(shader));
            }
        };

        Shader.prototype.link = function () {
            this.gl.linkProgram(this.program);
            if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
                throw "Shader Link Error: " + (this.gl.getProgramInfoLog(this.program));
            }
        };

        Shader.prototype.use = function () {
            this.gl.useProgram(this.program);
            return this;
        };

        Shader.prototype.uniformLoc = function (name) {
            var location;
            location = this.uniform_cache[name];
            if (location === void 0) {
                location = this.uniform_cache[name] = this.gl.getUniformLocation(this.program, name);
            }
            return location;
        };

        Shader.prototype.int = function (name, value) {
            var cached, loc;
            cached = this.value_cache[name];
            if (cached !== value) {
                this.value_cache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1i(loc, value);
                }
            }
            return this;
        };

        Shader.prototype.vec2 = function (name, a, b) {
            var loc;
            loc = this.uniformLoc(name);
            if (loc) {
                this.gl.uniform2f(loc, a, b);
            }
            return this;
        };

        Shader.prototype.float = function (name, value) {
            var cached, loc;
            cached = this.value_cache[name];
            if (cached !== value) {
                this.value_cache[name] = value;
                loc = this.uniformLoc(name);
                if (loc) {
                    this.gl.uniform1f(loc, value);
                }
            }
            return this;
        };

        return Shader;

    })();

    Framebuffer = (function () {
        function Framebuffer(gl) {
            this.gl = gl;
            this.buffer = this.gl.createFramebuffer();
        }

        Framebuffer.prototype.destroy = function () {
            return this.gl.deleteFRamebuffer(this.buffer);
        };

        Framebuffer.prototype.bind = function () {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);
            return this;
        };

        Framebuffer.prototype.unbind = function () {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
            return this;
        };

        Framebuffer.prototype.check = function () {
            var result;
            result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);
            switch (result) {
                case this.gl.FRAMEBUFFER_UNSUPPORTED:
                    throw 'Framebuffer is unsupported';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    throw 'Framebuffer incomplete attachment';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    throw 'Framebuffer incomplete dimensions';
                    break;
                case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    throw 'Framebuffer incomplete missing attachment';
            }
            return this;
        };

        Framebuffer.prototype.color = function (texture) {
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, texture.target, texture.handle, 0);
            this.check();
            return this;
        };

        Framebuffer.prototype.depth = function (buffer) {
            this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, buffer.id);
            this.check();
            return this;
        };

        Framebuffer.prototype.destroy = function () {
            return this.gl.deleteFramebuffer(this.buffer);
        };

        return Framebuffer;

    })();

    Texture = (function () {
        function Texture(gl, params) {
            var _ref, _ref1;
            this.gl = gl;
            if (params == null) {
                params = {};
            }
            this.channels = this.gl[((_ref = params.channels) != null ? _ref : 'rgba').toUpperCase()];
            if (typeof params.type === 'number') {
                this.type = params.type;
            } else {
                this.type = this.gl[((_ref1 = params.type) != null ? _ref1 : 'unsigned_byte').toUpperCase()];
            }
            switch (this.channels) {
                case this.gl.RGBA:
                    this.chancount = 4;
                    break;
                case this.gl.RGB:
                    this.chancount = 3;
                    break;
                case this.gl.LUMINANCE_ALPHA:
                    this.chancount = 2;
                    break;
                default:
                    this.chancount = 1;
            }
            this.target = this.gl.TEXTURE_2D;
            this.handle = this.gl.createTexture();
        }

        Texture.prototype.destroy = function () {
            return this.gl.deleteTexture(this.handle);
        };

        Texture.prototype.bind = function (unit) {
            if (unit == null) {
                unit = 0;
            }
            if (unit > 15) {
                throw 'Texture unit too large: ' + unit;
            }
            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
            this.gl.bindTexture(this.target, this.handle);
            return this;
        };

        Texture.prototype.setSize = function (width, height) {
            this.width = width;
            this.height = height;
            this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);
            return this;
        };

        Texture.prototype.upload = function (data) {
            this.width = data.width;
            this.height = data.height;
            this.gl.texImage2D(this.target, 0, this.channels, this.channels, this.type, data);
            return this;
        };

        Texture.prototype.linear = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
            return this;
        };

        Texture.prototype.nearest = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
            return this;
        };

        Texture.prototype.clampToEdge = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
            return this;
        };

        Texture.prototype.repeat = function () {
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
            return this;
        };

        return Texture;

    })();

    Node = (function () {
        function Node(gl, width, height) {
            var floatExt;
            this.gl = gl;
            this.width = width;
            this.height = height;
            floatExt = this.gl.getFloatExtension({
                require: ['renderable']
            });
            this.texture = new Texture(this.gl, {
                type: floatExt.type
            }).bind(0).setSize(this.width, this.height).nearest().clampToEdge();
            this.fbo = new Framebuffer(this.gl).bind().color(this.texture).unbind();
        }

        Node.prototype.use = function () {
            return this.fbo.bind();
        };

        Node.prototype.bind = function (unit) {
            return this.texture.bind(unit);
        };

        Node.prototype.end = function () {
            return this.fbo.unbind();
        };

        Node.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            return this.texture.bind(0).setSize(this.width, this.height);
        };

        return Node;

    })();

    vertexShaderBlit = 'attribute vec4 position;\n' +
        'varying vec2 texcoord;\n' +
        'void main(){\n' +
        '    texcoord = position.xy*0.5+0.5;\n' +
        '    gl_Position = position;\n' +
        '}';

    fragmentShaderBlit = '#ifdef GL_FRAGMENT_PRECISION_HIGH\n    ' +
        '  precision highp int;\n' +
        '    precision highp float;\n' +
        '#else\n' +
        '    precision mediump int;\n' +
        '    precision mediump float;\n' +
        '#endif\n' +
        'uniform sampler2D source;\n' +
        'varying vec2 texcoord;';

    Heights = (function () {
        function Heights(heatmap, gl, width, height) {
            var i, _i, _ref;
            this.heatmap = heatmap;
            this.gl = gl;
            this.width = width;
            this.height = height;
            this.shader = new Shader(this.gl, {
                vertex: 'attribute vec4 position, intensity;\nvarying vec2 off, dim;\nvarying float vIntensity;\nuniform vec2 viewport;\n\nvoid main(){\n    dim = abs(position.zw);\n' +
                    '    off = position.zw;\n    vec2 pos = position.xy + position.zw;\n   ' +
//                    ' off = vec2(-25,25);\n ' +
//                    'dim=vec2(20,50);\n ' +
                    ' vIntensity = intensity.x;\n    gl_Position = vec4((pos/viewport)*2.0-1.0, 0.0, 1.0);\n}',
                fragment: '#ifdef GL_FRAGMENT_PRECISION_HIGH\n   ' +
                    ' precision highp int;\n   ' +
                    ' precision highp float;\n#else\n   ' +
                    ' precision mediump int;\n   ' +
                    ' precision mediump float;\n#endif\n' +
                    ' varying vec2 off, dim;\n' +
                    ' varying float vIntensity;\nvoid main(){\n  ' +
                    '  float falloff = (1.0 - smoothstep(0.0, 1.0, length(off/dim)));\n  ' +
//                    '  falloff = 0.3; \n' +
                    '  float intensity = falloff*vIntensity;\n   ' +
//                    '  float intensity = vIntensity;\n   ' +
                    '  gl_FragColor = vec4(intensity,0.0,0,1.0);\n' +
                    ' }'
            });
            this.clampShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform float low, high;\nvoid main(){\n    gl_FragColor = vec4(clamp(texture2D(source, texcoord).rgb, low, high), 1.0);\n}'
            });
            this.multiplyShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform float value;\nvoid main(){\n    gl_FragColor = vec4(texture2D(source, texcoord).rgb*value, 1.0);\n}'
            });
            this.blurShader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + 'uniform vec2 viewport;\nvoid main(){\n    vec4 result = vec4(0.0);\n    for(int x=-1; x<=1; x++){\n        for(int y=-1; y<=1; y++){\n            vec2 off = vec2(x,y)/viewport;\n            //float factor = 1.0 - smoothstep(0.0, 1.5, length(off));\n            float factor = 1.0;\n            result += vec4(texture2D(source, texcoord+off).rgb*factor, factor);\n        }\n    }\n    gl_FragColor = vec4(result.rgb/result.w, 1.0);\n}'
            });
            this.nodeBack = new Node(this.gl, this.width, this.height);
            this.nodeFront = new Node(this.gl, this.width, this.height);
            this.vertexBuffer = this.gl.createBuffer();
            this.vertexSize = 8;
            this.maxPointCount = 1024 * 10;
            this.vertexBufferData = new Float32Array(this.maxPointCount * this.vertexSize * 6);
            this.vertexBufferViews = [];
            for (i = _i = 0, _ref = this.maxPointCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                this.vertexBufferViews.push(new Float32Array(this.vertexBufferData.buffer, 0, i * this.vertexSize * 6));
            }
            this.bufferIndex = 0;
            this.pointCount = 0;
        }

        Heights.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            this.nodeBack.resize(this.width, this.height);
            return this.nodeFront.resize(this.width, this.height);
        };

        Heights.prototype.update = function () {
            var intensityLoc, positionLoc;
            if (this.pointCount > 0) {
                this.gl.enable(this.gl.BLEND);
                this.nodeFront.use();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, this.vertexBufferViews[this.pointCount], this.gl.STREAM_DRAW);
                positionLoc = this.shader.attribLocation('position');
                intensityLoc = this.shader.attribLocation('intensity');
                this.gl.enableVertexAttribArray(1);
                this.gl.vertexAttribPointer(positionLoc, 4, this.gl.FLOAT, false, 8 * 4, 0 * 4);
                this.gl.vertexAttribPointer(intensityLoc, 4, this.gl.FLOAT, false, 8 * 4, 4 * 4);
                this.shader.use().vec2('viewport', this.width, this.height);
                this.gl.drawArrays(this.gl.TRIANGLES, 0, this.pointCount * 6);
                this.gl.disableVertexAttribArray(1);
                this.pointCount = 0;
                this.bufferIndex = 0;
                this.nodeFront.end();
                return this.gl.disable(this.gl.BLEND);
            }
        };

        Heights.prototype.clear = function () {
            this.nodeFront.use();
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
            return this.nodeFront.end();
        };

        Heights.prototype.clamp = function (min, max) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.clampShader.use().int('source', 0).float('low', min).float('high', max);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.multiply = function (value) {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.multiplyShader.use().int('source', 0).float('value', value);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.blur = function () {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.heatmap.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.nodeFront.bind(0);
            this.nodeBack.use();
            this.blurShader.use().int('source', 0).vec2('viewport', this.width, this.height);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.nodeBack.end();
            return this.swap();
        };

        Heights.prototype.swap = function () {
            var tmp;
            tmp = this.nodeFront;
            this.nodeFront = this.nodeBack;
            return this.nodeBack = tmp;
        };

        Heights.prototype.addVertex = function (x, y, xs, ys, intensity) {
            this.vertexBufferData[this.bufferIndex++] = x;
            this.vertexBufferData[this.bufferIndex++] = y;
            this.vertexBufferData[this.bufferIndex++] = xs;
            this.vertexBufferData[this.bufferIndex++] = ys;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            this.vertexBufferData[this.bufferIndex++] = intensity;
            return this.vertexBufferData[this.bufferIndex++] = intensity;
        };

        Heights.prototype.addPoint = function (x, y, size, intensity) {
            var s1, s2;
            if (size == null) {
                size = 50;
            }
            if (intensity == null) {
                intensity = 0.2;
            }
            if (this.pointCount >= this.maxPointCount - 1) {
                this.update();
            }
            y = this.height - y;
            s1 = size / 2;
            s2 = size / 2;
//            s1 = 25;
            this.addVertex(x, y, -s1, -s2, intensity);
            this.addVertex(x, y, +s1, -s2, intensity);
            this.addVertex(x, y, -s1, +s2, intensity);
            this.addVertex(x, y, -s1, +s2, intensity);
            this.addVertex(x, y, +s1, -s2, intensity);
            this.addVertex(x, y, +s1, +s2, intensity);
            return this.pointCount += 1;
        };

        return Heights;

    })();

    WebGLHeatmap = (function () {
        function WebGLHeatmap(_arg) {
            var alphaEnd, alphaRange, alphaStart, error, getColorFun, gradientTexture, image, intensityToAlpha, output, quad, textureGradient, _ref, _ref1,bgColor;
            _ref = _arg != null ? _arg : {}, this.canvas = _ref.canvas, this.width = _ref.width, this.height = _ref.height, intensityToAlpha = _ref.intensityToAlpha, gradientTexture = _ref.gradientTexture, alphaRange = _ref.alphaRange;
            bgColor = _ref.bgColor;
            if (!this.canvas) {
                this.canvas = document.createElement('canvas');
            }
            try {
                this.gl = this.canvas.getContext('experimental-webgl', {
                    depth: false,
                    antialias: false,
                    preserveDrawingBuffer: true
                });
                if (this.gl === null) {
                    this.gl = this.canvas.getContext('webgl', {
                        depth: false,
                        antialias: false,
                        preserveDrawingBuffer: true
                    });
                    if (this.gl === null) {
                        throw 'WebGL not supported';
                    }
                }
            } catch (_error) {
                error = _error;
                throw 'WebGL not supported';
            }
            if (window.WebGLDebugUtils != null) {
                console.log('debugging mode');
                this.gl = WebGLDebugUtils.makeDebugContext(this.gl, function (err, funcName, args) {
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                });
            }
            this.gl.enableVertexAttribArray(0);
            this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
            if (gradientTexture) {
                textureGradient = this.gradientTexture = new Texture(this.gl, {
                    channels: 'rgba'
                }).bind(0).setSize(2, 2).nearest().clampToEdge();
                if (typeof gradientTexture === 'string') {
                    image = new Image();
                    image.onload = function () {
                        return textureGradient.bind().upload(image);
                    };
                    image.src = gradientTexture;
                } else {
                    if (gradientTexture.width > 0 && gradientTexture.height > 0) {
                        textureGradient.upload(gradientTexture);
                    } else {
                        gradientTexture.onload = function () {
                            return textureGradient.upload(gradientTexture);
                        };
                    }
                }
                getColorFun = 'uniform sampler2D gradientTexture;\nvec3 getColor(float intensity){\n    return texture2D(gradientTexture, vec2(intensity, 0.0)).rgb;\n}';
            } else {
                textureGradient = null;
//                getColorFun = 'vec3 getColor(float intensity){\n' +
//                    '    vec3 blue = vec3(0.0, 0.0, 1.0);\n' +
//                '    vec3 cyan = vec3(0.0, 1.0, 1.0);\n' +
                getColorFun = 'vec3 getColor(float intensity){\n';
                if(bgColor){
                    getColorFun += ' vec3 blue = vec3('+parseInt(bgColor.r || 0.0)+', '+parseInt(bgColor.g || 0.0)+', '+parseInt(bgColor.b || 0.0)+');\n';
                }else{
                    getColorFun +='    vec3 blue = vec3(0.0, 0.0, 1.0);\n';
                }
                getColorFun += '    vec3 cyan = vec3(0.0, 1.0, 1.0);\n' +
                    '    vec3 green = vec3(0.0, 1.0, 0.0);\n' +
                    '    vec3 yellow = vec3(1.0, 1.0, 0.0);\n' +
                    '    vec3 red = vec3(1.0, 0.0, 0.0);\n\n' +
                    '    vec3 color = (\n' +
                    '        fade(-0.25, 0.25, intensity)*blue +\n' +
                    '        fade(0.0, 0.5, intensity)*cyan +\n' +
                    '        fade(0.25, 0.75, intensity)*green +\n' +
                    '        fade(0.5, 1.0, intensity)*yellow +\n' +
                    '        smoothstep(0.75, 1.0, intensity)*red\n' +
                    '    );\n' +
                    '    return color;\n' +
                    '}';
            }
            if (intensityToAlpha == null) {
                intensityToAlpha = true;
            }
            if (intensityToAlpha) {
                _ref1 = alphaRange != null ? alphaRange : [0, 1], alphaStart = _ref1[0], alphaEnd = _ref1[1];
                output = "vec4 alphaFun(vec3 color, float intensity){\n  " +
                    "  float alpha = smoothstep(" + (alphaStart.toFixed(8)) + ", " + (alphaEnd.toFixed(8)) + ", intensity);\n  " +
                    "  return vec4(color*alpha, alpha);\n" +
                    " }";
            } else {
                output = 'vec4 alphaFun(vec3 color, float intensity){\n   ' +
                    ' return vec4(color, 1.0);\n' +
                    ' }';
            }
            this.shader = new Shader(this.gl, {
                vertex: vertexShaderBlit,
                fragment: fragmentShaderBlit + ("float linstep(float low, float high, float value){\n   " +
                    " return clamp((value-low)/(high-low), 0.0, 1.0);\n}\n\n" +
                    " float fade(float low, float high, float value){\n   " +
                    " float mid = (low+high)*0.5;\n   " +
                    " float range = (high-low)*0.5;\n   " +
                    " float x = 1.0 - clamp(abs(mid-value)/range, 0.0, 1.0);\n   " +
                    " return smoothstep(0.0, 1.0, x);\n}\n\n" + getColorFun + "\n" + output + "\n\n" +
                    " void main(){\n   " +
                    "  float intensity = smoothstep(0.0, 1.0, texture2D(source, texcoord).r);\n  " +
                    "  vec3 color = getColor(intensity);\n   " +
                    "  gl_FragColor = alphaFun(color, intensity);\n" +
                    " }")
            });
            if (this.width == null) {
                this.width = this.canvas.offsetWidth || 2;
            }
            if (this.height == null) {
                this.height = this.canvas.offsetHeight || 2;
            }
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            this.gl.viewport(0, 0, this.width, this.height);
            this.quad = this.gl.createBuffer();
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            quad = new Float32Array([-1, -1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, 1, 0, 1, 1, -1, 0, 1, 1, 1, 0, 1]);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, quad, this.gl.STATIC_DRAW);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
            this.heights = new Heights(this, this.gl, this.width, this.height);
        }

        WebGLHeatmap.prototype.adjustSize = function () {
            var canvasHeight, canvasWidth;
            canvasWidth = this.canvas.offsetWidth || 2;
            canvasHeight = this.canvas.offsetHeight || 2;
            if (this.width !== canvasWidth || this.height !== canvasHeight) {
                this.gl.viewport(0, 0, canvasWidth, canvasHeight);
                this.canvas.width = canvasWidth;
                this.canvas.height = canvasHeight;
                this.width = canvasWidth;
                this.height = canvasHeight;
                return this.heights.resize(this.width, this.height);
            }
        };

        WebGLHeatmap.prototype.display = function () {
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quad);
            this.gl.vertexAttribPointer(0, 4, this.gl.FLOAT, false, 0, 0);
            this.heights.nodeFront.bind(0);
            if (this.gradientTexture) {
                this.gradientTexture.bind(1);
            }
            this.shader.use().int('source', 0).int('gradientTexture', 1);
            return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
        };

        WebGLHeatmap.prototype.update = function () {
            return this.heights.update();
        };

        WebGLHeatmap.prototype.clear = function () {
            return this.heights.clear();
        };

        WebGLHeatmap.prototype.clamp = function (min, max) {
            if (min == null) {
                min = 0;
            }
            if (max == null) {
                max = 1;
            }
            return this.heights.clamp(min, max);
        };

        WebGLHeatmap.prototype.multiply = function (value) {
            if (value == null) {
                value = 0.95;
            }
            return this.heights.multiply(value);
        };

        WebGLHeatmap.prototype.blur = function () {
            return this.heights.blur();
        };

        WebGLHeatmap.prototype.addPoint = function (x, y, size, intensity) {
            return this.heights.addPoint(x, y, size, intensity);
        };

        WebGLHeatmap.prototype.addPoints = function (items) {
            var item, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = items.length; _i < _len; _i++) {
                item = items[_i];
                _results.push(this.addPoint(item.x, item.y, item.size, item.intensity));
            }
            return _results;
        };

        return WebGLHeatmap;

    })();

    window.createWebGLHeatmap = function (params) {
        return new WebGLHeatmap(params);
    };
})(window);

var $HeatMap = function(obj){
    if(!obj){
        obj = {};
    }
    this.radius = obj.radius || 10;
    this.maxValue = obj.maxValue||1;
    this.minValue = obj.minValue||0;
    this.width = obj.width || 100; // 这个是最后生成的plane的大小
    this.height = obj.height || 100;
    this.intensityToAlpha = obj.intensityToAlpha||false;
    this.alphaRange = obj.alphaRange || [0,1];
    this.gradientTexture = obj.gradientTexture;
    this.canvasHeight = 100;
    this.canvasWidth = parseInt(this.canvasHeight*this.width/this.height); // 晕，原来canvas的尺寸不能为小数啊
    this.positionX = obj.positionX == undefined?this.width/2:parseFloat(obj.positionX);  //palan要放的位置，根据这个坐标来转换addPoint中的(x,y)将那个在3d中的坐标转成canvas中对应的点
    this.positionY = obj.positionY == undefined?this.height/2:parseFloat(obj.positionY);
    this.heatmap = createWebGLHeatmap({canvas: null,
        width: this.canvasWidth,
        height: this.canvasHeight,
        intensityToAlpha: this.intensityToAlpha,//false,
        alphaRange: this.alphaRange,//[0, 1] //[0, 0.05]
        gradientTexture: this.gradientTexture,
        bgColor:obj.bgColor
    });

};

mono.extend($HeatMap,Object,{

    // 环境温度，材料的属性(比如温度导热因子)，FF0000(红) - FFFF00(黄色) - 00FF00 - 00FFFF(浅蓝) - 0000FF
    createHeatMap: function () {
//    var heatmap = createWebGLHeatmap({canvas: null, intensityToAlpha:true, alphaRange: [0, 0.05]});
    },

    /**
     * 将canvas上的原点转成3D上对应的点，也就是最canvas上左下角(0,0)的对应的坐标
     * @private
     */
    _getOriginal: function () {
        var x = this.positionX - this.width / 2;
        var y = this.height / 2 + this.positionY;
        return {x: x, y: y};
    },

    _getOriginalX: function () {
        return this.positionX - this.width / 2;
    },

    _getOriginalY: function () {
//    return this.positionY - this.height/2;
        return this.height / 2 + this.positionY; // 由于3D中原点在左上角(2D中在左下角)，y的方向正好搞反了,所以算个原始x值时是+h/2
    },

    _transPositionX: function (x) {
        return (parseFloat(x) - this._getOriginalX()) * (this.canvasWidth / this.width);
    },

    _transPositionY: function (y) {
//    return parseFloat(y) - this.positionY;
        return (this._getOriginalY() - parseFloat(y)) * (this.canvasHeight / this.height);// 由于3D中原点在左上角(2D中在左下角)，y的方向正好搞反了
    },

    /**
     * 将3D中的宽度w换算成canvas上对应的w
     * @param w
     * @private
     */
    _transWidth: function (d) {
        var w = parseFloat(d);
        if (w <= 0) return 0;
        return w * this.canvasWidth / this.width;
    },

    _transHeight: function (l) {
        var h = parseFloat(l);
        if (h <= 0) {
            return 0;
        }
        return h * this.canvasHeight / this.height;
    },


    /**
     * 在区域附近生成热点
     * 注意：
     * 1、热点的数量
     * 2、范围
     * 3、热点的半径
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generateNearPointsForArea: function (x, y, w, l, value) {
        if (!w || !l) return;
        var count = parseInt(w * l) * 3; //在该区域附件的随机热点的数量
        var min_x = x - w / 2;
        var min_y = y - l / 2;
        if (min_x < 0 || min_y < 0) return;
        var index = 0;
        var near_area = 5;//this.radius/2;
        while (index < count) {
            var offset_x = (Math.random() * 2 - 1) * (near_area + w / 2); // -1~1之间
            var offset_y = (Math.random() * 2 - 1) * (near_area + l / 2);
            var p_x = 0, p_y = 0;
            p_x = x + offset_x;
            p_y = y + offset_y;
            if (p_x > min_x
                && p_x < (min_x + w)
                && p_y > min_y
                && p_y < (min_y + l)) { // 如果在区域里则剔除掉
                continue;
            }
            this.heatmap.addPoint(p_x, p_y, this.radius / 2, value / 30);
            index++;
        }
    },

// 随机点的数量根据radius的大小来确定，是radius的两倍,怎么样？
// 随机点离实际点最远的距离也根据radius的大小来确定，也是radius的两倍，怎么样?
// 但是，对于area的方式来讲，随机点的数量要远远大于单个点附近的随机点，其还应该跟据area的大小，离该区域最远的距离也应该远大于radius*2,并且自己的半径非常的小

    /**
     * 根据一个点，在该区域内和区域外都添加一定数量的点，但是在该区域内的点是均匀分布的，但是离该区域越近点就愈多，越远就越少
     * 注意，x,y,l,w都要换算成canvas的上的点和大小
     * @param obj
     */
    addPointWithArea: function (obj) {
        if (!obj) return;
        if (obj instanceof Array && obj.length > 0) {
            for (var i = 0; i < obj.length; i++) {
                arguments.callee(obj[i]);
            }
        } else {
            if (obj.type && obj.type === 'circle') {
                this._createCircleCloud(obj);
            } else {
                this._createRectCloud(obj);
            }
        }
        //    this._generateNearPointsForArea(t_x,t_y, w,l,value); //去掉在区域附近再创建随机点了
    },

    /**
     * 生成一个圆或者圆弧行的温度云图
     * @param obj
     * @private
     */
    _createCircleCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var radius = parseFloat(obj.radius) || 0;
        if (radius || radius <= 0)return;
    },

    /**
     * 生成一个rect(矩形)的温度云图
     * @param obj
     * @private
     */
    _createRectCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var w = parseFloat(obj.w) || 0;
        var l = parseFloat(obj.l) || 0;
        var value = parseFloat(obj.value) || 0;
        var axis = obj.axis; //旋转轴
        w = this._transWidth(w);
        l = this._transHeight(l);
        if (axis && axis == 'z') {
            var v_l = l;
            l = w;
            w = v_l;
        }
        if (!w && !l) {
            this.addPoint(x, y, value);
            return;
        }
        if (!l) {
            l = w;
        }
        if (!w) {
            w = l;
        }
        var t_x = this._transPositionX(x);
        var t_y = this._transPositionY(y);
        this._generatePointsForArea(t_x, t_y, w, l, value);
    },

    /**
     * 在区域内生成相关的热点，该热点是均匀的
     * 注意：
     * 1、区域内的热点的半径为radius的1/3;
     * 2、热点的值应该是实际值的1/X？
     * 3、热点的数量=区域的面积
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generatePointsForArea: function (x, y, w, l, value) {

//        this.heatmap.addPoint(x, y, 100, value);


         if(!w || !l) return;
         var min_x = x -  w/2;
         var min_y = y - l/2;
         var index = 0;
         var count = parseInt(w*l); //在该区域内所要生成的随机点的数量
         var offsetX = 1 , offsetY = 1;
         while(index < count){
         if(offsetX >= w){
         offsetX = 1;
         offsetY ++;
         }
         if(offsetX >= w && offsetY >= l){
         break;
         }
         var p_x = min_x + offsetX;
         var p_y = min_y + offsetY;
         this.heatmap.addPoint(p_x, p_y, this.radius, value/20);
         offsetX ++;
         index++;
         }

    },

    _generatePointsForArea_for_random: function (x, y, w, l, value) {
        if (!w || !l) return;
        w += 5;
        l += 5;
        var min_x = x - w / 2;
        var min_y = y - l / 2;
        var index = 0;
        var count = parseInt(w * l); //在该区域内所要生成的随机点的数量
        while (index < count) {
            var p_x = min_x + Math.random() * w;
            var p_y = min_y + Math.random() * l;
            this.heatmap.addPoint(p_x, p_y, this.radius, value / 30);
            index++;
        }
    },


    /**
     * 在某个点(x,y)附近加些云点，以(x,y)为圆心
     * @param x
     * @param y
     * @param value
     * @private
     */
    _paintAtCoord: function (x, y, value) {
        var count = 0;
//    this.heatmap.addPoint(x, y, this.radius, value);
//    return;
//    var max = parseInt(Math.random()*50);
        while (count < this.radius * 2) {
            var xoff = Math.random() * 2 - 1;
            var yoff = Math.random() * 2 - 1;
            var l = xoff * xoff + yoff * yoff;
            if (l > 1) {
                continue;
            }
            var ls = Math.sqrt(l);
            xoff /= ls;
            yoff /= ls;
            xoff *= 1 - l;
            yoff *= 1 - l;
            count += 1;
            this.heatmap.addPoint(x + xoff * this.radius * 2, y + yoff * this.radius * 2, this.radius, value / 10);
//        this.heatmap.addPoint(x+xoff, y+yoff, this.radius, value/30); // 由于现在的canvas才100*100
        }
    },

    addPoint: function (x, y, value, dic) {
        x = this._transPositionX(x);
        y = this._transPositionY(y);
//    if(value != null && value != undefined){
//        value = (parseFloat(value) - this.minValue)/(this.maxValue-this.minValue);
//        if(value < 0){
//            value = 0;
//        }
//    }
        var count = 0;
        while (count < 20) {
            var xoff = Math.random() * 2 - 1;
            var yoff = Math.random() * 2 - 1;
            var l = xoff * xoff + yoff * yoff;
            if (l > 1) {
                continue;
            }
            var ls = Math.sqrt(l);
            xoff /= ls;
            yoff /= ls;
            xoff *= 1 - l;
            yoff *= 1 - l;
            count += 1;
            this.heatmap.addPoint(x + xoff * 10, y + yoff * 5, this.radius, value / 20);
        }
    },

    addPoint1: function (x, y, value, radius) {
        x = this._transPositionX(x);
        y = this._transPositionY(y);
        if (value != null && value != undefined) {
            value = (parseFloat(value) - this.minValue) / (this.maxValue - this.minValue);
            if (value < 0) {
                value = 0;
            }
        }
        if (radius) {
            this.heatmap.addPoint(x, y, radius, value);
        } else {
            this._paintAtCoord(x, y, value);
        }
    },


    update: function () {
        this.heatmap.adjustSize(); // can be commented out for statically sized heatmaps, resize clears the map
        this.heatmap.update(); // adds the buffered points
        this.heatmap.display();
//    this.heatmap.multiply(0.9995);
//    this.heatmap.blur();
//    this.heatmap.clamp(0.0, 1.0); // depending on usecase you might want to clamp it
    },

    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
//        document.body.appendChild(this.heatmap.canvas); //需要放入requestAnimate中，否则多个field的话会有问题
        raf(function () {
            document.body.appendChild(self.heatmap.canvas);
            self.update();
//            console.log(self.heatmap.canvas.toDataURL());
            if (callback) {
                callback();
            }
        });
    },

    clear: function () {
        this.heatmap.clear();
    },

    getCanvas: function () {
        return this.heatmap.canvas;
    },

    getImage: function () {
        if (this.heatmap.canvas) {
//        var ctx = this.heatmap.canvas.getContext('2d');
//        ctx.fillStyle = 'rgba(0,0,255,1.0)';
//        ctx.fillRect(0,0,500,500);
            return this.heatmap.canvas.toDataURL();
        } else {
            console.log('getImage error!');
        }
    },

    getTemperatureBoard: function () {
        var board = new mono.Plane(this.width, this.height);
        board.setStyle('m.texture.repeat', new mono.Vec2(1, 1))
            .setStyle('m.type', 'basic')
//        .setStyle('m.texture.image', this.getImage())
//        .setStyle('m.transparent', true)
            .setStyle('m.side', 'both');
//    board.setStyle('m.color','#0000FF');
//    if (this.direction == 'h') {
        board.setRotation(90 * Math.PI / 180, 0, 0)
//    }
        var self = this;
        this.refresh(function () {
            board.setStyle('m.texture.image', self.getImage());
            document.body.removeChild(self.heatmap.canvas);
        });
        board.setPositionX(this.positionX);
        board.setPositionZ(this.positionY);
        return board;
    }

});

it.HeatMap3D = $HeatMap;




var $HeatMap2D = function(opt){
    this.defaultOptions = {
//        gradientColors: ['#0066FF', 'cyan', 'lime', 'yellow', 'red'],
//        gradientColors: [{color:'#0066FF',}, 'cyan', 'lime', 'yellow', 'red'],
                gradientColors: ['rgba(0, 102, 255, 0.9)', 'cyan', 'lime', 'yellow', 'red'],
//        gradientColors: ['blue', 'red'],
        minAlpha: 0.05,
        valueScale: 1,
        opacity: 1,
        positionX : null, //相对中心点的偏移量
        positionY : null, //相对中心点的偏移量
        width : 500,
        height : 500,
        canvasHeight : 500,
//        canvasWidth : 1000,
        blurSize: 30,
        withBg : true, // 没有热点的地方是不是染色，true表示染色，默认的是蓝色，false表示不染色，透明的
    };
    this.option = opt;
    if (opt) {
        for (var i in this.defaultOptions) {
            if (opt[i] !== undefined) {
                this.option[i] = opt[i];
            } else {
                this.option[i] = this.defaultOptions[i];
            }
        }
    } else {
        this.option = this.defaultOptions;
    }
    this.datas = [];
    this.heatMapCanvas = document.createElement('canvas');
    this.width = this.option.width;
    this.height = this.option.height;
    this.canvasHeight = this.option.canvasHeight;
    this.canvasWidth = this.option.canvasWidth = parseInt(this.canvasHeight*this.width/this.height); // 晕，原来canvas的尺寸不能为小数啊
    this.positionX = this.option.positionX == undefined?this.width/2:parseFloat(this.option.positionX);  //palan要放的位置，根据这个坐标来转换addPoint中的(x,y)将那个在3d中的坐标转成canvas中对应的点
    this.positionY = this.option.positionY == undefined?this.height/2:parseFloat(this.option.positionY);
    this.BRUSH_SIZE = 20*2*this.canvasHeight/this.height; // 也就是canvasWidth中的20*2哦
    this.GRADIENT_LEVELS = 256;
    this.withBg = this.option.withBg;

};

mono.extend($HeatMap2D,Object,{


    /**
     * 添加热点
     * @param x (x,y)是3D上的(x,z)点
     * @param y
     * @param value
     */
    addPoint : function(x,y,value){
        if(arguments.length === 1 && arguments[0] instanceof Array){
            var obj = arguments[0];
            x = obj[0];
            y = obj[1];
            value = obj[2];
        }
        x = this._transPositionX(x);
        y = this._transPositionY(y);
        this.datas.push([x,y,value]);
    },

    /**
     * 根据一个点，在该区域内和区域外都添加一定数量的点，但是在该区域内的点是均匀分布的，但是离该区域越近点就愈多，越远就越少
     * 注意，x,y,l,w都要换算成canvas的上的点和大小
     * @param obj
     */
    addPointWithArea: function (obj) {
        if (!obj) return;
        if (obj instanceof Array && obj.length > 0) {
            for (var i = 0; i < obj.length; i++) {
                arguments.callee(obj[i]);
            }
        } else {
//            if (obj.type && obj.type === 'circle') {
//                this._createCircleCloud(obj);
//            } else {
                this._createRectCloud(obj);
//            }
        }
    },

    /**
     * 生成一个rect(矩形)的温度云图
     * @param obj
     * @private
     */
    _createRectCloud: function (obj) {
        if (!obj) return;
        var x = parseFloat(obj.x) || 0;
        var y = parseFloat(obj.y) || 0;
        var w = parseFloat(obj.w) || 0;
        var l = parseFloat(obj.l) || 0;
        var value = parseFloat(obj.value) || 0;
        var axis = obj.axis; //旋转轴
        w = this._transWidth(w);
        l = this._transHeight(l);
        if (axis && axis == 'z') {
            var v_l = l;
            l = w;
            w = v_l;
        }
        if (!w && !l) {
            this.addPoint(x, y, value);
            return;
        }
        if (!l) {
            l = w;
        }
        if (!w) {
            w = l;
        }
        var t_x = this._transPositionX(x);
        var t_y = this._transPositionY(y);
        this._generatePointsForArea(t_x, t_y, w, l, value);
    },


    /**
     * 在区域内生成相关的热点，该热点是均匀的
     * 注意：
     * 1、区域内的热点的半径为radius的1/3;
     * 2、热点的值应该是实际值的1/X？
     * 3、热点的数量=区域的面积
     * @param x
     * @param y
     * @param w
     * @param l
     * @param value
     * @private
     */
    _generatePointsForArea: function (x, y, w, l, value) {
        if(!w || !l) return;
//        value = 0.8;
        var min_x = x -  w/2;
        var min_y = y - l/2;
//        var index = 0;
//        var count = parseInt(w*l); //在该区域内所要生成的随机点的数量
//        var offsetX = 1 , offsetY = 1;
        var size = this.BRUSH_SIZE;//+2;
        var columns  = parseInt(w/size);
        var rows = parseInt(l/(size));

        if(columns%2 ===0){
            columns = columns+1; //使之对称
        }
        if(rows%2 ===0){
            rows = rows+1;//使之对称
        }

        var deltaC=0 ,deltaR=0;
        if(columns > 5){
            deltaC=1;
            columns = columns+deltaC;//可添加往旁边的扩充点，它们的权值应该更小
        }
        if(rows > 5){
            deltaR=1;
            rows = rows+deltaR;//可添加往旁边的扩充点，它们的权值应该更小
        }

        var vx = x,vy = y;
//        this.datas.push([vx,vy,value]);
        for(var r = 0 ; r < rows; r++){
            var dy = vy + Math.pow(-1,r) * r/2 * size;
//            if(r === 0 ){ // 中心(x,y)
//                dy = vy;
//            }
            for(var c = 0 ; c < columns; c++ ){
                var dx = vx + Math.pow(-1,c) * c/2 * size;
                if(c===0){
                    dx = vx;
                }
                var deltaValue = 1;
                if( columns-c <= deltaC || rows -r < deltaR ){
//                    if(columns-c == 2 ||rows -r ==2 ){
//                        deltaValue = 0.5;
//                    }else{
                    deltaValue = 0.3;
//                    }
                }
                this.datas.push([dx,dy,value*deltaValue*Math.random()]);
            }
        }
        // 增加左右两边的点
//        for(var i = 0 ; i < rows ; i++){
//
//        }


//        for(var count = 0 ; count < rows*columns ; count++){
//            var x = min_x + Math.random() * w; //* this.BRUSH_SIZE;
//            var y = min_y + Math.random() * l;
//            this.datas.push([x,y,Math.random()]);
//        }

        // 增加左右两边的点
//        for(var i = 0 ; i < rows ; i++){
//            var x = min_x - 1.5*size;
//            var y = min_y + i*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            x = min_x - 2.5*size;
//            r_value = value*0.3*Math.random();
//            this.datas.push([x,y,r_value]);
//
//            x = min_x + (columns+1)*size; //* this.BRUSH_SIZE;
//            r_value = value*0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value*0.3*Math.random();
//            x = min_x + (columns+2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//        // 增加上下两边的点
//        for(var i = 0 ; i < columns ; i++){
//            var x = min_x + i*size; //* this.BRUSH_SIZE;
//            var y = min_y - 1.5*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3 * Math.random();
//            y = min_y - 2.5*size;
//            this.datas.push([x,y,r_value]);
//
//            y = min_y + (rows +1)*size;
//            r_value = value * 0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3*Math.random();
//            y = min_y + (rows +2)*size;
//            this.datas.push([x,y,r_value]);
//        }

    },
//    _generatePointsForArea: function (x, y, w, l, value) {
//        if(!w || !l) return;
//        value = 0.8;
//        var min_x = x -  w/2;
//        var min_y = y - l/2;
//        var size = this.BRUSH_SIZE;//+2;
//        var columns  = parseInt(w/size);
//        var rows = parseInt(l/(size));
//
//        //应该从中心往两边扩展，从min往max那边扩展不太好，如果只有一个点，那就不是落在中心的
//        var vx = x,vy = y;
//        this.datas.push([vx,vy,value*Math.random()]);
//        for(var r = 0 ; r < rows; r++){
//            var dy = vy + Math.pow(-1,r) * size;
//            for(var c = 0 ; c < columns; c++ ){
//                var dx = vx + Math.pow(-1,c) * size;
//                this.datas.push([dx,dy,value*Math.random()]);
//            }
//        }
//
////        for(var r = 0 ; r < rows; r++){
////            var y = min_y + r * size;
////            for(var c = 0 ; c < columns; c++ ){
////                var x = min_x + c * size;
////                this.datas.push([x,y,value*Math.random()]);
////            }
////        }
//
//        // 增加左右两边的点
//        for(var i = 0 ; i < rows ; i++){
//            var x = min_x - 1.5*size;
//            var y = min_y + i*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            x = min_x - 2.5*size;
//            r_value = value*0.3*Math.random();
//            this.datas.push([x,y,r_value]);
//
//            x = min_x + (columns+1)*size; //* this.BRUSH_SIZE;
//            r_value = value*0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value*0.3*Math.random();
//            x = min_x + (columns+2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//        // 增加上下两边的点
//        for(var i = 0 ; i < columns ; i++){
//            var x = min_x + i*size; //* this.BRUSH_SIZE;
//            var y = min_y - 1.5*size;
//            var r_value = value * 0.5 * Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3 * Math.random();
//            y = min_y - 2.5*size;
//            this.datas.push([x,y,r_value]);
//
//            y = min_y + (rows +1)*size;
//            r_value = value * 0.5*Math.random();
//            this.datas.push([x,y,r_value]);
//            r_value = value * 0.3*Math.random();
//            y = min_y + (rows +2)*size;
//            this.datas.push([x,y,r_value]);
//        }
//
//    },

    /**
     * 创建heatMap的Canvas
     * @returns {HTMLElement|*|$HeatMap2D.heatMapCanvas}
     */
    getCanvas: function (){
        var data = this.datas;
        var width = this.canvasWidth;
        var height = this.canvasHeight;
        var brush = this._createBrush();
        var gradient = this._createGradient();
        var r = this.BRUSH_SIZE + this.option.blurSize;

        var canvas = this.heatMapCanvas ;//= document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');

        var len = data.length;
        for (var i = 0; i < len; ++i) {
            var p = data[i];
            var x = p[0];
            var y = p[1];
            var value = p[2];
            // calculate alpha using value
            var alpha = Math.min(1, Math.max(value * this.option.valueScale
                || this.option.minAlpha, this.option.minAlpha));
            // draw with the circle brush with alpha
            ctx.globalAlpha = alpha;
            ctx.drawImage(brush, x - r, y - r);
        }

        // colorize the canvas using alpha value and set with gradient
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var pixels = imageData.data;
        var len = pixels.length / 4;
        while (len--) {
            var id = len * 4 + 3;
            var alpha = pixels[id] / 256;
            var colorOffset = Math.floor(alpha * (this.GRADIENT_LEVELS - 1));
            pixels[id - 3] = gradient[colorOffset * 4];     // red
            pixels[id - 2] = gradient[colorOffset * 4 + 1]; // green
            pixels[id - 1] = gradient[colorOffset * 4 + 2]; // blue
            if (this.withBg) {
                //            if(!pixels[id] || pixels[id] < 10){
                pixels[id] = 190; //205 这个透明度是整体的，全局
                //            }else{
                //                pixels[id] = 205;
                //            }
            } else {
                pixels[id] *= this.option.opacity; // alpha
            }  
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
    },

    /**
     * 创建原型的刷子
     * @private
     * @returns
     */
    _createBrush: function () {
        if (!this._brushCanvas) {
            this._brushCanvas = document.createElement('canvas');

            // set brush size
            var r = this.BRUSH_SIZE + this.option.blurSize;
            var d = r * 2;
            this._brushCanvas.width = d;
            this._brushCanvas.height = d;

            var ctx = this._brushCanvas.getContext('2d');

            // in order to render shadow without the distinct circle,
            // draw the distinct circle in an invisible place,
            // and use shadowOffset to draw shadow in the center of the canvas
            ctx.shadowOffsetX = d;
            ctx.shadowBlur = this.option.blurSize;
            // draw the shadow in black, and use alpha and shadow blur to generate
            // color in color map
            ctx.shadowColor = 'black';

            // draw circle in the left to the canvas
            ctx.beginPath();
            ctx.arc(-r, r, this.BRUSH_SIZE, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
        }
        return this._brushCanvas;
    },

    /**
     * 根据value获取颜色值
     * @returns {array}
     */
    _createGradient: function () {
        if (!this._gradientPixels) {
            var levels = this.GRADIENT_LEVELS;
            var canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = levels;
            var ctx = canvas.getContext('2d');
            var gradient = ctx.createLinearGradient(0, 0, 0, levels);
            var len = this.option.gradientColors.length;
            for (var i = 0; i < len; ++i) {
                if (typeof this.option.gradientColors[i] === 'string') {
                    gradient.addColorStop((i + 1) / len,
                        this.option.gradientColors[i]);
                } else {
                    gradient.addColorStop(this.option.gradientColors[i].offset,
                        this.option.gradientColors[i].color);
                }
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, levels);
            this._gradientPixels = ctx.getImageData(0, 0, 1, levels).data;
        }
        return this._gradientPixels;
    },

    /**
     * 将canvas上的原点转成3D上对应的点，也就是最canvas上左下角(0,0)的对应的坐标
     * @private
     */
    _getOriginal: function () {
        var x = this.positionX - this.width / 2;
        var y = this.height / 2 + this.positionY;
        return {x: x, y: y};
    },

    _getOriginalX: function () {
        return this.positionX - this.width / 2;
    },

    _getOriginalY: function () {
//    return this.positionY - this.height/2;
        return this.height / 2 + this.positionY; // 由于3D中原点在左上角(2D中在左下角)，y的方向正好搞反了,所以算个原始x值时是+h/2
    },

    _transPositionX: function (x) {
        return (parseFloat(x) - this._getOriginalX()) * (this.canvasWidth / this.width);
    },

    _transPositionY: function (y) {
//    return parseFloat(y) - this.positionY;
        return (this._getOriginalY() - parseFloat(y)) * (this.canvasHeight / this.height);// 由于3D中原点在左上角(2D中在左下角)，y的方向正好搞反了
    },

    /**
     * 将3D中的宽度w换算成canvas上对应的w
     * @param w
     * @private
     */
    _transWidth: function (d) {
        var w = parseFloat(d);
        if (w <= 0) return 0;
        return w * this.canvasWidth / this.width;
    },

    _transHeight: function (l) {
        var h = parseFloat(l);
        if (h <= 0) {
            return 0;
        }
        return h * this.canvasHeight / this.height;
    },

    clear : function(){
        this.datas = [];
    },

    /**
     * 由于之前在WebGL中非要将canvas加到了document中才能画。
     * 而此时没有用到webgl是可以不需要加到document中，可以考虑去掉，否则还画好后还得考虑从document中remove掉
     * @param callback
     */
    refresh: function (callback) {
        var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
        var self = this;
        raf(function () {
            document.body.appendChild(self.getCanvas());
            if (callback) {
                callback();
            }
        });
    },

    getImage: function () {
        if (this.heatMapCanvas) {
//        var ctx = this.heatmap.canvas.getContext('2d');
//        ctx.fillStyle = 'rgba(0,0,255,1.0)';
//        ctx.fillRect(0,0,500,500);
            return this.heatMapCanvas.toDataURL();
        } else {
            console.log('getImage error!');
        }
    },

    getTemperatureBoard: function () {
        var board = new mono.Plane(this.width, this.height);
        board.setStyle('m.texture.repeat', new mono.Vec2(1, 1))
              .setStyle('m.type', 'basic')
//        .setStyle('m.texture.image', this.getImage())
           // .setStyle('m.transparent', true)
           // .setStyle('m.type', 'phong')
           .setStyle('m.side', 'both');
           if(!this.withBg){
              board.setStyle('m.transparent', true);
              board.setStyle('m.type', 'phong');
           }
        board.setRotation(90 * Math.PI / 180, 0, 0);
        var self = this;
        this.refresh(function () {
            board.setStyle('m.texture.image', self.heatMapCanvas); //直接用canvas，每次生成一个image，重新刷新后不会被删除
            // board.setStyle('m.texture.image', self.getImage());
            document.body.removeChild(self.heatMapCanvas);
        });
        // (this.positionX,this.positionY)相对于中心点的偏移量，因此其并不是物理坐标，默认的这么设置，
        // 若温度场的parent的中心点不是坐标中心点时，需要在获取后重新设置一下
        board.setPositionX(this.positionX);
        board.setPositionZ(this.positionY);
        return board;
    }

});

it.HeatMap = $HeatMap2D;


/**
 * 权限管理模块
 * 
 * user-asset-power
 * user其实可以不用了，就当前用户，powerMap就保存当前user的权限即可，保存其他的user也没有何用，角色都不用了
 *
 * 权限级别：0、可见可操作；1、虚化；2、不可见；3、不创建3D对象(这一级别估计会不太好处理，对于已创建的对象和在当前场景时动态的创建的问题)
 *         没有的话，级别也是0
 *
 * 注意父子关系：当parent的权限级别一定要低于孩子的权限级别，否则孩子的级别就是其父亲对应的权限级别
 * 
 **/
var $DRMManager = function(sceneManager){
	this.sceneManager = sceneManager;
	this.dataManager = this.sceneManager.dataManager;
	// this.userMap = {};
	this.dataPowerMap = {}; //资产权限Map
	this.virtualLevel = new it.VirtualManager(this.sceneManager); // level1
	this.visibleLevel = new it.VisibleManager(this.sceneManager); // level2
	this.initDrmListener();
	this._dRMManagerChangeDispatcher = new mono.EventDispatcher();
	this.registerDRM();
};

mono.extend($DRMManager,Object,{

	 registerDRM : function(){
	 	// if (this.drmListener) {
	 	this.addDRMChangeListener(this.drmListener);
	 	// }
	 	this.sceneManager.viewManager3d.addVisibleFilter(this.visibleLevel);
	 	this.sceneManager.viewManager3d.addMaterialFilter(this.virtualLevel);
	 },

	 unRegister : function(){
	 	this.removeDRMChangeListener(this.drmListener);
	 	this.sceneManager.viewManager3d.removeVisibleFilter(this.visibleLevel);
	 	this.sceneManager.viewManager3d.removeMaterialFilter(this.virtualLevel);
	 },

	initDrmListener: function() {
		var self = this;
		this.drmListener = function(e) {
			var kind = e.kind;
			var dataId = e.dataId;
			var oldLevel = e.oldLevel;
			var newLevel = e.newLevel;
			if (!kind) {
				return;
			} else if (kind == 'add') { //这个add也可能是update，到底是不是就看oldLevel的值
				self._addOrUpdateAction(dataId,oldLevel,newLevel);
			} else if (kind == 'remove') {
				self._removeAction(dataId,oldLevel,newLevel);
			} else if (kind == 'clear') {
				self._clearAction();
			}
		};
	},

    /**
     * 增加或更新dataId资产的权限
     * 注意：其孩子的权限问题，当设置父亲权限时，孩子的各filter也要做相应的处理；但是孩子的权限map发生了改变的话，也需要check其parent的权限map
     * 
     */
	_addOrUpdateAction: function(dataId, oldLevel, newLevel) {
		if (!dataId) {
			return;
		}
		var data = this.dataManager.getDataById(dataId);
		// if (oldLevel != undefined) { // update
		// 不管是否update，都统一处理
		var parentLevel = this.getParentLevel(data)||0; //先祖宗的权限level
		if (parentLevel <= newLevel) {
			if (newLevel == 1) {
				this.setLevel1ForData(data);
			} else if (newLevel == 2) {
				this.setLevel2ForData(data);
			} else if (newLevel == 3) {
				this.setLevel3ForData(data);
			} else { //newLevel == 0
				this.setLevel0ForData(data);
			}
			this.sceneManager.viewManager3d.clearVisibleMap(); //当visibleFilter发生了改变时，需要把visibleMap清空，否则不能马上生效(非得场景切换后才生效)
		}

	},
    
    /**
     * 获取离其最近的祖宗的权限Level
     * 改成其祖宗中级别最高的那个
     */
	getParentLevel : function(dataOrId){
		if (!dataOrId) {
			return 0;
		}
		var data = null;
		if (dataOrId instanceof it.Data) {
			data = dataOrId;
		}else {
			data = this.dataManager.getDataById(dataOrId);
		}
		if (!data) {
			return 0;
		}
		var parent = this.dataManager.getDataById(data.getParentId());
		if (!parent) {
			return 0;
		}
		if (this.dataPowerMap[parent.getId()] != undefined) {
			var level = this.dataPowerMap[parent.getId()];
			if (level == 3 ) { // 3是最高级别的了，直接返回，不在递归
				return 3;
			}
			var ancLevel = this.getParentLevel(parent,this);
			if (ancLevel > level) {
				return ancLevel;
			}else{
				return level;
			}
		}else {
			return this.getParentLevel(parent,this);
		}
		
	},

    /**
     * 给data设置level1级权限：虚幻
     */
	setLevel1ForData : function(data){
		if (!data) {
			return;
		}
		this._removeFromLevel3(data); //从level3的管理器中去除
		this._removeFromLevel2(data); //从level2的管理器中去除
		this.virtualLevel.add(data); // 加到了level1中，也要从高的level的管理器中去掉
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && (!childLevel || childLevel <= 1)){//当孩子没有设置过权限，或权限level比level1小时，则应该被parent权限覆盖
                    this.setLevel1ForData(child,this);
                }else if (childLevel == 2) {
                	this.setLevel2ForData(child,this);
                }else if (childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},

    /**
     * 给data设置level2级权限：不可见
     */
	setLevel2ForData : function(data){
		if (!data) {
			return ;
		}
		this._removeFromLevel3(data); //从level3的管理器中去除
		this.visibleLevel.setVisible(data,false);
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && (!childLevel || childLevel <= 2)){//当孩子没有设置过权限，或权限level比level1小时，则应该被parent权限覆盖
                    this.setLevel2ForData(child,this);
                }else if(childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},
    
    /**
     * 给data设置level3级权限：不创建3D对象
     * 这里需要注意的太多了：1、一开始要堵住入口；
                          2、已经创建了怎么整（从缓存中找到，删除父子关系，并删除）
                          3、已经创建了并且正在显示着怎么整（踢出父子关系，从box中删除）
     * 
     */
	setLevel3ForData : function(data){
		if (!data) {
			return ;
		}
	},

    /**
     * 给data设置level0级权限，由于默认的是0级，所以这里就处理清空
     */
	setLevel0ForData : function(data){
		if (!data) {
			return ;
		}
		this._removeFromLevel3(data);
		this._removeFromLevel2(data);
		this._removeFromLevel1(data);
		var children = data.getChildren();
        if(children && children.size() > 0){
            for(var i = 0 ; i < children.size(); i++){
                var child = children.get(i);
                var childLevel = this.dataPowerMap[child.getId()];
                if(child && !childLevel){//当孩子没有设置过权限，或权限为0时，则应该被parent权限覆盖(其实这里也就是清空)
                    this.setLevel0ForData(child,this);
                }else if (childLevel == 1) {
                	this.setLevel1ForData(child,this);
                }else if (childLevel == 2){
                	this.setLevel2ForData(child,this);
                }else if (childLevel == 3){
                	this.setLevel3ForData(child,this);
                }
            }
        }
	},

	_removeFromLevel3 : function(data){

	},

	_removeFromLevel2 : function(data){
		this.visibleLevel.setVisible(data,true); 
	},

	_removeFromLevel1 : function(data){
		this.virtualLevel.remove(data);
	},
    
    /**
     * 从level0管理器中去除，由于默认的是level0，这里可以do nothing。。。
     */
	_removeFromLevel0 : function(data){

	},

	_clearLevel3 : function(){

	},

	_clearLevel2 : function(){
		this.visibleLevel.clear();
	},

	_clearLevel1 : function(){
		this.virtualLevel.clearAll();
	},

	_clearLevel0 : function(){
		// do nothing......
	},

    /** 
     * 删除资产权限的处理
     */
	_removeAction : function(dataId,oldLevel){
		if (!dataId) {
			return;
		}
		var data = this.dataManager.getDataById(dataId);
		var parentLevel = this.getParentLevel(data) || 0; //先祖宗的权限level
		if (parentLevel < oldLevel) {
			if (parentLevel == 1) {
				this.setLevel1ForData(data);
			} else if (parentLevel == 2) {
				this.setLevel2ForData(data);
			} else if (parentLevel == 3) {
				this.setLevel3ForData(data);
			} else { //newLevel == 0 //理论上这条不可能会被执行
				this.setLevel0ForData(data);
			}
			this.sceneManager.viewManager3d.clearVisibleMap(); 
		}
	},

	_clearAction : function(){
		this._clearLevel0();
		this._clearLevel1();
		this._clearLevel2();
		this._clearLevel3();
		this.sceneManager.viewManager3d.clearVisibleMap(); 
	},

    /**
     * 设置默认的级别
     * 也是统一将所有的data都设置成同一level级别
     * 这样的效率不知道会怎样
     */
	initDefaultLevel : function(level){
		var dataMap = this.dataManager._dataMap;
		for(var id in dataMap){
			this._addOrUpdateAction(id,null,level);
		}
	},

     // /**
     //  * 给当前user设置dataOrId资产的权限
     //  */
     // add : function(dataOrId,powerLevel){
     // 	this.update(dataOrId,powerLevel);
     // },

     /**
      * 给当前user设置dataOrId资产的权限
      */
	 update : function(dataOrId,powerLevel){
	 	if (!dataOrId) {
	 		return ;
	 	}
	 	if (powerLevel == null || powerLevel == undefined) {
	 		console.log('please input right powerLevel, like 0,1,2,3');
	 	}
	 	var dataId = dataOrId;
	 	if (dataOrId instanceof it.Data) {
	 		dataId = dataOrId.getId();
	 	}
	 	var oldLevel = this.dataPowerMap[dataId];
	 	this.dataPowerMap[dataId] = powerLevel;
		this._dRMManagerChangeDispatcher.fire({
			kind: 'add', //这个add可能包含着update
			dataId : dataId,
			oldLevel: oldLevel,
			newLevel: powerLevel
		});
	 },
     
     /**
      * 删除资产权限
      */
	 remove : function(dataOrId){
	 	if (!dataOrId) {
	 		return;
	 	}
	 	var dataId = dataOrId;
	 	if (dataOrId instanceof it.Data) {
	 		dataId = dataOrId.getId();
	 	}
	 	if (this.dataPowerMap[dataId] == undefined) {
	 		return ;
	 	}
	 	var oldLevel = this.dataPowerMap[dataId];
	 	delete this.dataPowerMap[dataId];
	 	this._dRMManagerChangeDispatcher.fire({
			kind: 'remove',
			dataId: dataId,
			oldLevel: oldLevel
		});
	 },

     /**
      * 清除所有的权限，清除后所有的资产的权限级别都是0
      */
	 clear : function(){
	 	this.dataPowerMap = {};
	 	this._dRMManagerChangeDispatcher.fire({
			kind: 'clear'
		});
	 },

	 addDRMChangeListener : function(listener, scope, ahead){
	 	this._dRMManagerChangeDispatcher.add(listener, scope, ahead);
	 },

	 removeDRMChangeListener : function(listener, scope, ahead){
	 	this._dRMManagerChangeDispatcher.remove(listener, scope);
	 },


});

it.DRMManager = $DRMManager;



it.PopMenuManager = function(sceneManager){
    this.sceneManager = sceneManager;
    this.getMenuItemsFunction = null;
    this._initPopMenu();
};

mono.extend(it.PopMenuManager,Object,{
     _initPopMenu : function(){
     	var self = this,network = this.sceneManager.network3d;
        var popupMenu = this._popupMenu = new twaver.controls.PopupMenu(network.getRootView());
        popupMenu.setBackground('#90C3D4');
        popupMenu.setBorder("2px solid #90C3D4");
        var oShow = popupMenu.show;
        popupMenu.show = function(e){// 增加一个偏移
           oShow.call(this,e);
           var view = this._view;
           var style = view.style;
            style.left = (parseInt(style.left) + 1) + 'px';
            style.top = (parseInt(style.top) + 1)+ 'px';
        };
        initPopupMenu();
        function initPopupMenu(){
            var lastData, box = network.getDataBox(), event;
            popupMenu.onMenuShowing = function(e){
               event = e;
                var first = network.getFirstElementByMouseEvent(e, false, function (data) {
                    var flag = data.getClient('mainVisible');
                    var mainObj = Utils.isNotNull(flag);
                    return !mainObj;
                });
                var items = [];
                if(first){
                   lastData = first.element;
                   var data = main.sceneManager.getNodeData(lastData);
                   items = self.getMenuItems(lastData,data,event,first);
                }else{
                	items = self.getMenuItems(null,null,event,null);
                }
                if(items && items.length > 0){
                	popupMenu.setMenuItems(items);
                	return true;
                }
                return false;
            };
        };


     },

     getPopupMenu : function(){
     	return this._popupMenu;
     },
     // [{label : 增加机柜,action : function(menuItem){},group:none}]
     getMenuItems : function(element,data,event,eventObject){
        if(this.getMenuItemsFunction){
        	return this.getMenuItemsFunction(element,data,event,eventObject);
        }
        return [];
     },
});
})(window);